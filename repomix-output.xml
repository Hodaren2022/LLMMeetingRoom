This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.codeflicker/preview/start-command.bat
.gitignore
.kwaipilot/specs/adaptive-responsive-design/design.md
.kwaipilot/specs/adaptive-responsive-design/requirements.md
.kwaipilot/specs/responsive-mobile-optimization/design.md
.kwaipilot/specs/responsive-mobile-optimization/requirements.md
.kwaipilot/specs/virtual-meeting-room-ui/design.md
.kwaipilot/specs/virtual-meeting-room-ui/requirements.md
.kwaipilot/specs/virtual-meeting-room/design.md
.kwaipilot/specs/virtual-meeting-room/requirements.md
2025-11-07 14 10 44.png
2025-11-07 14 10 51.png
docs/responsive-testing.md
eslint.config.mjs
next.config.ts
package.json
playwright.config.ts
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
src/app/api/debate/enhanced/route.ts
src/app/api/debate/route.ts
src/app/api/generate-topic/route.ts
src/app/api/health/route.ts
src/app/api/search/enhanced/route.ts
src/app/api/search/route.ts
src/app/favicon.ico
src/app/globals.css
src/app/layout.tsx
src/app/page.tsx
src/app/personas/page.tsx
src/components/ConsensusDisplay.tsx
src/components/DebateControlPanel.tsx
src/components/DebateRoom.tsx
src/components/DebateViewer.tsx
src/components/EditableTopicHeader.tsx
src/components/index.ts
src/components/MobileNavigation.tsx
src/components/ModeratorSelectionPanel.tsx
src/components/PersonaCard.tsx
src/components/PersonaEditor.tsx
src/components/PersonaManager.tsx
src/components/PersonaSelectionPanel.tsx
src/components/ResponsiveImage.tsx
src/components/TouchComponents.tsx
src/components/WebVitalsProvider.tsx
src/hooks/index.ts
src/hooks/useContainerQuery.ts
src/hooks/useDebateOrchestrator.ts
src/hooks/useSwipe.ts
src/services/apiService.ts
src/services/consensusManager.ts
src/services/debateOrchestrator.ts
src/services/geminiService.ts
src/services/geminiUtils.ts
src/services/personaEngine.ts
src/services/topicService.ts
src/stores/additionalStores.ts
src/stores/enhancedMeetingRoomStore.ts
src/stores/index.ts
src/stores/meetingRoomStore.ts
src/styles/components.css
src/types/gemini.ts
src/types/index.ts
src/types/store.ts
src/utils/fluidTypography.ts
src/utils/index.ts
src/utils/webVitalsMonitor.ts
tailwind.config.ts
tests/responsive.spec.ts
tests/touch-interactions.spec.ts
tests/utils/responsive-test-helper.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".codeflicker/preview/start-command.bat">
#!/usr/bin/env bash
npm run dev
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path=".kwaipilot/specs/adaptive-responsive-design/design.md">
# 自適應響應型物件設計文檔

## 概述

本設計文檔詳細說明了虛擬會議室項目中自適應響應型物件設計系統的技術實現方案。該系統將利用現代 CSS 技術，包括容器查詢、流體排版、CSS Grid/Flexbox 高級佈局等，創建一個真正適應性強的用戶界面。

## 系統架構

### 響應式設計層次結構

```mermaid
graph TD
    A[全局響應式系統] --> B[容器查詢層]
    A --> C[媒體查詢層]
    B --> D[組件級響應式]
    C --> E[佈局級響應式]
    D --> F[PersonaCard]
    D --> G[DebateRoom]
    D --> H[MobileNavigation]
    E --> I[Grid 佈局]
    E --> J[Flexbox 佈局]
```

### 技術棧整合

- **Next.js 16**: 利用最新的 Image 組件和性能優化
- **TailwindCSS 4**: 使用新的容器查詢支持和改進的響應式工具
- **CSS 自定義屬性**: 實現動態主題和響應式變量
- **Web Vitals 監控**: 集成性能監控和優化

## 核心設計模式

### 1. 容器查詢響應式系統

#### 實現策略

```css
/* 容器查詢基礎設置 */
.component-container {
  container-type: inline-size;
  container-name: component;
}

/* PersonaCard 容器查詢 */
.persona-card {
  /* 窄容器佈局 */
  display: flex;
  flex-direction: column;
  
  @container component (min-width: 300px) {
    /* 中等容器佈局 */
    flex-direction: row;
    align-items: center;
  }
  
  @container component (min-width: 500px) {
    /* 寬容器佈局 */
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 1rem;
  }
}
```

#### 組件適配矩陣

| 容器寬度 | PersonaCard 佈局 | DebateRoom 佈局 | Navigation 佈局 |
|---------|-----------------|----------------|----------------|
| < 300px | 垂直堆疊 | 單列 | 漢堡菜單 |
| 300-500px | 水平排列 | 雙列 | 底部標籤 |
| > 500px | 網格佈局 | 三列 | 側邊欄 |

### 2. 流體排版系統

#### 排版比例計算

使用數學函數計算流體排版參數：

```
v = (100 * (y2 - y1)) / (x2 - x1)
r = (x1 * y2 - x2 * y1) / (x1 - x2)
```

其中：
- v: viewport 寬度值 (vw)
- r: 相對大小值 (rem)
- x1, x2: 起始和結束視窗寬度
- y1, y2: 起始和結束字體大小

#### 實際應用

```css
/* 主標題流體排版 */
.heading-primary {
  font-size: clamp(1.5rem, 2vw + 1rem, 3rem);
  line-height: clamp(1.2, 1vw + 1.1, 1.4);
}

/* 正文流體排版 */
.body-text {
  font-size: clamp(0.875rem, 1vw + 0.5rem, 1.125rem);
  line-height: clamp(1.4, 0.5vw + 1.3, 1.6);
}
```

### 3. 自適應圖片系統

#### Next.js Image 組件優化

```tsx
// 響應式圖片組件
const ResponsiveImage: React.FC<ResponsiveImageProps> = ({
  src,
  alt,
  priority = false,
  className
}) => {
  return (
    <Image
      src={src}
      alt={alt}
      fill
      priority={priority}
      sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
      className={`object-cover ${className}`}
      quality={75}
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
    />
  );
};
```

#### 圖片優化策略

```mermaid
flowchart LR
    A[原始圖片] --> B{設備檢測}
    B -->|移動設備| C[WebP 小尺寸]
    B -->|平板設備| D[WebP 中尺寸]
    B -->|桌面設備| E[AVIF 大尺寸]
    C --> F[懶加載]
    D --> F
    E --> F
    F --> G[性能監控]
```

### 4. 高級佈局系統

#### Grid + Flexbox 混合佈局

```css
/* 主佈局 Grid */
.main-layout {
  display: grid;
  grid-template-areas:
    "header header header"
    "sidebar main aside"
    "footer footer footer";
  grid-template-columns: 250px 1fr 200px;
  grid-template-rows: auto 1fr auto;
  min-height: 100vh;
  gap: 1rem;
}

/* 內容區域 Flexbox */
.content-area {
  grid-area: main;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

/* 響應式調整 */
@media (max-width: 1024px) {
  .main-layout {
    grid-template-areas:
      "header"
      "main"
      "footer";
    grid-template-columns: 1fr;
  }
}
```

#### 自適應網格系統

```css
/* 自適應卡片網格 */
.card-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: clamp(1rem, 2vw, 2rem);
  padding: clamp(1rem, 3vw, 3rem);
}

/* 容器查詢優化 */
@container (min-width: 600px) {
  .card-grid {
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  }
}
```

## 組件設計規範

### PersonaCard 響應式重構

```tsx
const PersonaCard: React.FC<PersonaCardProps> = ({ persona, ...props }) => {
  return (
    <div className="persona-card-container" style={{ containerType: 'inline-size' }}>
      <div className="persona-card">
        {/* 頭像區域 - 容器查詢響應式 */}
        <div className="avatar-section">
          <ResponsiveImage
            src={persona.avatar}
            alt={persona.name}
            className="avatar"
          />
        </div>
        
        {/* 信息區域 - 流體排版 */}
        <div className="info-section">
          <h3 className="persona-name">{persona.name}</h3>
          <p className="persona-role">{persona.role}</p>
        </div>
        
        {/* 控制區域 - 觸摸優化 */}
        <div className="controls-section">
          {/* 觸摸友好按鈕 */}
        </div>
      </div>
    </div>
  );
};
```

### MobileNavigation 手勢增強

```tsx
const MobileNavigation: React.FC<MobileNavigationProps> = ({ ...props }) => {
  const swipeHandlers = useSwipe({
    onSwipeLeft: () => setDrawerOpen(false),
    onSwipeRight: () => setDrawerOpen(true),
  }, {
    threshold: 50,
    preventDefaultTouchmoveEvent: true
  });

  return (
    <div className="mobile-nav-container">
      {/* 手勢感應區域 */}
      <div className="swipe-area" {...swipeHandlers}>
        {/* 導航內容 */}
      </div>
    </div>
  );
};
```

## 性能優化策略

### Web Vitals 監控實現

```typescript
// Web Vitals 監控服務
class WebVitalsMonitor {
  private metrics: Map<string, number> = new Map();
  
  constructor() {
    this.initializeMonitoring();
  }
  
  private initializeMonitoring() {
    // LCP 監控
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.metrics.set('LCP', lastEntry.startTime);
      this.reportMetric('LCP', lastEntry.startTime);
    }).observe({ entryTypes: ['largest-contentful-paint'] });
    
    // INP 監控
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.metrics.set('INP', entry.processingStart - entry.startTime);
        this.reportMetric('INP', entry.processingStart - entry.startTime);
      }
    }).observe({ entryTypes: ['event'] });
    
    // CLS 監控
    new PerformanceObserver((list) => {
      let clsValue = 0;
      for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      }
      this.metrics.set('CLS', clsValue);
      this.reportMetric('CLS', clsValue);
    }).observe({ entryTypes: ['layout-shift'] });
  }
  
  private reportMetric(name: string, value: number) {
    // 發送到分析服務
    analytics.track('web_vital', { metric: name, value });
    
    // 性能警告
    if (this.isMetricPoor(name, value)) {
      console.warn(`Poor ${name} performance: ${value}`);
    }
  }
  
  private isMetricPoor(metric: string, value: number): boolean {
    const thresholds = {
      LCP: 2500,  // 2.5s
      INP: 200,   // 200ms
      CLS: 0.1    // 0.1
    };
    return value > thresholds[metric as keyof typeof thresholds];
  }
}
```

### 代碼分割和懶加載

```typescript
// 組件懶加載
const PersonaManager = lazy(() => import('@/components/PersonaManager'));
const DebateRoom = lazy(() => import('@/components/DebateRoom'));

// 路由級代碼分割
const PersonasPage = lazy(() => import('@/app/personas/page'));

// 動態導入工具函數
const loadUtils = () => import('@/utils/advanced-utils');
```

## 測試策略

### 響應式測試矩陣

| 設備類型 | 屏幕尺寸 | 測試重點 | 工具 |
|---------|---------|---------|------|
| 手機 | 320-480px | 觸摸交互、性能 | Chrome DevTools |
| 平板 | 768-1024px | 佈局轉換、手勢 | BrowserStack |
| 桌面 | 1280px+ | 複雜佈局、功能完整性 | Playwright |

### 自動化測試實現

```typescript
// 響應式視覺回歸測試
describe('Responsive Design Tests', () => {
  const viewports = [
    { width: 320, height: 568, name: 'mobile' },
    { width: 768, height: 1024, name: 'tablet' },
    { width: 1920, height: 1080, name: 'desktop' }
  ];
  
  viewports.forEach(viewport => {
    test(`PersonaCard layout at ${viewport.name}`, async ({ page }) => {
      await page.setViewportSize(viewport);
      await page.goto('/personas');
      
      // 等待容器查詢生效
      await page.waitForTimeout(100);
      
      // 截圖比較
      await expect(page.locator('.persona-card')).toHaveScreenshot(
        `persona-card-${viewport.name}.png`
      );
    });
  });
});
```

## 邊界情況和特殊處理

### 容器查詢降級策略

```css
/* 不支持容器查詢的瀏覽器降級 */
.persona-card {
  /* 默認移動佈局 */
  display: flex;
  flex-direction: column;
}

/* 媒體查詢降級 */
@media (min-width: 640px) {
  .persona-card {
    flex-direction: row;
  }
}

/* 容器查詢增強 */
@supports (container-type: inline-size) {
  .persona-card-container {
    container-type: inline-size;
  }
  
  @container (min-width: 300px) {
    .persona-card {
      flex-direction: row;
    }
  }
}
```

### 性能降級處理

| 條件 | 降級策略 | 實現方式 |
|------|---------|---------|
| 低端設備 | 禁用動畫 | `prefers-reduced-motion` |
| 慢網絡 | 簡化佈局 | Network Information API |
| 舊瀏覽器 | 媒體查詢降級 | `@supports` 檢測 |

這個設計文檔提供了完整的技術實現方案，確保自適應響應型物件設計系統能夠在各種設備和條件下提供最佳的用戶體驗。
</file>

<file path=".kwaipilot/specs/adaptive-responsive-design/requirements.md">
# 自適應響應型物件設計需求文檔

## 簡介

本需求文檔旨在為虛擬會議室項目實現現代化的自適應響應型物件設計系統。該系統將利用最新的 CSS 技術，包括容器查詢、流體排版、自適應圖片等先進技術，確保所有組件在不同設備和屏幕尺寸下都能提供最佳的用戶體驗。

## 需求

### 需求 1：容器查詢響應式組件系統

**用戶故事：** 作為開發者，我希望組件能夠根據其容器大小而非視窗大小進行響應式調整，以便在複雜佈局中實現更精確的適應性。

#### 驗收標準

1. WHEN 組件被放置在不同大小的容器中 THEN 組件應該根據容器尺寸自動調整佈局和樣式 <kreference link="https://www.joshwcomeau.com/css/container-queries-introduction/" index="1">[^1]</kreference>
2. WHEN PersonaCard 組件在窄容器中顯示 THEN 應該使用垂直堆疊佈局
3. WHEN PersonaCard 組件在寬容器中顯示 THEN 應該使用水平佈局
4. WHEN 容器查詢條件改變 THEN 組件過渡應該平滑且無閃爍
5. WHEN 使用容器查詢 THEN 必須避免無限循環問題，確保測量的屬性不會被查詢內的樣式影響

### 需求 2：流體排版系統

**用戶故事：** 作為用戶，我希望文字大小能夠在不同設備間平滑縮放，而不是在特定斷點突然跳躍，以獲得更一致的閱讀體驗。

#### 驗收標準

1. WHEN 視窗寬度在 320px 到 1920px 之間變化 THEN 字體大小應該使用 CSS clamp() 函數平滑縮放 <kreference link="https://www.smashingmagazine.com/2022/01/modern-fluid-typography-css-clamp/" index="2">[^2]</kreference>
2. WHEN 用戶調整瀏覽器字體大小 THEN 流體排版應該相應調整以保持可訪問性
3. WHEN 計算流體排版參數 THEN 應該使用 rem 單位作為最小值和最大值以支持用戶偏好
4. WHEN 設置首選值 THEN 應該結合 vw 和 rem 單位以實現響應式和可訪問性的平衡
5. WHEN 流體排版達到最小或最大值 THEN 應該保持在該值而不繼續縮放

### 需求 3：自適應圖片和媒體優化

**用戶故事：** 作為用戶，我希望圖片能夠根據我的設備和網絡條件自動優化，以獲得最佳的加載速度和視覺質量。

#### 驗收標準

1. WHEN 使用 Next.js Image 組件 THEN 應該自動生成多種尺寸的圖片並選擇最適合的版本 <kreference link="https://www.contentful.com/blog/nextjs-image-component/" index="3">[^3]</kreference>
2. WHEN 圖片在移動設備上顯示 THEN 應該提供較小尺寸的圖片以節省帶寬
3. WHEN 圖片支持現代格式 THEN 應該優先使用 WebP 和 AVIF 格式
4. WHEN 圖片位於視窗外 THEN 應該實現懶加載以提高初始頁面加載速度
5. WHEN 關鍵圖片需要優先加載 THEN 應該使用 priority 屬性進行預加載

### 需求 4：高級佈局模式

**用戶故事：** 作為開發者，我希望能夠使用 CSS Grid 和 Flexbox 的高級組合來創建複雜且靈活的佈局系統。

#### 驗收標準

1. WHEN 創建頁面主佈局 THEN 應該使用 CSS Grid 定義整體結構 <kreference link="https://blog.pixelfreestudio.com/ultimate-guide-to-css-grid-and-flexbox-layouts-in-2024/" index="4">[^4]</kreference>
2. WHEN 在 Grid 項目內部對齊內容 THEN 應該使用 Flexbox 進行精確控制
3. WHEN 創建響應式網格 THEN 應該使用 auto-fit 和 minmax() 函數實現自適應列數
4. WHEN 需要命名網格區域 THEN 應該使用 grid-template-areas 提高代碼可讀性
5. WHEN 組合使用 Grid 和 Flexbox THEN 應該確保佈局在所有設備上都保持穩定

### 需求 5：性能監控和 Web Vitals 優化

**用戶故事：** 作為產品經理，我希望能夠監控響應式設計對網站性能的影響，確保優化不會犧牲用戶體驗。

#### 驗收標準

1. WHEN 實現響應式設計 THEN 必須監控 Core Web Vitals 指標（LCP、INP、CLS） <kreference link="https://bluetriangle.com/blog/core-web-vitals-monitoring/" index="5">[^5]</kreference>
2. WHEN LCP 超過 2.5 秒 THEN 應該觸發性能警告並提供優化建議
3. WHEN INP 超過 200 毫秒 THEN 應該檢查 JavaScript 執行和主線程阻塞
4. WHEN CLS 超過 0.1 THEN 應該檢查佈局偏移並修復不穩定元素
5. WHEN 監控性能數據 THEN 應該收集真實用戶監控（RUM）數據而非僅依賴實驗室數據

### 需求 6：觸摸交互優化

**用戶故事：** 作為移動設備用戶，我希望所有交互元素都針對觸摸操作進行優化，提供流暢的手勢支持。

#### 驗收標準

1. WHEN 設計觸摸目標 THEN 最小尺寸應該為 44px × 44px 以符合可訪問性標準
2. WHEN 用戶進行觸摸操作 THEN 應該提供即時的視覺反饋
3. WHEN 實現手勢支持 THEN 應該支持滑動、捏合縮放等常見手勢
4. WHEN 觸摸元素間距過近 THEN 應該增加間距以避免誤觸
5. WHEN 在不同設備上測試 THEN 觸摸交互應該在所有支持的設備上保持一致

### 需求 7：無障礙設計響應式實現

**用戶故事：** 作為有特殊需求的用戶，我希望響應式設計能夠在所有設備上都保持良好的無障礙性。

#### 驗收標準

1. WHEN 使用流體排版 THEN 文字必須能夠放大到 200% 而不影響功能
2. WHEN 佈局發生響應式變化 THEN 焦點順序應該保持邏輯性
3. WHEN 在移動設備上使用 THEN 所有功能都應該可以通過鍵盤或輔助技術訪問
4. WHEN 顏色對比度在不同屏幕上 THEN 應該始終滿足 WCAG 2.1 AA 標準
5. WHEN 響應式佈局改變 THEN 屏幕閱讀器應該能夠正確理解內容結構

### 需求 8：跨設備測試和驗證

**用戶故事：** 作為質量保證工程師，我希望有完整的測試策略來驗證響應式設計在各種設備上的表現。

#### 驗收標準

1. WHEN 進行響應式測試 THEN 應該覆蓋主流設備和瀏覽器組合
2. WHEN 測試不同屏幕密度 THEN 應該驗證在高 DPI 設備上的顯示效果
3. WHEN 測試網絡條件 THEN 應該模擬不同的網絡速度和延遲
4. WHEN 自動化測試 THEN 應該包含視覺回歸測試以檢測佈局變化
5. WHEN 性能測試 THEN 應該在不同設備性能條件下驗證響應式行為

  [^1]: https://www.joshwcomeau.com/css/container-queries-introduction/
  [^2]: https://www.smashingmagazine.com/2022/01/modern-fluid-typography-css-clamp/
  [^3]: https://www.contentful.com/blog/nextjs-image-component/
  [^4]: https://blog.pixelfreestudio.com/ultimate-guide-to-css-grid-and-flexbox-layouts-in-2024/
  [^5]: https://bluetriangle.com/blog/core-web-vitals-monitoring/
</file>

<file path=".kwaipilot/specs/responsive-mobile-optimization/design.md">
# 響應式移動端優化設計文檔

## 介紹

本設計文檔基於需求分析，提供了全面的響應式移動端優化解決方案。我們將採用移動優先的設計方法，使用TailwindCSS的響應式功能，並實現現代化的移動端交互模式，同時解決現有的狀態管理和功能性問題。

## 技術架構

### 響應式斷點策略

基於研究結果，我們將採用語義化的斷點命名方式，而非傳統的尺寸命名： <kreference link="https://mrtnschndlr.medium.com/things-to-rethink-with-tailwind-css-part-1-breakpoints-b2809e2bbb2" index="3">[^3]</kreference>

```javascript
// tailwind.config.js
module.exports = {
  theme: {
    screens: {
      'mobile': '320px',    // 小型手機
      'tablet': '640px',    // 平板和大型手機
      'laptop': '1024px',   // 筆記本電腦
      'desktop': '1280px',  // 桌面顯示器
    },
  }
}
```

### 移動優先設計原則

1. **基礎樣式**：所有未加前綴的類別適用於移動設備
2. **漸進增強**：使用 `tablet:`, `laptop:`, `desktop:` 前綴逐步增強
3. **觸摸友好**：最小觸摸目標44px×44px <kreference link="https://www.uxpin.com/studio/blog/tailwind-best-practices/" index="2">[^2]</kreference>
4. **內容優先**：確保核心功能在小屏幕上可用

## 組件設計規範

### 1. DebateRoom 主容器

#### 當前問題
- 固定寬度的側邊欄在移動設備上佔用過多空間
- 標籤導航在小屏幕上擁擠
- 控制面板無法在移動設備上有效使用

#### 解決方案

```mermaid
graph TD
    A[DebateRoom] --> B[移動端布局]
    A --> C[平板端布局]
    A --> D[桌面端布局]
    
    B --> E[全屏主內容]
    B --> F[底部抽屜導航]
    B --> G[浮動操作按鈕]
    
    C --> H[雙欄布局]
    C --> I[可折疊側邊欄]
    
    D --> J[三欄布局]
    D --> K[固定側邊欄]
```

#### 實現細節

**移動端 (320px-640px)**
- 主內容區域佔滿整個屏幕
- 標籤導航轉換為底部抽屜
- 控制面板作為浮動操作按鈕(FAB)
- 使用手勢滑動切換標籤

**平板端 (640px-1024px)**
- 雙欄布局：主內容 + 可折疊側邊欄
- 標籤導航保持在頂部但優化間距
- 控制面板集成到側邊欄

**桌面端 (1024px+)**
- 保持現有三欄布局
- 優化間距和字體大小

### 2. PersonaCard 響應式設計

#### 當前問題
- 固定寬度導致在小屏幕上溢出
- 按鈕過小，不適合觸摸操作
- 信息密度過高，在移動設備上難以閱讀

#### 解決方案

```mermaid
graph LR
    A[PersonaCard] --> B[移動端]
    A --> C[平板端]
    A --> D[桌面端]
    
    B --> E[垂直布局]
    B --> F[大型觸摸按鈕]
    B --> G[簡化信息顯示]
    
    C --> H[網格布局 2列]
    C --> I[中等按鈕尺寸]
    
    D --> J[網格布局 3-4列]
    D --> K[完整信息顯示]
```

#### 實現規範

**移動端優化**
- 卡片寬度：100%（單列）
- 最小高度：120px
- 按鈕尺寸：44px×44px
- 字體大小：16px（主要文字）、14px（次要文字）
- 間距：16px（外邊距）、12px（內邊距）

**觸摸交互優化**
- 增加點擊區域
- 添加觸摸反饋動畫
- 優化滑動手勢支持

### 3. DebateControlPanel 移動端適配

#### 當前問題
- 按鈕網格在小屏幕上過於擁擠
- 文字輸入框在移動設備上難以使用
- 狀態指示器不夠明顯

#### 解決方案

**移動端布局**
- 按鈕改為單列垂直排列
- 增大按鈕高度至56px
- 優化文字輸入框的觸摸體驗
- 添加視覺狀態指示器

**交互優化**
- 支持滑動手勢操作
- 添加觸覺反饋
- 優化鍵盤彈出時的布局調整

### 4. 導航系統重設計

基於移動端導航模式研究，我們將實現混合導航系統： <kreference link="https://www.uxpin.com/studio/blog/mobile-navigation-patterns-pros-and-cons/" index="4">[^4]</kreference>

#### 移動端導航模式

```mermaid
graph TD
    A[導航系統] --> B[底部標籤欄]
    A --> C[側滑抽屜]
    A --> D[浮動操作按鈕]
    
    B --> E[主要功能]
    B --> F[辯論、共識、參與者]
    
    C --> G[次要功能]
    C --> H[設置、幫助、關於]
    
    D --> I[快速操作]
    D --> J[開始/暫停辯論]
```

#### 實現策略

**底部標籤欄**
- 3-4個主要功能標籤
- 圖標 + 文字標籤
- 高度：72px
- 支持滑動切換

**側滑抽屜**
- 從左側滑出
- 包含次要功能和設置
- 支持手勢關閉
- 半透明背景遮罩

## 狀態管理優化

### Zustand 遷移問題解決

基於研究發現的Zustand狀態遷移問題，我們需要實現以下修復： <kreference link="https://github.com/pmndrs/zustand/discussions/2663" index="5">[^5]</kreference>

#### 問題分析
- "State loaded from storage couldn't be migrated" 警告
- 缺少遷移函數導致的狀態恢復問題
- 移動端狀態同步異常

#### 解決方案

```typescript
// 添加狀態版本控制和遷移函數
const useMeetingRoomStore = create<MeetingRoomState>()(
  persist(
    (set, get) => ({
      // ... 現有狀態
    }),
    {
      name: 'meeting-room-storage',
      version: 1,
      migrate: (persistedState: any, version: number) => {
        if (version === 0) {
          // 從版本0遷移到版本1
          return {
            ...persistedState,
            // 添加新的默認值
            debateSettings: {
              timeoutPerRound: 300000, // 5分鐘，確保不少於30秒
              ...persistedState.debateSettings
            }
          };
        }
        return persistedState;
      },
      partialize: (state) => ({
        rooms: state.rooms,
        availablePersonas: state.availablePersonas,
      }),
    }
  )
);
```

### 辯論初始化錯誤修復

#### 問題分析
- "每回合超時時間不能少於30秒" 錯誤
- "辯論尚未準備就緒" 狀態問題
- 移動端觸摸操作導致的狀態異常

#### 解決方案

```typescript
// 優化驗證邏輯
private validateRoomSettings(room: MeetingRoom): void {
  // 確保超時時間至少30秒（30000毫秒）
  const minTimeout = 30000;
  if (room.settings.timeoutPerRound && room.settings.timeoutPerRound < minTimeout) {
    // 自動修正而非拋出錯誤
    room.settings.timeoutPerRound = minTimeout;
    console.warn(`超時時間已自動調整為${minTimeout/1000}秒`);
  }
  
  // 其他驗證邏輯...
}
```

## 性能優化策略

### 1. 代碼分割和懶加載

```typescript
// 組件懶加載
const DebateRoom = lazy(() => import('./components/DebateRoom'));
const PersonaManager = lazy(() => import('./components/PersonaManager'));

// 路由級別的代碼分割
const PersonasPage = lazy(() => import('./app/personas/page'));
```

### 2. 圖片和資源優化

```typescript
// 響應式圖片
<Image
  src="/persona-avatar.jpg"
  alt="Persona Avatar"
  width={48}
  height={48}
  sizes="(max-width: 640px) 48px, (max-width: 1024px) 64px, 80px"
  className="rounded-full"
/>
```

### 3. 虛擬化長列表

```typescript
// 對於大量PersonaCard的情況
import { FixedSizeList as List } from 'react-window';

const VirtualizedPersonaList = ({ personas }) => (
  <List
    height={400}
    itemCount={personas.length}
    itemSize={120}
    className="mobile:h-screen tablet:h-96"
  >
    {({ index, style }) => (
      <div style={style}>
        <PersonaCard persona={personas[index]} />
      </div>
    )}
  </List>
);
```

## 測試策略

### 1. 響應式測試

```typescript
// 使用React Testing Library進行響應式測試
describe('DebateRoom Responsive', () => {
  test('mobile layout', () => {
    Object.defineProperty(window, 'innerWidth', {
      writable: true,
      configurable: true,
      value: 375,
    });
    
    render(<DebateRoom />);
    expect(screen.getByTestId('mobile-navigation')).toBeInTheDocument();
  });
});
```

### 2. 觸摸交互測試

```typescript
// 觸摸事件測試
test('persona card touch interactions', () => {
  render(<PersonaCard />);
  const card = screen.getByRole('button');
  
  fireEvent.touchStart(card);
  fireEvent.touchEnd(card);
  
  expect(mockOnToggle).toHaveBeenCalled();
});
```

### 3. 性能測試

```typescript
// 使用Web Vitals監控
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  // 發送性能指標到分析服務
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

## 實現時間線

### 階段1：基礎響應式框架（1-2週）
- 設置TailwindCSS自定義斷點
- 實現基礎移動端布局
- 修復狀態管理問題

### 階段2：組件優化（2-3週）
- PersonaCard響應式重構
- DebateControlPanel移動端適配
- 導航系統重設計

### 階段3：交互優化（1-2週）
- 觸摸手勢支持
- 動畫和過渡效果
- 性能優化

### 階段4：測試和調優（1週）
- 跨設備測試
- 性能監控
- 用戶體驗調優

## 參考資料

[^1]: https://chenhuijing.com/blog/the-horizontal-overflow-problem/
[^2]: https://www.uxpin.com/studio/blog/tailwind-best-practices/
[^3]: https://mrtnschndlr.medium.com/things-to-rethink-with-tailwind-css-part-1-breakpoints-b2809e2bbb2
[^4]: https://www.uxpin.com/studio/blog/mobile-navigation-patterns-pros-and-cons/
[^5]: https://github.com/pmndrs/zustand/discussions/2663
</file>

<file path=".kwaipilot/specs/responsive-mobile-optimization/requirements.md">
# 響應式移動端優化需求文檔

## 介紹

本項目旨在全面改善AI辯論平台的響應式設計，解決當前版面超出瀏覽器顯示範圍的問題，並為移動端和平板端提供優化的用戶體驗。同時修復相關的狀態管理和功能性錯誤，確保在所有設備上都能提供穩定可靠的服務。

## 需求

### 需求 1：修復版面溢出問題

**用戶故事：** 作為用戶，我希望在任何設備上都能完整查看所有內容，而不會出現水平滾動條或內容被截斷的情況。

#### 驗收標準

1. WHEN 用戶在移動設備（320px-768px）上訪問應用 THEN 所有內容應在視窗範圍內正確顯示
2. WHEN 用戶在平板設備（768px-1024px）上訪問應用 THEN 布局應適當調整以充分利用屏幕空間
3. WHEN 用戶在桌面設備（>1024px）上訪問應用 THEN 應保持當前的桌面體驗
4. WHEN 頁面包含長文本或URL THEN 應自動換行或截斷，不會導致水平溢出 <kreference link="https://chenhuijing.com/blog/the-horizontal-overflow-problem/" index="1">[^1]</kreference>
5. WHEN 用戶旋轉設備方向 THEN 布局應自動適應新的屏幕尺寸

### 需求 2：實現移動優先響應式設計

**用戶故事：** 作為移動端用戶，我希望獲得專為觸摸設備優化的用戶界面，包括適當的按鈕大小和觸摸友好的交互。

#### 驗收標準

1. WHEN 用戶在移動設備上操作 THEN 所有可點擊元素應至少44px×44px大小以符合觸摸標準
2. WHEN 用戶在移動設備上瀏覽 THEN 文字大小應至少16px以確保可讀性
3. WHEN 用戶在移動設備上使用表單 THEN 輸入框應有足夠的間距和大小便於操作 <kreference link="https://www.uxpin.com/studio/blog/tailwind-best-practices/" index="2">[^2]</kreference>
4. WHEN 用戶在移動設備上查看PersonaCard THEN 卡片應垂直堆疊並保持適當間距
5. WHEN 用戶在移動設備上使用辯論控制面板 THEN 按鈕應重新排列為單列布局

### 需求 3：優化組件響應式布局

**用戶故事：** 作為用戶，我希望所有組件在不同屏幕尺寸下都能保持良好的可用性和美觀性。

#### 驗收標準

1. WHEN 用戶在小屏幕上查看DebateRoom THEN 側邊欄應可折疊或轉換為底部抽屜
2. WHEN 用戶在移動設備上查看PersonaSelectionPanel THEN 人格卡片應以單列或雙列網格顯示
3. WHEN 用戶在移動設備上查看DebateViewer THEN 發言內容應適當縮放並保持可讀性
4. WHEN 用戶在移動設備上查看ConsensusDisplay THEN 圖表和統計數據應適應小屏幕顯示
5. WHEN 用戶在移動設備上使用EditableTopicHeader THEN 編輯功能應保持可用性

### 需求 4：修復狀態管理錯誤

**用戶故事：** 作為用戶，我希望應用在所有設備上都能正常運行，不會出現功能性錯誤或警告。

#### 驗收標準

1. WHEN 應用初始化時 THEN 不應出現"State loaded from storage couldn't be migrated"警告
2. WHEN 用戶嘗試開始辯論時 THEN 不應出現"每回合超時時間不能少於30秒"錯誤
3. WHEN 用戶點擊開始按鈕時 THEN 不應出現"辯論尚未準備就緒"錯誤
4. WHEN 用戶在移動設備上操作時 THEN 所有狀態變更應正確同步
5. WHEN 用戶切換設備或刷新頁面時 THEN 應用狀態應正確恢復

### 需求 5：改善移動端導航體驗

**用戶故事：** 作為移動端用戶，我希望能夠輕鬆導航應用的各個功能區域，並且能夠快速訪問常用功能。

#### 驗收標準

1. WHEN 用戶在移動設備上使用標籤導航 THEN 標籤應適當縮放並保持可點擊性
2. WHEN 用戶在移動設備上滾動長內容 THEN 應提供平滑的滾動體驗
3. WHEN 用戶在移動設備上使用模態對話框 THEN 對話框應適應屏幕大小並保持可用性
4. WHEN 用戶在移動設備上查看錯誤信息 THEN 錯誤提示應清晰可見且不會被遮擋
5. WHEN 用戶在移動設備上使用快捷鍵 THEN 應提供替代的觸摸操作方式

### 需求 6：性能優化

**用戶故事：** 作為移動端用戶，我希望應用在移動網絡環境下也能快速加載和響應。

#### 驗收標準

1. WHEN 用戶在移動設備上首次加載應用 THEN 關鍵內容應在3秒內顯示
2. WHEN 用戶在移動設備上進行交互 THEN 響應時間應小於100ms
3. WHEN 用戶在移動設備上滾動頁面 THEN 應保持60fps的流暢度
4. WHEN 用戶在移動設備上切換標籤 THEN 切換動畫應流暢無卡頓
5. WHEN 用戶在移動設備上使用辯論功能 THEN 實時更新應不影響界面響應性

## 參考資料

[^1]: https://chenhuijing.com/blog/the-horizontal-overflow-problem/
[^2]: https://www.uxpin.com/studio/blog/tailwind-best-practices/
</file>

<file path=".kwaipilot/specs/virtual-meeting-room-ui/design.md">
# 虛擬會議室UI體驗優化設計文檔

## 簡介

本設計文檔基於需求分析和現代UI設計最佳實踐，為虛擬會議室系統提供全面的界面設計方案。重點關注人格選擇體驗、辯論可視化和響應式設計，以創建直觀且高效的用戶界面。

## 整體架構設計

### 系統架構概覽

```mermaid
graph TB
    A[首頁 HomePage] --> B[會議室選擇 RoomSelection]
    B --> C[人格選擇 PersonaSelection]
    C --> D[辯論界面 DebateInterface]
    
    D --> E[辯論查看器 DebateViewer]
    D --> F[控制面板 ControlPanel]
    D --> G[共識分析 ConsensusView]
    
    E --> H[發言時間線 StatementTimeline]
    E --> I[實時狀態 LiveStatus]
    
    F --> J[辯論控制 DebateControls]
    F --> K[參與者管理 ParticipantManager]
```

### 組件層次結構

```mermaid
graph LR
    A[App] --> B[HomePage]
    A --> C[DebateRoom]
    
    B --> D[RoomGrid]
    B --> E[CreateRoomModal]
    
    C --> F[PersonaSelectionPanel]
    C --> G[DebateViewer]
    C --> H[ControlPanel]
    
    F --> I[PersonaCard]
    F --> J[SelectedPersonasList]
    
    G --> K[StatementBubble]
    G --> L[LoadingIndicator]
    
    H --> M[DebateControls]
    H --> N[LiveStats]
```

## 核心組件設計

### 1. PersonaSelectionPanel 組件

#### 設計原則
- **卡片式布局**：採用Material Design卡片模式，提供清晰的視覺分組 <kreference link="https://www.nngroup.com/articles/cards-component/" index="1">[^1]</kreference>
- **響應式網格**：使用CSS Grid實現自適應布局 <kreference link="https://medium.com/@abdulsamad18090/responsive-web-design-best-practices-for-2024-492a42635a4c" index="2">[^2]</kreference>
- **觸摸友好**：確保最小44px×44px的觸摸區域 <kreference link="https://medium.com/@abdulsamad18090/responsive-web-design-best-practices-for-2024-492a42635a4c" index="2">[^2]</kreference>

#### 視覺設計規範

```mermaid
graph TD
    A[PersonaCard] --> B[Avatar Section]
    A --> C[Content Section]
    A --> D[Action Section]
    
    B --> E[Circular Avatar 64px]
    B --> F[Status Indicator]
    
    C --> G[Name Typography]
    C --> H[Role Badge]
    C --> I[Description Text]
    
    D --> J[Selection State]
    D --> K[Hover Effects]
```

#### 響應式斷點設計
- **Desktop (≥1024px)**: 3列網格，卡片寬度320px
- **Tablet (768px-1023px)**: 2列網格，卡片寬度自適應
- **Mobile (<768px)**: 1列堆疊，卡片寬度100%

### 2. DebateViewer 組件重設計

#### 時間線布局設計

```mermaid
sequenceDiagram
    participant U as User
    participant S as System
    participant A1 as AI Persona 1
    participant A2 as AI Persona 2
    
    U->>S: 開始辯論
    S->>A1: 生成發言
    A1-->>S: 思考中...
    A1->>S: 發言內容
    S->>A2: 輪到發言
    A2-->>S: 分析前述發言...
    A2->>S: 反駁內容
```

#### 發言氣泡設計規範
- **左右交替布局**：奇數回合靠左，偶數回合靠右
- **漸進式展示**：支持摺疊/展開詳細信息
- **視覺層次**：使用陰影和間距創建深度感

### 3. 實時狀態系統設計

#### 狀態指示器架構

```mermaid
stateDiagram-v2
    [*] --> Idle: 系統初始化
    Idle --> Preparing: 開始辯論
    Preparing --> Searching: 搜尋資料
    Searching --> Debating: 開始發言
    Debating --> Thinking: AI思考中
    Thinking --> Speaking: 生成發言
    Speaking --> Debating: 下一位發言
    Debating --> Voting: 進入投票
    Voting --> Completed: 達成共識
    Comple--> [*]
    
    Debating --> Paused: 用戶暫停
    Paused --> Debating: 恢復辯論
    Paused --> [*]: 停止辯論
```

## 視覺設計系統

### 色彩系統

#### 主色調配置
- **Primary**: #3B82F6 (藍色) - 主要操作按鈕
- **Secondary**: #10B981 (綠色) - 成功狀態
- **Warning**: #F59E0B (橙色) - 警告信息
- **Error**: #EF4444 (紅色) - 錯誤狀態
- **Neutral**: #6B7280 (灰色) - 次要文字

#### 人格專屬色彩
- **CEO**: #1F2937 (深灰) - 權威感
- **CTO**: #059669 (深綠) - 技術感
- **CFO**: #DC2626 (紅色) - 財務警覺
- **環保倡議者**: #16A34A (綠色) - 環保理念
- **法律顧問**: #7C3AED (紫色) - 專業嚴謹
- **市場分析師**: #EA580C (橙色) - 活力創新

### 字體系統

#### 字體層次
- **H1**: 32px/40px, font-weight: 700 - 頁面標題
- **H2**: 24px/32px, font-weight: 600 - 區塊標題
- **H3**: 20px/28px, font-weight: 600 - 組件標題
- **Body**: 16px/24px, font-weight: 400 - 正文內容
- **Caption**: 14px/20px, font-weight: 400 - 輔助信息
- **Small**: 12px/16px, font-weight: 400 - 標籤文字

### 間距系統

#### 標準間距單位
- **xs**: 4px - 元素內部間距
- **sm**: 8px - 相關元素間距
- **md**: 16px - 組件間距
- **lg**: 24px - 區塊間距
- **xl**: 32px - 頁面區域間距
- **2xl**: 48px - 主要區域間距

## 交互設計規範

### 動畫設計原則

#### 過渡動畫配置
- **Duration**: 200ms (快速反饋), 300ms (標準), 500ms (複雜動畫)
- **Easing**: ease-out (進入), ease-in (退出), ease-in-out (變換)
- **Transform**: 優先使用transform和opacity，避免觸發重排

#### 關鍵動畫場景
1. **卡片選擇**: scale(1.02) + shadow增強
2. **發言出現**: slideInUp + fadeIn
3. **狀態切換**: crossfade
4. **加載狀態**: pulse + rotate

### 觸摸交互設計

#### 手勢支持
- **點擊**: 選擇/取消選擇人格
- **長按**: 顯示詳細信息
- **滑動**: 在移動端切換標籤
- **雙擊**: 快速操作（如收藏）

## 響應式設計策略

### 斷點系統

```css
/* 移動優先設計 */
.container {
  /* Mobile: 320px+ */
  padding: 16px;
  
  /* Tablet: 768px+ */
  @media (min-width: 768px) {
    padding: 24px;
  }
  
  /* Desktop: 1024px+ */
  @media (min-width: 1024px) {
    padding: 32px;
  }
  
  /* Large Desktop: 1280px+ */
  @media (min-width: 1280px) {
    padding: 48px;
  }
}
```

### 組件適配策略

#### PersonaCard 響應式行為
- **Mobile**: 全寬卡片，垂直堆疊信息
- **Tablet**: 2列網格，保持卡片比例
- **Desktop**: 3列網格，增加懸停效果

#### DebateViewer 適配
- **Mobile**: 單列時間線，簡化發言氣泡
- **Tablet**: 保持時間線，增加側邊信息
- **Desktop**: 完整布局，支持多面板視圖

## 性能優化設計

### 虛擬化策略

#### 長列表優化
```mermaid
graph LR
    A[發言列表] --> B[虛擬滾動]
    B --> C[可見項目渲染]
    B --> D[緩衝區管理]
    C --> E[DOM回收]
    D --> F[預加載策略]
```

#### 圖片優化
- **懶加載**: 使用Intersection Observer
- **響應式圖片**: srcset + sizes屬性
- **格式優化**: WebP優先，JPEG降級

### 狀態管理優化

#### 數據流設計
```mermaid
graph TD
    A[用戶操作] --> B[Action Dispatch]
    B --> C[Store Update]
    C --> D[Component Re-render]
    D --> E[Virtual DOM Diff]
    E --> F[DOM Update]
    
    C --> G[Persistence Layer]
    G --> H[LocalStorage]
    G --> I[IndexedDB]
```

## 無障礙設計規範

### ARIA 標籤策略

#### 語義化標記
- **role**: 定義組件角色
- **aria-label**: 提供描述性標籤
- **aria-describedby**: 關聯詳細描述
- **aria-expanded**: 指示展開狀態

#### 鍵盤導航支持
- **Tab順序**: 邏輯性導航路徑
- **Enter/Space**: 激活操作
- **Escape**: 關閉模態/取消操作
- **Arrow Keys**: 在組件間導航

### 對比度標準

#### WCAG AA 合規性
- **正文文字**: 4.5:1 最小對比度
- **大文字**: 3:1 最小對比度
- **非文字元素**: 3:1 最小對比度
- **焦點指示器**: 清晰可見的焦點環

## 邊界情況處理

### 錯誤狀態設計

| 場景 | 視覺表現 | 用戶操作 | 系統行為 |
|------|----------|----------|----------|
| 網絡連接失敗 | 頂部警告條 | 重試按鈕 | 自動重連 |
| API調用超時 | 加載失敗提示 | 手動重試 | 指數退避 |
| 人格選擇上限 | 卡片禁用 | 移除其他人格 | 動態更新 |
| 辯論中斷 | 暫停狀態 | 恢復/停止 | 保存進度 |

### 空狀態設計

#### 會議室列表為空
- **視覺**: 插圖 + 引導文字
- **操作**: 突出的創建按鈕
- **文案**: 友好且具有指導性

#### 辯論歷史為空
- **視覺**: 簡潔的佔位符
- **操作**: 開始辯論按鈕
- **文案**: 鼓勵性的提示

## 技術實現考量

### 組件庫選擇
- **基礎組件**: Headless UI + Tailwind CSS
- **圖標系統**: Lucide React
- **動畫庫**: Framer Motion
- **圖表庫**: Recharts

### 狀態管理
- **全局狀態**: Zustand (已使用)
- **服務器狀態**: TanStack Query
- **表單狀態**: React Hook Form

### 測試策略
- **單元測試**: Jest + Testing Library
- **視覺回歸**: Chromatic
- **E2E測試**: Playwright
- **無障礙測試**: axe-core

## 參考資料

[^1]: https://www.nngroup.com/articles/cards-component/
[^2]: https://medium.com/@abdulsamad18090/responsive-web-design-best-practices-for-2024-492a42635a4c
[^3]: https://www.eleken.co/blog-posts/card-ui-examples-and-best-practices-for-product-owners
[^4]: https://www.eleken.co/blog-posts/bad-ux-examples
</file>

<file path=".kwaipilot/specs/virtual-meeting-room-ui/requirements.md">
# 虛擬會議室UI體驗優化需求文檔

## 簡介

本需求文檔旨在優化虛擬會議室的用戶界面體驗，重點改進人格選擇、辯論可視化和整體交互流程。基於對現有系統的分析和現代UI設計最佳實踐的研究，我們將創建一個更直觀、響應式且用戶友好的界面。

## 需求

### 需求 1：直觀的人格選擇界面

**用戶故事：** 作為會議室創建者，我希望能夠通過點擊按鈕快速選擇預設人格，這樣我就能輕鬆組建辯論團隊而無需複雜的配置過程。

#### 驗收標準

1. WHEN 用戶進入人格選擇界面 THEN 系統 SHALL 顯示6個預設人格的卡片式按鈕，每個按鈕包含人格頭像、姓名、角色和簡短描述
2. WHEN 用戶點擊人格卡片 THEN 系統 SHALL 立即將該人格添加到會議室參與者列表中，並提供視覺反饋（如卡片高亮或動畫效果）
3. WHEN 人格已被選中 THEN 系統 SHALL 在卡片上顯示選中狀態（如勾選標記、邊框變色）
4. WHEN 用戶再次點擊已選中的人格 THEN 系統 SHALL 將其從參與者列表中移除
5. WHEN 參與者數量達到上限（6個）THEN 系統 SHALL 禁用未選中的人格卡片並顯示提示信息

### 需求 2：響應式人格卡片設計

**用戶故事：** 作為移動設備用戶，我希望人格選擇界面在不同屏幕尺寸下都能良好顯示，這樣我就能在任何設備上使用虛擬會議室。

#### 驗收標準

1. WHEN 在桌面設備（≥1024px）上查看 THEN 系統 SHALL 以3列網格顯示人格卡片
2. WHEN 在平板設備（768px-1023px）上查看 THEN 系統 SHALL 以2列網格顯示人格卡片
3. WHEN 在移動設備（<768px）上查看 THEN 系統 SHALL 以1列堆疊顯示人格卡片
4. WHEN 卡片內容超出容器 THEN 系統 SHALL 自動調整文字大小和間距以保持可讀性
5. WHEN 用戶觸摸卡片 THEN 系統 SHALL 提供適當的觸摸反饋（至少44px×44px的觸摸區域）

### 需求 3：增強的辯論可視化

**用戶故事：** 作為辯論觀察者，我希望能夠清晰地看到每個AI替身的發言過程和立場變化，這樣我就能更好地理解辯論的進展和邏輯。

#### 驗收標準

1. WHEN 辯論進行中 THEN 系統 SHALL 以時間線形式顯示所有發言，每個發言氣泡包含發言者頭像、姓名、內容和傾向度分數
2. WHEN AI替身正在思考 THEN 系統 SHALL 顯示動態加載指示器和"正在分析..."的狀態文字
3. WHEN 新發言產生 THEN 系統 SHALL 以平滑動畫將新內容添加到辯論流中
4. WHEN 用戶點擊發言氣泡 THEN 系統 SHALL 展開顯示詳細信息（推理過程、引用來源等）
5. WHEN 辯論回合結束 THEN 系統 SHALL 顯示該回合的共識趨勢圖表

### 需求 4：實時狀態反饋系統

**用戶故事：** 作為會議主持人，我希望能夠實時了解辯論的進展狀態和每個參與者的當前立場，這樣我就能適時做出干預決策。

#### 驗收標準

1. WHEN 辯論開始 THEN 系統 SHALL 在右側面板顯示實時統計信息（當前回合、總發言數、平均傾向度）
2. WHEN 當前發言者改變 THEN 系統 SHALL 高亮顯示當前發言者的信息卡片
3. WHEN 系統遇到錯誤 THEN 系統 SHALL 在頂部顯示非阻塞式錯誤提示，包含錯誤類型和建議操作
4. WHEN 網絡連接不穩定 THEN 系統 SHALL 顯示連接狀態指示器
5. WHEN 辯論暫停或停止 THEN 系統 SHALL 更新所有相關UI元素的狀態

### 需求 5：優化的會議室管理界面

**用戶故事：** 作為系統用戶，我希望能夠輕鬆創建和管理多個會議室，這樣我就能針對不同議題組織不同的辯論會議。

#### 驗收標準

1. WHEN 用戶訪問首頁 THEN 系統 SHALL 顯示會議室網格視圖，每個卡片包含會議室名稱、議題、參與者數量和狀態
2. WHEN 用戶點擊"創建會議室"按鈕 THEN 系統 SHALL 打開模態對話框，包含會議室名稱和議題輸入字段
3. WHEN 用戶提交創建表單 THEN 系統 SHALL 驗證輸入並創建新會議室，然後自動跳轉到人格選擇界面
4. WHEN 會議室卡片被懸停 THEN 系統 SHALL 顯示預覽信息和快速操作按鈕（編輯、刪除、複製）
5. WHEN 會議室列表為空 THEN 系統 SHALL 顯示友好的空狀態界面，引導用戶創建第一個會議室

### 需求 6：無障礙設計支持

**用戶故事：** 作為視覺障礙用戶，我希望能夠使用屏幕閱讀器正常操作虛擬會議室，這樣我就能平等地參與AI辯論體驗。

#### 驗收標準

1. WHEN 使用屏幕閱讀器 THEN 系統 SHALL 為所有交互元素提供適當的ARIA標籤和描述
2. WHEN 使用鍵盤導航 THEN 系統 SHALL 支持Tab鍵順序導航，所有可交互元素都能通過鍵盤訪問
3. WHEN 顏色用於傳達信息 THEN 系統 SHALL 同時提供非顏色的視覺提示（如圖標、文字）
4. WHEN 文字對比度不足 THEN 系統 SHALL 確保所有文字與背景的對比度至少達到WCAG AA標準（4.5:1）
5. WHEN 動畫播放 THEN 系統 SHALL 提供減少動畫的選項，尊重用戶的偏好設置

### 需求 7：性能優化和加載體驗：** 作為移動網絡用戶，我希望虛擬會議室能夠快速加載並流暢運行，這樣我就能在任何網絡條件下使用系統。

#### 驗收標準

1. WHEN 首次訪問應用 THEN 系統 SHALL 在3秒內完成初始頁面加載
2. WHEN 切換會議室標籤 THEN 系統 SHALL 在500毫秒內完成視圖切換
3. WHEN 加載大量辯論歷史 THEN 系統 SHALL 實現虛擬滾動，一次只渲染可見的發言項目
4. WHEN 圖片加載緩慢 THEN 系統 SHALL 顯示佔位符並實現懶加載
5. WHEN 系統資源不足 THEN 系統 SHALL 優雅降級，保持核心功能可用

## 參考資料

[^1]: https://www.eleken.co/blog-posts/bad-ux-examples
[^2]: https://www.nngroup.com/articles/cards-component/
[^3]: https://www.eleken.co/blog-posts/card-ui-examples-and-best-practices-for-product-owners
[^4]: https://medium.com/@abdulsamad18090/responsive-web-design-best-practices-for-2024-492a42635a4c
</file>

<file path=".kwaipilot/specs/virtual-meeting-room/design.md">
# 虛擬會議室系統設計文件

## 概述

虛擬會議室系統是一個基於 Next.js 和 Gemini AI 的智能辯論平台，採用模組化架構設計，支援多替身深度辯論、聯網搜尋和共識計算功能。

## 系統架構

```mermaid
graph TB
    A[用戶界面層] --> B[業務邏輯層]
    B --> C[服務層]
    C --> D[外部 API 層]
    
    A --> A1[會議室管理頁面]
    A --> A2[替身管理頁面]
    A --> A3[辯論進行頁面]
    
    B --> B1[會議室狀態管理]
    B --> B2[替身管理邏輯]
    B --> B3[辯論協調器]
    
    C --> C1[Gemini 服務]
    C --> C2[替身引擎]
    C --> C3[API 服務]
    
    D --> D1[Gemini API]
    D --> D2[Google Search]
```

## 核心模組設計

### 1. 替身引擎（PersonaEngine）

替身引擎負責管理虛擬替身的人格特質和行為模式。

```mermaid
classDiagram
    class PersonaEngine {
        +buildPersonaPrompt(persona, context, searchResults)
        +parsePersonaResponse(content)
        +validatePersona(persona)
        +generateSearchKeywords(persona, topic)
        +calculatePersonaSimilarity(persona1, persona2)
    }
    
    class Persona {
        +id: string
        +name: string
        +identity: string
        +primeDirective: string
        +toneStyle: string
        +defaultBias: string
        +ragFocus: string[]
        +temperature: number
        +color: string
        +isActive: boolean
    }
    
    PersonaEngine --> Persona
```

**設計決策：**
- 使用靜態方法設計，避免狀態管理複雜性
- 支援動態 Prompt 生成，確保替身行為一致性
- 內建驗證機制，確保替身配置完整性

### 2. 辯論協調器（DebateOrchestrator）

辯論協調器管理整個辯論流程，包括替身輪替、狀態同步和事件處理。

```mermaid
stateDiagram-v2
    [*] --> Idle
    Idle --> Initializing: initializeDebate()
    Initializing --> Searching: performTopicSearch()
    Searching --> Ready: searchComplete
    Ready --> Debating: startDebate()
    Debating --> Paused: pauseDebate()
    Paused --> Debating: resumeDebate()
    Debating --> Completed: consensusReached/maxRounds
    Debating --> Error: errorOccurred
    Error --> Idle: reset()
    Completed --> Idle: reset()
```

**關鍵功能：**
- 事件驅動架構，支援狀態變化監聽
- 錯誤處理和重試機制
- 支援暫停/恢復功能
- 自動共識檢測

### 3. Gemini 服務整合

```mermaid
sequenceDiagram
    participant U as 用戶
    participant DC as 辯論協調器
    participant GS as Gemini服務
    participant GA as Gemini API
    
    U->>DC: 開始辯論
    DC->>GS: 搜尋議題資訊
    GS->>GA: 呼叫 Google Search
    GA-->>GS: 返回搜尋結果
    GS-->>DC: 整合搜尋資料
    
    loop 每個替身發言
        DC->>GS: 生成替身回應
        GS->>GA: 發送 Prompt + 搜尋結果
        GA-->>GS: 返回 AI 回應
        GS-->>DC: 解析回應和來源
        DC->>U: 顯示發言和來源
    end
```

**技術實現：**
- 使用 Gemini 2.0 Flash 模型，支援 Google Search grounding <kreference link="https://ai.google.dev/gemini-api/docs/google-search" index="1">[^1]</kreference>
- 實現來源引用解析和顯示
- 支援批量請求和錯誤重試
- 溫度參數個性化設定

### 4. Chain of Thought 推理機制

基於研究顯示，Chain of Thought 推理能顯著提升 AI 的複雜推理能力 <kreference link="https://www.promptingguide.ai/techniques/cot" index="2">[^2]</kreference>。

```mermaid
flowchart TD
    A[接收上下文] --> B[解析階段 Analyze]
    B --> C[批判階段 Critique]
    C --> D[策略階段 Strategy]
    D --> E[生成結構化回應]
    
    B --> B1[分析前一發言薄弱點]
    B --> B2[識別與核心原則的衝突]
    
    C --> C1[結合搜尋結果]
    C --> C2[提出基於事實的反駁]
    
    D --> D1[制定回應策略]
    D --> D2[確保針鋒相對]
    
    E --> E1[明確引用與質疑]
    E --> E2[反駁論點與證據]
    E --> E3[行動呼籲或質問]
    E --> E4[傾向度分數]
```

**Prompt 範本結構：**
```
【替身身份設定】
身份：{persona.identity}
核心原則：{persona.primeDirective}
辯論風格：{persona.toneStyle}
預設傾向：{persona.defaultBias}

【最新查證資訊】
{searchResults}

【辯論歷史】
{previousStatements}

【內部強制性思考步驟】
1. 解析目標論點 (Analyze)
2. 檢驗與批判 (Critique)  
3. 規劃回應策略 (Strategy)

【強制性輸出結構】
1. 明確引用與質疑
2. 反駁論點與證據
3. 行動呼籲或質問
4. 傾向度分數：[1-10]/10
```

### 5. 共識計算機制

```mermaid
graph LR
    A[收集傾向度分數] --> B[計算支持度]
    A --> C[計算反對度]
    B --> D[檢查門檻]
    C --> D
    D --> E{達成共識?}
    E -->|是| F[結束辯論]
    E -->|否| G[繼續下一輪]
```

**計算公式：**
- 支持度 = Σ(分數) / (10 × 替身數量)
- 反對度 = Σ(10-分數) / (9 × 替身數量)
- 共識門檻：預設 70%，可調整

### 6. 狀態管理架構

使用 Zustand 進行狀態管理，採用模組化設計：

```mermaid
graph TB
    A[MeetingRoomStore] --> B[會議室狀態]
    A --> C[替身管理]
    A --> D[辯論控制]
    
    B --> B1[當前會議室]
    B --> B2[會議室列表]
    B --> B3[會議設定]
    
    C --> C1[可用替身]
    C --> C2[啟用狀態]
    C --> C3[替身操作]
    
    D --> D1[辯論狀態]
    D --> D2[當前回合]
    D --> D3[發言歷史]
```

## 資料流設計

### 辯論流程資料流

```mermaid
sequenceDiagram
    participant UI as 用戶界面
    participant Store as 狀態管理
    participant Orch as 辯論協調器
    participant API as API服務
    participant Gemini as Gemini API
    
    UI->>Store: 開始辯論
    Store->>Orch: 初始化辯論
    Orch->>API: 搜尋議題資訊
    API->>Gemini: Google Search
    Gemini-->>API: 搜尋結果
    API-->>Orch: 整合資料
    
    loop 每輪辯論
        Orch->>API: 生成替身發言
        API->>Gemini: Chain of Thought Prompt
        Gemini-->>API: 結構化回應
        API-->>Orch: 解析結果
        Orch->>Store: 更新發言
        Store->>UI: 顯示發言
    end
    
    Orch->>Store: 計算共識
    Store->>UI: 顯示結果
```

## 錯誤處理策略

### 1. API 錯誤處理
- 實現指數退避重試機制
- 設定最大重試次數（3次）
- 提供降級處理方案

### 2. 網路錯誤處理
- 檢測網路連接狀態
- 提供離線模式提示
- 支援手動重試功能

### 3. 資料驗證
- 前端表單驗證
- 後端 API 參數驗證
- 替身配置完整性檢查

## 效能優化

### 1. API 呼叫優化
- 批量處理搜尋請求
- 快取搜尋結果
- 使用適當的模型溫度參數

### 2. 前端效能
- 虛擬滾動處理大量發言
- 懶載入替身組件
- 狀態更新防抖處理

### 3. 記憶體管理
- 限制辯論歷史記錄數量
- 定期清理無用狀態
- 使用 WeakMap 避免記憶體洩漏

## 安全考量

### 1. API 金鑰安全
- 環境變數儲存 API 金鑰
- 伺服器端 API 呼叫
- 避免前端暴露敏感資訊

### 2. 輸入驗證
- 防止 Prompt 注入攻擊
- 限制輸入長度和格式
- 過濾惡意內容

### 3. 資料隱私
- 本地儲存敏感資料
- 不記錄個人識別資訊
- 遵循資料保護法規

  [^1]: https://ai.google.dev/gemini-api/docs/google-search
  [^2]: https://www.promptingguide.ai/techniques/cot
</file>

<file path=".kwaipilot/specs/virtual-meeting-room/requirements.md">
# 虛擬會議室系統需求文件

## 簡介

虛擬會議室系統是一個基於 AI 的智能辯論平台，允許用戶創建多個虛擬替身，針對特定議題進行深度辯論，並透過聯網搜尋功能獲取最新資訊，最終達成共識或進行多輪討論。

## 需求

### 需求 1：替身管理系統

**用戶故事：** 作為用戶，我希望能夠創建和管理多個虛擬替身，每個替身都有獨特的人格特質和專業背景，以便在辯論中扮演不同角色。

#### 驗收標準

1. WHEN 用戶進入替身管理頁面 THEN 系統 SHALL 顯示所有可用的替身列表
2. WHEN 用戶點擊「創建替身」按鈕 THEN 系統 SHALL 打開替身編輯器
3. WHEN 用戶填寫替身資訊（名稱、身份、核心原則、辯論風格、預設傾向、搜尋重點、溫度參數）THEN 系統 SHALL 驗證資料完整性並保存替身
4. WHEN 用戶點擊替身卡片 THEN 系統 SHALL 切換該替身的啟用狀態
5. WHEN 用戶編輯或刪除替身 THEN 系統 SHALL 更新替身資料或從列表中移除

### 需求 2：會議室創建與管理

**用戶故事：** 作為用戶，我希望能夠創建會議室並設定辯論議題，選擇參與的替身，以便組織結構化的辯論活動。

#### 驗收標準

1. WHEN 用戶點擊「創建會議室」THEN 系統 SHALL 提示輸入會議室名稱和辯論議題
2. WHEN 用戶輸入有效的會議室資訊 THEN 系統 SHALL 創建新會議室並導航至該會議室
3. WHEN 用戶在會議室中選擇替身 THEN 系統 SHALL 將選中的替身加入參與者列表
4. WHEN 會議室至少有 2 個參與替身 THEN 系統 SHALL 啟用「開始辯論」功能
5. WHEN 用戶設定會議參數（最大回合數、共識門檻、每回合超時時間）THEN 系統 SHALL 保存這些設定

### 需求 3：聯網搜尋與資料整合

**用戶故事：** 作為系統，我希望能夠透過 Gemini API 的 Google Search grounding 功能自動搜尋相關資訊，以便為替身提供最新、準確的資料支持其論點。 <kreference link="https://ai.google.dev/gemini-api/docs/google-search" index="1">[^1]</kreference>

#### 驗收標準

1. WHEN 辯論開始前 THEN 系統 SHALL 分析議題並生成相關搜尋關鍵詞
2. WHEN 系統執行搜尋 THEN 系統 SHALL 使用 Gemini API 的 googleSearch 工具獲取最新資訊 <kreference link="https://ai.google.dev/gemini-api/docs/google-search" index="1">[^1]</kreference>
3. WHEN 搜尋完成 THEN 系統 SHALL 將搜尋結果整合到共享上下文中
4. WHEN 替身發言時 THEN 系統 SHALL 在 prompt 中包含相關搜尋結果
5. WHEN 替身引用搜尋資料 THEN 系統 SHALL 在回應中包含來源引用資訊

### 需求 4：深度辯論機制（Chain of Thought）

**用戶故事：** 作為系統，我希望實現強制性三層推理機制，確保替身進行深度辯論而非淺層對話，以提高辯論質量和說服力。 <kreference link="https://www.promptingguide.ai/techniques/cot" index="2">[^2]</kreference>

#### 驗收標準

1. WHEN 替身準備發言 THEN 系統 SHALL 強制執行解析（Analyze）階段，分析前一發言的薄弱點
2. WHEN 解析完成 THEN 系統 SHALL 執行批判（Critique）階段，結合搜尋結果提出反駁論點
3. WHEN 批判完成 THEN 系統 SHALL 執行策略（Strategy）階段，制定結構化的回應策略
4. WHEN 替身發言 THEN 系統 SHALL 確保回應包含明確引用、反駁論點和行動呼籲三個部分
5. WHEN 發言結束 THEN 系統 SHALL 要求替身提供傾向度分數（1-10）

### 需求 5：共識計算與投票機制

**用戶故事：** 作為用戶，我希望系統能夠自動計算辯論共識，並提供量化的支持度和反對度，以便了解辯論結果和決定是否需要進一步討論。

#### 驗收標準

1. WHEN 每輪辯論結束 THEN 系統 SHALL 收集所有替身的傾向度分數
2. WHEN 計算共識 THEN 系統 SHALL 使用公式：支持度 = Σ分數 / (10 × 替身數量)
3. WHEN 計算共識 THEN 系統 SHALL 使用公式：反對度 = Σ(10-分數) / (9 × 替身數量)
4. WHEN 支持度或反對度超過設定門檻（預設 70%）THEN 系統 SHALL 宣告達成共識
5. WHEN 未達成共識且未達最大回合數 THEN 系統 SHALL 繼續下一輪辯論

### 需求 6：多輪辯論控制

**用戶故事：** 作為用戶，我希望能夠控制辯論流程，包括暫停、恢復、停止辯論，以及設定最大回合數，以便靈活管理辯論進程。

#### 驗收標準

1. WHEN 用戶點擊「開始辯論」THEN 系統 SHALL 初始化辯論並開始第一輪
2. WHEN 辯論進行中且用戶點擊「暫停」THEN 系統 SHALL 暫停當前辯論狀態
3. WHEN 辯論暫停且用戶點擊「恢復」THEN 系統 SHALL 從暫停點繼續辯論
4. WHEN 用戶點擊「停止」THEN 系統 SHALL 終止辯論並計算最終結果
5. WHEN 達到最大回合數 THEN 系統 SHALL 自動結束辯論並顯示最終共識

### 需求 7：實時狀態顯示

**用戶故事：** 作為用戶，我希望能夠實時查看辯論狀態，包括當前發言者、回合數、各替身的傾向度變化，以便了解辯論進展。

#### 驗收標準

1. WHEN 辯論進行中 THEN 系統 SHALL 顯示當前回合數和最大回合數
2. WHEN 替身發言時 THEN 系統 SHALL 高亮顯示當前發言者
3. WHEN 替身完成發言 THEN 系統 SHALL 更新該替身的傾向度分數顯示
4. WHEN 辯論狀態改變 THEN 系統 SHALL 更新狀態指示器（準備中、搜尋中、辯論中、已完成等）
5. WHEN 出現錯誤 THEN 系統 SHALL 顯示錯誤訊息並提供重試選項

### 需求 8：辯論歷史與來源追蹤

**用戶故事：** 作為用戶，我希望能夠查看完整的辯論歷史和每個論點的來源，以便驗證資訊的可靠性和追蹤論點的發展過程。

#### 驗收標準

1. WHEN 替身發言 THEN 系統 SHALL 記錄發言內容、時間戳、傾向度分數和來源引用
2. WHEN 用戶查看辯論歷史 THEN 系統 SHALL 按時間順序顯示所有發言
3. WHEN 發言包含來源引用 THEN 系統 SHALL 提供可點擊的連結到原始來源
4. WHEN 用戶點擊來源連結 THEN 系統 SHALL 在新視窗中打開來源網頁
5. WHEN 辯論結束 THEN 系統 SHALL 生成包含所有來源的參考文獻列表

  [^1]: https://ai.google.dev/gemini-api/docs/google-search
  [^2]: https://www.promptingguide.ai/techniques/cot
</file>

<file path="docs/responsive-testing.md">
# 響應式設計測試指南

## 概述

本項目實現了全面的響應式設計測試系統，使用 Playwright 進行自動化測試，確保應用在各種設備和瀏覽器上都能正常工作。

## 測試類型

### 1. 響應式佈局測試
- **文件**: `tests/responsive.spec.ts`
- **功能**: 測試不同視窗大小下的佈局表現
- **覆蓋範圍**: 
  - 移動設備 (320px - 414px)
  - 平板設備 (768px - 1024px)
  - 桌面設備 (1280px - 2560px)

### 2. 觸摸交互測試
- **文件**: `tests/touch-interactions.spec.ts`
- **功能**: 測試觸摸手勢和交互反饋
- **測試項目**:
  - 觸摸按鈕反饋
  - 長按手勢
  - 滑動手勢
  - 捏合縮放

### 3. 容器查詢測試
- **功能**: 測試 CSS 容器查詢的響應式行為
- **測試組件**: PersonaCard, DebateRoom, Navigation

### 4. 流體排版測試
- **功能**: 驗證 CSS clamp() 函數的字體縮放
- **測試範圍**: 標題、正文、間距

### 5. 性能測試
- **指標**: Core Web Vitals (LCP, FID, CLS)
- **目標**: 
  - LCP < 2.5s
  - FID < 100ms
  - CLS < 0.1

## 運行測試

### 基本命令

```bash
# 運行所有測試
npm run test

# 運行響應式測試
npm run test:responsive

# 運行觸摸交互測試
npm run test:touch

# 使用 UI 模式運行測試
npm run test:ui

# 查看測試報告
npm run test:report
```

### 高級選項

```bash
# 運行特定瀏覽器的測試
npx playwright test --project="Desktop Chrome"

# 運行特定設備的測試
npx playwright test --project="iPhone 12"

# 調試模式
npx playwright test --debug

# 生成測試代碼
npx playwright codegen localhost:3000
```

## 測試配置

### 支持的設備

| 設備類型 | 設備名稱 | 分辨率 |
|---------|---------|--------|
| 移動設備 | iPhone SE | 320×568 |
| 移動設備 | iPhone 12 | 390×844 |
| 移動設備 | Samsung Galaxy | 360×640 |
| 平板設備 | iPad | 768×1024 |
| 平板設備 | iPad Pro | 1024×1366 |
| 桌面設備 | Desktop Small | 1280×720 |
| 桌面設備 | Desktop Large | 1920×1080 |
| 桌面設備 | Desktop XL | 2560×1440 |

### 瀏覽器支持

- Chrome (桌面/移動)
- Firefox (桌面)
- Safari (桌面/移動)
- Edge (桌面)

## 測試工具

### ResponsiveTestHelper

位於 `tests/utils/responsive-test-helper.ts`，提供以下功能：

```typescript
// 創建測試助手
const helper = new ResponsiveTestHelper(page);

// 測試所有視窗大小
await helper.testAllViewports(async (viewport) => {
  // 測試邏輯
});

// 檢查觸摸目標大小
const touchTargets = await helper.checkTouchTargets();

// 檢查文字溢出
const hasOverflow = await helper.checkTextOverflow('.text-content');

// 生成測試報告
const report = await helper.generateReport();
```

### 快速測試函數

```typescript
import { quickResponsiveTest } from './utils/responsive-test-helper';

test('快速響應式測試', async ({ page }) => {
  await quickResponsiveTest(page, '/');
});
```

## 測試最佳實踐

### 1. 觸摸目標大小
- 最小尺寸: 44×44px
- 推薦尺寸: 56×56px
- 重要按鈕: 64×64px

### 2. 文字可讀性
- 最小字體: 12px
- 行高比例: 1.4-1.6
- 對比度: 4.5:1 (普通文字)

### 3. 佈局穩定性
- 避免佈局偏移 (CLS)
- 預留動態內容空間
- 使用骨架屏

### 4. 性能優化
- 圖片懶加載
- 關鍵資源預加載
- 代碼分割

## 故障排除

### 常見問題

1. **測試超時**
   ```bash
   # 增加超時時間
   npx playwright test --timeout=60000
   ```

2. **截圖差異**
   ```bash
   # 更新基準截圖
   npx playwright test --update-snapshots
   ```

3. **設備模擬問題**
   ```bash
   # 檢查設備配置
   npx playwright show-trace trace.zip
   ```

### 調試技巧

1. **使用調試模式**
   ```bash
   npx playwright test --debug tests/responsive.spec.ts
   ```

2. **查看測試執行過程**
   ```bash
   npx playwright test --headed
   ```

3. **生成詳細報告**
   ```bash
   npx playwright test --reporter=html
   ```

## CI/CD 集成

### GitHub Actions 配置

```yaml
name: Responsive Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npx playwright install
      - run: npm run test
      - uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: test-results/
```

## 測試報告

測試完成後，可以在以下位置查看報告：

- HTML 報告: `playwright-report/index.html`
- JSON 結果: `test-results/results.json`
- JUnit 報告: `test-results/junit.xml`
- 截圖: `test-results/screenshots/`
- 視頻: `test-results/videos/`

## 持續改進

### 監控指標

1. **測試覆蓋率**: 目標 >90%
2. **測試執行時間**: 目標 <5分鐘
3. **失敗率**: 目標 <5%

### 定期檢查

- 每週檢查測試結果
- 每月更新設備配置
- 每季度評估測試策略

## 相關資源

- [Playwright 官方文檔](https://playwright.dev/)
- [Web Vitals 指南](https://web.dev/vitals/)
- [響應式設計最佳實踐](https://web.dev/responsive-web-design-basics/)
- [容器查詢指南](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries)
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="playwright.config.ts">
import { defineConfig, devices } from '@playwright/test';

/**
 * Playwright 配置文件
 * 用於響應式設計測試和跨瀏覽器測試
 */
export default defineConfig({
  testDir: './tests',
  
  /* 並行運行測試 */
  fullyParallel: true,
  
  /* 在 CI 環境中禁止重試 */
  forbidOnly: !!process.env.CI,
  
  /* 在 CI 環境中重試失敗的測試 */
  retries: process.env.CI ? 2 : 0,
  
  /* 並行工作進程數量 */
  workers: process.env.CI ? 1 : undefined,
  
  /* 測試報告配置 */
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }],
    ['junit', { outputFile: 'test-results/junit.xml' }]
  ],
  
  /* 全局測試配置 */
  use: {
    /* 基礎 URL */
    baseURL: 'http://localhost:3000',
    
    /* 收集失敗測試的追蹤信息 */
    trace: 'on-first-retry',
    
    /* 截圖配置 */
    screenshot: 'only-on-failure',
    
    /* 視頻錄製 */
    video: 'retain-on-failure',
  },

  /* 響應式測試項目配置 */
  projects: [
    {
      name: 'Desktop Chrome',
      use: { 
        ...devices['Desktop Chrome'],
        viewport: { width: 1920, height: 1080 }
      },
    },
    
    {
      name: 'Desktop Firefox',
      use: { 
        ...devices['Desktop Firefox'],
        viewport: { width: 1920, height: 1080 }
      },
    },
    
    {
      name: 'Desktop Safari',
      use: { 
        ...devices['Desktop Safari'],
        viewport: { width: 1920, height: 1080 }
      },
    },

    /* 平板設備測試 */
    {
      name: 'iPad',
      use: { ...devices['iPad'] },
    },
    
    {
      name: 'iPad Pro',
      use: { ...devices['iPad Pro'] },
    },

    /* 移動設備測試 */
    {
      name: 'iPhone 12',
      use: { ...devices['iPhone 12'] },
    },
    
    {
      name: 'iPhone 12 Pro',
      use: { ...devices['iPhone 12 Pro'] },
    },
    
    {
      name: 'iPhone SE',
      use: { ...devices['iPhone SE'] },
    },
    
    {
      name: 'Samsung Galaxy S21',
      use: { ...devices['Galaxy S III'] }, // 使用類似的設備配置
    },

    /* 自定義響應式斷點測試 */
    {
      name: 'Mobile Small',
      use: {
        ...devices['Desktop Chrome'],
        viewport: { width: 320, height: 568 }
      },
    },
    
    {
      name: 'Mobile Medium',
      use: {
        ...devices['Desktop Chrome'],
        viewport: { width: 375, height: 667 }
      },
    },
    
    {
      name: 'Mobile Large',
      use: {
        ...devices['Desktop Chrome'],
        viewport: { width: 414, height: 896 }
      },
    },
    
    {
      name: 'Tablet Small',
      use: {
        ...devices['Desktop Chrome'],
        viewport: { width: 768, height: 1024 }
      },
    },
    
    {
      name: 'Tablet Large',
      use: {
        ...devices['Desktop Chrome'],
        viewport: { width: 1024, height: 1366 }
      },
    },
    
    {
      name: 'Desktop Small',
      use: {
        ...devices['Desktop Chrome'],
        viewport: { width: 1280, height: 720 }
      },
    },
    
    {
      name: 'Desktop Large',
      use: {
        ...devices['Desktop Chrome'],
        viewport: { width: 1920, height: 1080 }
      },
    },
    
    {
      name: 'Desktop XL',
      use: {
        ...devices['Desktop Chrome'],
        viewport: { width: 2560, height: 1440 }
      },
    },
  ],

  /* 開發服務器配置 */
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
    timeout: 120 * 1000,
  },
});
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="src/app/api/debate/enhanced/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { getGeminiService } from '@/services/geminiService';
import { Persona, DebateContext, SourceReference } from '@/types';

export async function POST(request: NextRequest) {
  try {
    const { action, ...params } = await request.json();
    
    const geminiService = getGeminiService();
    
    switch (action) {
      case 'speak': {
        const { persona, context, searchResults } = params as {
          persona: Persona;
          context: DebateContext;
          searchResults?: SourceReference[];
        };
        
        if (!persona || !context) {
          return NextResponse.json(
            { error: 'Persona and context are required for speak action' },
            { status: 400 }
          );
        }

        const response = await geminiService.generatePersonaResponse(
          persona,
          context,
          searchResults
        );

        return NextResponse.json({
          response,
          success: true,
        });
      }
      
      case 'search': {
        const { topic, personas } = params as {
          topic: string;
          personas: Persona[];
        };
        
        if (!topic || !personas) {
          return NextResponse.json(
            { error: 'Topic and personas are required for search action' },
            { status: 400 }
          );
        }

        const keywords = await geminiService.analyzeTopicAndGenerateKeywords(topic, personas);
        const searchResults = await geminiService.searchTopicInformation(topic, keywords);

        return NextResponse.json({
          keywords,
          searchResults,
          success: true,
        });
      }
      
      case 'analyze': {
        const { topic, personas } = params as {
          topic: string;
          personas: Persona[];
        };
        
        if (!topic || !personas) {
          return NextResponse.json(
            { error: 'Topic and personas are required for analyze action' },
            { status: 400 }
          );
        }

        const keywords = await geminiService.analyzeTopicAndGenerateKeywords(topic, personas);

        return NextResponse.json({
          keywords,
          success: true,
        });
      }
      
      default:
        return NextResponse.json(
          { error: `Unknown action: ${action}` },
          { status: 400 }
        );
    }
  } catch (error) {
    console.error('Error in debate API:', error);
    return NextResponse.json(
      { 
        error: 'Failed to process debate request',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/debate/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { getGeminiService } from '@/services/geminiService';

export async function POST(request: NextRequest) {
  try {
    const { persona, context, searchResults } = await request.json();
    
    if (!persona || !context) {
      return NextResponse.json(
        { error: 'Persona and context are required' },
        { status: 400 }
      );
    }

    const geminiService = getGeminiService();
    const response = await geminiService.generatePersonaResponse(
      persona,
      context,
      searchResults
    );

    return NextResponse.json({
      response,
      success: true,
    });
  } catch (error) {
    console.error('Error in debate API:', error);
    return NextResponse.json(
      { error: 'Failed to generate persona response' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/search/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { getGeminiService } from '@/services/geminiService';

export async function POST(request: NextRequest) {
  try {
    const { topic, personas } = await request.json();
    
    if (!topic || !personas) {
      return NextResponse.json(
        { error: 'Topic and personas are required' },
        { status: 400 }
      );
    }

    const geminiService = getGeminiService();
    const keywords = await geminiService.analyzeTopicAndGenerateKeywords(topic, personas);
    const searchResults = await geminiService.searchTopicInformation(topic, keywords);

    return NextResponse.json({
      keywords,
      searchResults,
      success: true,
    });
  } catch (error) {
    console.error('Error in search API:', error);
    return NextResponse.json(
      { error: 'Failed to search topic information' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/personas/page.tsx">
'use client';

import React, { useState } from 'react';
import { useMeetingRoomStore } from '@/stores/meetingRoomStore';
import { PersonaCard, PersonaEditor } from '@/components';
import { Persona } from '@/types';
import { Plus, Users } from 'lucide-react';

export default function PersonasPage() {
  const {
    availablePersonas,
    addPersona,
    updatePersona,
    deletePersona,
    togglePersonaActive,
  } = useMeetingRoomStore();

  const [isEditorOpen, setIsEditorOpen] = useState(false);
  const [editingPersona, setEditingPersona] = useState<Persona | undefined>();

  const activeCount = availablePersonas.filter(p => p.isActive).length;

  const handleCreatePersona = () => {
    setEditingPersona(undefined);
    setIsEditorOpen(true);
  };

  const handleEditPersona = (persona: Persona) => {
    setEditingPersona(persona);
    setIsEditorOpen(true);
  };

  const handleDeletePersona = (persona: Persona) => {
    if (window.confirm(`確定要刪除替身「${persona.name}」嗎？`)) {
      deletePersona(persona.id);
    }
  };

  const handleTogglePersona = (persona: Persona) => {
    togglePersonaActive(persona.id);
  };

  const handleSavePersona = (personaData: Omit<Persona, 'id'>) => {
    if (editingPersona) {
      updatePersona(editingPersona.id, personaData);
    } else {
      addPersona(personaData);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto px-4 py-8">
        <div className="space-y-6">
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-3">
              <Users className="w-6 h-6 text-blue-600" />
              <div>
                <h2 className="text-xl font-semibold text-gray-900">
                  替身管理
                </h2>
                <p className="text-sm text-gray-600">
                  共 {availablePersonas.length} 個替身，{activeCount} 個已選中
                </p>
              </div>
            </div>

            <button
              onClick={handleCreatePersona}
              className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors"
            >
              <Plus className="w-4 h-4" />
              創建替身
            </button>
          </div>

          {availablePersonas.length === 0 ? (
            <div className="text-center py-12">
              <Users className="w-16 h-16 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-semibold text-gray-900 mb-2">
                還沒有替身
              </h3>
              <p className="text-gray-600 mb-4">
                創建您的第一個虛擬替身，開始構建辯論團隊
              </p>
              <button
                onClick={handleCreatePersona}
                className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors"
              >
                創建替身
              </button>
            </div>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {availablePersonas.map((persona) => (
                <PersonaCard
                  key={persona.id}
                  persona={persona}
                  isSelected={persona.isActive}
                  onToggle={() => handleTogglePersona(persona)}
                  onEdit={() => handleEditPersona(persona)}
                  onDelete={() => handleDeletePersona(persona)}
                  showControls={true}
                />
              ))}
            </div>
          )}

          <PersonaEditor
            persona={editingPersona}
            isOpen={isEditorOpen}
            onClose={() => {
              setIsEditorOpen(false);
              setEditingPersona(undefined);
            }}
            onSave={handleSavePersona}
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/DebateViewer.tsx">
import React, { useState, useEffect } from 'react';
import { Statement, Persona, DebateStatus } from '@/types';
import { formatDistanceToNow } from 'date-fns';
import { zhCN } from 'date-fns/locale';

interface DebateViewerProps {
  statements: Statement[];
  currentSpeaker: Persona | null;
  debateStatus: DebateStatus;
  currentRound: number;
  loading: boolean;
  onStatementClick?: (statement: Statement) => void;
}

export const DebateViewer: React.FC<DebateViewerProps> = ({
  statements,
  currentSpeaker,
  debateStatus,
  currentRound,
  loading,
  onStatementClick,
}) => {
  const [selectedStatement, setSelectedStatement] = useState<Statement | null>(null);
  const [autoScroll, setAutoScroll] = useState(true);

  // 自動滾動到最新發言
  useEffect(() => {
    if (autoScroll && statements.length > 0) {
      const latestElement = document.getElementById(`statement-${statements.length - 1}`);
      latestElement?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [statements, autoScroll]);

  const getStatusColor = (status: DebateStatus) => {
    switch (status) {
      case 'preparing': return 'bg-yellow-100 text-yellow-800';
      case 'debating': return 'bg-green-100 text-green-800';
      case 'paused': return 'bg-orange-100 text-orange-800';
      case 'completed': return 'bg-blue-100 text-blue-800';
      case 'error': return 'bg-red-100 text-red-800';
      case 'searching': return 'bg-purple-100 text-purple-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  const getStatusText = (status: DebateStatus) => {
    switch (status) {
      case 'preparing': return '準備中';
      case 'debating': return '辯論中';
      case 'paused': return '已暫停';
      case 'completed': return '已完成';
      case 'error': return '錯誤';
      case 'searching': return '搜尋中';
      default: return '未知狀態';
    }
  };

  const getTendencyColor = (score: number) => {
    if (score >= 7) return 'text-green-600 bg-green-50';
    if (score <= 4) return 'text-red-600 bg-red-50';
    return 'text-yellow-600 bg-yellow-50';
  };

  const getTendencyText = (score: number) => {
    if (score >= 7) return '支持';
    if (score <= 4) return '反對';
    return '中立';
  };

  const handleStatementClick = (statement: Statement) => {
    setSelectedStatement(statement);
    onStatementClick?.(statement);
  };

  return (
    <div className="flex flex-col h-full bg-white rounded-lg shadow-lg">
      {/* 辯論狀態欄 */}
      <div className="flex items-center justify-between p-4 border-b border-gray-200">
        <div className="flex items-center space-x-4">
          <span className={`px-3 py-1 rounded-full text-sm font-medium ${getStatusColor(debateStatus)}`}>
            {getStatusText(debateStatus)}
          </span>
          <span className="text-sm text-gray-600">
            第 {currentRound} 輪
          </span>
          {currentSpeaker && (
            <span className="text-sm text-blue-600">
              當前發言者: {currentSpeaker.name}
            </span>
          )}
        </div>
        
        <div className="flex items-center space-x-2">
          <label className="flex items-center text-sm text-gray-600">
            <input
              type="checkbox"
              checked={autoScroll}
              onChange={(e) => setAutoScroll(e.target.checked)}
              className="mr-2"
            />
            自動滾動
          </label>
          {loading && (
            <div className="flex items-center text-sm text-gray-500">
              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-500 mr-2"></div>
              處理中...
            </div>
          )}
        </div>
      </div>

      {/* 發言列表 */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {statements.length === 0 ? (
          <div className="text-center text-gray-500 py-8">
            <div className="text-4xl mb-2">💬</div>
            <p>尚無發言，辯論即將開始...</p>
          </div>
        ) : (
          statements.map((statement, index) => (
            <div
              key={statement.id}
              id={`statement-${index}`}
              className={`p-4 rounded-lg border cursor-pointer transition-all duration-200 hover:shadow-md ${
                selectedStatement?.id === statement.id
                  ? 'border-blue-500 bg-blue-50'
                  : 'border-gray-200 hover:border-gray-300'
              }`}
              onClick={() => handleStatementClick(statement)}
            >
              {/* 發言者信息 */}
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center space-x-3">
                  <div className="w-8 h-8 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center text-white text-sm font-bold">
                    {statement.personaName.charAt(0)}
                  </div>
                  <div>
                    <h4 className="font-medium text-gray-900">{statement.personaName}</h4>
                    <p className="text-xs text-gray-500">
                      {formatDistanceToNow(statement.timestamp, { 
                        addSuffix: true, 
                        locale: zhCN 
                      })}
                    </p>
                  </div>
                </div>
                
                <div className="flex items-center space-x-2">
                  <span className={`px-2 py-1 rounded text-xs font-medium ${getTendencyColor(statement.tendencyScore)}`}>
                    {getTendencyText(statement.tendencyScore)} ({statement.tendencyScore}/10)
                  </span>
                  <span className="text-xs text-gray-400">#{statement.round}</span>
                </div>
              </div>

              {/* 發言內容 */}
              <div className="text-gray-800 leading-relaxed mb-3">
                {statement.content}
              </div>

              {/* 引用和標籤 */}
              {(statement.references.length > 0 || statement.tags.length > 0) && (
                <div className="flex flex-wrap items-center gap-2 pt-2 border-t border-gray-100">
                  {statement.references.length > 0 && (
                    <div className="flex items-center text-xs text-gray-500">
                      <span className="mr-1">📎</span>
                      {statement.references.length} 個引用
                    </div>
                  )}
                  {statement.tags.map((tag, tagIndex) => (
                    <span
                      key={tagIndex}
                      className="px-2 py-1 bg-gray-100 text-gray-600 rounded text-xs"
                    >
                      #{tag}
                    </span>
                  ))}
                </div>
              )}
            </div>
          ))
        )}
      </div>

      {/* 發言詳情側邊欄 */}
      {selectedStatement && (
        <div className="border-t border-gray-200 p-4 bg-gray-50">
          <div className="flex items-center justify-between mb-2">
            <h5 className="font-medium text-gray-900">發言詳情</h5>
            <button
              onClick={() => setSelectedStatement(null)}
              className="text-gray-400 hover:text-gray-600"
            >
              ✕
            </button>
          </div>
          
          <div className="space-y-2 text-sm">
            <div>
              <span className="text-gray-600">發言者:</span>
              <span className="ml-2 font-medium">{selectedStatement.personaName}</span>
            </div>
            <div>
              <span className="text-gray-600">輪次:</span>
              <span className="ml-2">{selectedStatement.round}</span>
            </div>
            <div>
              <span className="text-gray-600">傾向度:</span>
              <span className={`ml-2 px-2 py-1 rounded text-xs ${getTendencyColor(selectedStatement.tendencyScore)}`}>
                {selectedStatement.tendencyScore}/10
              </span>
            </div>
            {selectedStatement.references.length > 0 && (
              <div>
                <span className="text-gray-600">引用資料:</span>
                <ul className="ml-2 mt-1 space-y-1">
                  {selectedStatement.references.map((ref, index) => (
                    <li key={index} className="text-xs text-blue-600 hover:underline cursor-pointer">
                      {ref.title || ref.url}
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/index.ts">
export { PersonaCard } from './PersonaCard';
export { PersonaEditor } from './PersonaEditor';
export { DebateViewer } from './DebateViewer';
export { DebateControlPanel } from './DebateControlPanel';
export { ConsensusDisplay } from './ConsensusDisplay';
export { DebateRoom } from './DebateRoom';
export { PersonaManager } from './PersonaManager';
export { PersonaSelectionPanel } from './PersonaSelectionPanel';
export { ModeratorSelectionPanel } from './ModeratorSelectionPanel';
export { EditableTopicHeader } from './EditableTopicHeader';
</file>

<file path="src/components/MobileNavigation.tsx">
import React, { useState, useEffect } from 'react';
import { Menu, X, Settings, Users, MessageSquare, BarChart3 } from 'lucide-react';

interface MobileDrawerProps {
  isOpen: boolean;
  onClose: () => void;
  children?: React.ReactNode;
}

export const MobileDrawer: React.FC<MobileDrawerProps> = ({ 
  isOpen, 
  onClose, 
  children 
}) => {
  // 防止背景滾動
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }
    
    return () => {
      document.body.style.overflow = 'unset';
    };
  }, [isOpen]);

  // ESC鍵關閉
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        onClose();
      }
    };

    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <>
      {/* 背景遮罩 */}
      <div 
        className="drawer-overlay"
        onClick={onClose}
        aria-hidden="true"
      />
      
      {/* 抽屜內容 */}
      <div 
        className={`drawer-content ${!isOpen ? 'closed' : ''}`}
        role="dialog"
        aria-modal="true"
        aria-labelledby="drawer-title"
      >
        {/* 抽屜標題欄 */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200">
          <h2 id="drawer-title" className="text-lg font-semibold text-gray-900">
            功能選單
          </h2>
          <button
            onClick={onClose}
            className="btn-touch p-2 text-gray-400 hover:text-gray-600 transition-colors"
            aria-label="關閉選單"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* 抽屜內容區域 */}
        <div className="flex-1 overflow-y-auto p-4">
          {children}
        </div>
      </div>
    </>
  );
};

interface NavigationItemProps {
  icon: React.ReactNode;
  label: string;
  onClick: () => void;
  badge?: number;
  isActive?: boolean;
}

export const NavigationItem: React.FC<NavigationItemProps> = ({
  icon,
  label,
  onClick,
  badge,
  isActive = false
}) => {
  return (
    <button
      onClick={onClick}
      className={`btn-touch w-full flex items-center gap-3 p-3 rounded-lg transition-colors text-left ${
        isActive 
          ? 'bg-blue-50 text-blue-600 border border-blue-200' 
          : 'text-gray-700 hover:bg-gray-50'
      }`}
    >
      <span className="flex-shrink-0">{icon}</span>
      <span className="flex-1 font-medium">{label}</span>
      {badge !== undefined && badge > 0 && (
        <span className={`px-2 py-1 rounded-full text-xs font-medium ${
          isActive 
            ? 'bg-blue-100 text-blue-600' 
            : 'bg-gray-100 text-gray-600'
        }`}>
          {badge}
        </span>
      )}
    </button>
  );
};

interface MobileNavigationProps {
  currentTab: string;
  onTabChange: (tab: string) => void;
  participantCount?: number;
  statementCount?: number;
  onSettingsClick?: () => void;
}

export const MobileNavigation: React.FC<MobileNavigationProps> = ({
  currentTab,
  onTabChange,
  participantCount = 0,
  statementCount = 0,
  onSettingsClick
}) => {
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);

  const navigationItems = [
    {
      id: 'selection',
      icon: <Users className="w-5 h-5" />,
      label: '人格選擇',
      badge: participantCount
    },
    {
      id: 'debate',
      icon: <MessageSquare className="w-5 h-5" />,
      label: '辯論過程',
      badge: statementCount
    },
    {
      id: 'consensus',
      icon: <BarChart3 className="w-5 h-5" />,
      label: '共識分析'
    },
    {
      id: 'participants',
      icon: <Users className="w-5 h-5" />,
      label: '參與者管理'
    }
  ];

  const handleTabChange = (tabId: string) => {
    onTabChange(tabId);
    setIsDrawerOpen(false);
  };

  return (
    <>
      {/* 移動端漢堡選單按鈕 */}
      <button
        onClick={() => setIsDrawerOpen(true)}
        className="btn-touch fixed top-4 left-4 z-50 p-3 bg-white rounded-lg shadow-lg border border-gray-200 tablet:hidden"
        aria-label="開啟導航選單"
      >
        <Menu className="w-5 h-5 text-gray-600" />
      </button>

      {/* 側滑抽屜 */}
      <MobileDrawer 
        isOpen={isDrawerOpen} 
        onClose={() => setIsDrawerOpen(false)}
      >
        <div className="space-y-2">
          {/* 主要導航項目 */}
          <div className="mb-6">
            <h3 className="text-sm font-medium text-gray-500 mb-3 px-3">
              主要功能
            </h3>
            <div className="space-y-1">
              {navigationItems.map((item) => (
                <NavigationItem
                  key={item.id}
                  icon={item.icon}
                  label={item.label}
                  onClick={() => handleTabChange(item.id)}
                  badge={item.badge}
                  isActive={currentTab === item.id}
                />
              ))}
            </div>
          </div>

          {/* 設置和其他功能 */}
          <div className="border-t border-gray-200 pt-4">
            <h3 className="text-sm font-medium text-gray-500 mb-3 px-3">
              其他功能
            </h3>
            <div className="space-y-1">
              {onSettingsClick && (
                <NavigationItem
                  icon={<Settings className="w-5 h-5" />}
                  label="設置"
                  onClick={() => {
                    onSettingsClick();
                    setIsDrawerOpen(false);
                  }}
                />
              )}
            </div>
          </div>

          {/* 應用信息 */}
          <div className="border-t border-gray-200 pt-4 mt-8">
            <div className="px-3 py-2 text-xs text-gray-500">
              <p className="font-medium">AI 辯論平台</p>
              <p>版本 1.0.0</p>
            </div>
          </div>
        </div>
      </MobileDrawer>
    </>
  );
};

export default MobileNavigation;
</file>

<file path="src/components/PersonaManager.tsx">
import React, { useState } from 'react';
import { Persona } from '@/types';

interface PersonaManagerProps {
  personas: Persona[];
  onPersonasChange: (personas: Persona[]) => void;
  disabled?: boolean;
  maxPersonas?: number;
}

export const PersonaManager: React.FC<PersonaManagerProps> = ({
  personas,
  onPersonasChange,
  disabled = false,
  maxPersonas = 6,
}) => {
  const [editingPersona, setEditingPersona] = useState<Persona | null>(null);
  const [showEditor, setShowEditor] = useState(false);

  const handleAddPersona = () => {
    if (personas.length >= maxPersonas) return;
    
    const newPersona: Persona = {
      id: `persona_${Date.now()}`,
      name: `參與者 ${personas.length + 1}`,
      role: '參與者',
      ragFocus: ['通用'],
      temperature: 0.7,
      systemPrompt: '你是一個理性且有建設性的辯論參與者。',
    };
    
    setEditingPersona(newPersona);
    setShowEditor(true);
  };

  const handleEditPersona = (persona: Persona) => {
    setEditingPersona(persona);
    setShowEditor(true);
  };

  const handleDeletePersona = (personaId: string) => {
    if (disabled) return;
    onPersonasChange(personas.filter(p => p.id !== personaId));
  };

  const handleSavePersona = (persona: Persona) => {
    const isNew = !personas.find(p => p.id === persona.id);
    
    if (isNew) {
      onPersonasChange([...personas, persona]);
    } else {
      onPersonasChange(personas.map(p => p.id === persona.id ? persona : p));
    }
    
    setShowEditor(false);
    setEditingPersona(null);
  };

  const handleCancelEdit = () => {
    setShowEditor(false);
    setEditingPersona(null);
  };

  return (
    <div className="h-full flex flex-col">
      <div className="flex items-center justify-between mb-6">
        <div>
          <h3 className="text-lg font-semibold text-gray-900">參與者管理</h3>
          <p className="text-sm text-gray-600">
            {personas.length}/{maxPersonas} 個參與者
          </p>
        </div>
        
        <button
          onClick={handleAddPersona}
          disabled={disabled || personas.length >= maxPersonas}
          className="flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        >
          <span className="mr-2">➕</span>
          添加參與者
        </button>
      </div>

      <div className="flex-1 overflow-y-auto">
        {personas.length === 0 ? (
          <div className="text-center text-gray-500 py-12">
            <div className="text-4xl mb-4">👥</div>
            <p className="text-lg mb-2">尚無參與者</p>
            <p className="text-sm">點擊上方按鈕添加第一個參與者</p>
          </div>
        ) : (
          <div className="grid gap-4">
            {personas.map((persona) => (
              <div
                key={persona.id}
                className="bg-white rounded-lg border border-gray-200 p-4 hover:shadow-md transition-shadow"
              >
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-3">
                    <div className="w-10 h-10 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center text-white font-bold">
                      {persona.name.charAt(0)}
                    </div>
                    <div>
                      <h4 className="font-medium text-gray-900">{persona.name}</h4>
                      <p className="text-sm text-gray-600">{persona.role}</p>
                    </div>
                  </div>
                  
                  {!disabled && (
                    <div className="flex space-x-2">
                      <button
                        onClick={() => handleEditPersona(persona)}
                        className="text-blue-600 hover:text-blue-800 text-sm"
                      >
                        編輯
                      </button>
                      <button
                        onClick={() => handleDeletePersona(persona.id)}
                        className="text-red-600 hover:text-red-800 text-sm"
                      >
                        刪除
                      </button>
                    </div>
                  )}
                </div>
                
                <div className="mt-3 text-sm text-gray-600">
                  <p>專業領域: {persona.ragFocus.join(', ')}</p>
                  <p>創造性: {(persona.temperature * 100).toFixed(0)}%</p>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {showEditor && editingPersona && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto p-6">
            <h3 className="text-lg font-semibold mb-4">
              {personas.find(p => p.id === editingPersona.id) ? '編輯參與者' : '新增參與者'}
            </h3>
            
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  姓名
                </label>
                <input
                  type="text"
                  value={editingPersona.name}
                  onChange={(e) => setEditingPersona({...editingPersona, name: e.target.value})}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  角色
                </label>
                <input
                  type="text"
                  value={editingPersona.role}
                  onChange={(e) => setEditingPersona({...editingPersona, role: e.target.value})}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  創造性 ({(editingPersona.temperature * 100).toFixed(0)}%)
                </label>
                <input
                  type="range"
                  min="0"
                  max="1"
                  step="0.1"
                  value={editingPersona.temperature}
                  onChange={(e) => setEditingPersona({...editingPersona, temperature: parseFloat(e.target.value)})}
                  className="w-full"
                />
              </div>
            </div>
            
            <div className="flex justify-end space-x-3 mt-6">
              <button
                onClick={handleCancelEdit}
                className="px-4 py-2 text-gray-600 border border-gray-300 rounded-md hover:bg-gray-50"
              >
                取消
              </button>
              <button
                onClick={() => handleSavePersona(editingPersona)}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
              >
                保存
              </button>
            </div>
          </div>
        </div>
      )}

      {disabled && (
        <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
          <div className="flex items-center text-yellow-800 text-sm">
            <span className="mr-2">⚠️</span>
            辯論進行中，無法修改參與者設定
          </div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/ResponsiveImage.tsx">
import React, { useState, useCallback } from 'react';
import Image from 'next/image';

/**
 * 響應式圖片組件屬性
 */
export interface ResponsiveImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  fill?: boolean;
  priority?: boolean;
  quality?: number;
  placeholder?: 'blur' | 'empty';
  blurDataURL?: string;
  className?: string;
  style?: React.CSSProperties;
  sizes?: string;
  onLoad?: () => void;
  onError?: () => void;
  loading?: 'lazy' | 'eager';
  unoptimized?: boolean;
}

/**
 * 響應式圖片組件
 * 基於 Next.js Image 組件的增強版本，提供更好的響應式支持
 */
export const ResponsiveImage: React.FC<ResponsiveImageProps> = ({
  src,
  alt,
  width,
  height,
  fill = false,
  priority = false,
  quality = 75,
  placeholder = 'blur',
  blurDataURL,
  className = '',
  style,
  sizes,
  onLoad,
  onError,
  loading = 'lazy',
  unoptimized = false,
  ...props
}) => {
  const [imageError, setImageError] = useState(false);
  const [imageLoaded, setImageLoaded] = useState(false);

  // 默認模糊佔位符
  const defaultBlurDataURL = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCdABmX/9k=';

  // 生成響應式 sizes 屬性
  const generateSizes = useCallback((): string => {
    if (sizes) return sizes;
    
    // 根據容器和設備類型生成默認 sizes
    return '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw';
  }, [sizes]);

  // 處理圖片加載完成
  const handleLoad = useCallback(() => {
    setImageLoaded(true);
    onLoad?.();
  }, [onLoad]);

  // 處理圖片加載錯誤
  const handleError = useCallback(() => {
    setImageError(true);
    onError?.();
  }, [onError]);

  // 錯誤狀態顯示
  if (imageError) {
    return (
      <div 
        className={`bg-gray-200 flex items-center justify-center ${className}`}
        style={style}
      >
        <span className="text-gray-500 text-sm">圖片加載失敗</span>
      </div>
    );
  }

  // 圖片組件屬性
  const imageProps = {
    src,
    alt,
    quality,
    priority,
    loading: priority ? 'eager' as const : loading,
    placeholder,
    blurDataURL: blurDataURL || defaultBlurDataURL,
    className: `transition-opacity duration-300 ${imageLoaded ? 'opacity-100' : 'opacity-0'} ${className}`,
    style,
    sizes: generateSizes(),
    onLoad: handleLoad,
    onError: handleError,
    unoptimized,
    ...props
  };

  // 填充模式
  if (fill) {
    return (
      <Image
        {...imageProps}
        fill
        alt={alt || ''}
      />
    );
  }

  // 固定尺寸模式
  if (width && height) {
    return (
      <Image
        {...imageProps}
        width={width}
        height={height}
        alt={alt || ''}
      />
    );
  }

  // 自適應模式（需要容器設置相對定位）
  return (
    <div className="relative w-full h-full">
      <Image
        {...imageProps}
        fill
        style={{ objectFit: 'cover', ...style }}
        alt={alt || ''}
      />
    </div>
  );
};

/**
 * 頭像圖片組件
 * 專門用於用戶頭像的響應式圖片組件
 */
export interface AvatarImageProps {
  src: string;
  alt: string;
  size?: 'sm' | 'md' | 'lg' | 'xl';
  className?: string;
  fallbackText?: string;
}

export const AvatarImage: React.FC<AvatarImageProps> = ({
  src,
  alt,
  size = 'md',
  className = '',
  fallbackText
}) => {
  const [imageError, setImageError] = useState(false);

  const sizeClasses = {
    sm: 'w-8 h-8',
    md: 'w-12 h-12',
    lg: 'w-16 h-16',
    xl: 'w-24 h-24'
  };

  const sizePx = {
    sm: 32,
    md: 48,
    lg: 64,
    xl: 96
  };

  if (imageError) {
    return (
      <div 
        className={`${sizeClasses[size]} rounded-full bg-gray-300 flex items-center justify-center ${className}`}
      >
        <span className="text-gray-600 font-medium text-sm">
          {fallbackText || alt.charAt(0).toUpperCase()}
        </span>
      </div>
    );
  }

  return (
    <div className={`${sizeClasses[size]} relative rounded-full overflow-hidden ${className}`}>
      <ResponsiveImage
        src={src}
        alt={alt}
        width={sizePx[size]}
        height={sizePx[size]}
        className="rounded-full"
        quality={85}
        onError={() => setImageError(true)}
        sizes={`${sizePx[size]}px`}
      />
    </div>
  );
};

/**
 * 卡片圖片組件
 * 用於卡片中的響應式圖片
 */
export interface CardImageProps {
  src: string;
  alt: string;
  aspectRatio?: 'square' | 'video' | 'wide' | 'tall';
  className?: string;
  priority?: boolean;
}

export const CardImage: React.FC<CardImageProps> = ({
  src,
  alt,
  aspectRatio = 'video',
  className = '',
  priority = false
}) => {
  const aspectClasses = {
    square: 'aspect-square',
    video: 'aspect-video',
    wide: 'aspect-[21/9]',
    tall: 'aspect-[3/4]'
  };

  return (
    <div className={`relative ${aspectClasses[aspectRatio]} overflow-hidden ${className}`}>
      <ResponsiveImage
        src={src}
        alt={alt}
        fill
        priority={priority}
        className="object-cover"
        sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
      />
    </div>
  );
};

/**
 * 圖片工具函數
 */
export const imageUtils = {
  /**
   * 生成模糊佔位符
   */
  generateBlurDataURL: (width: number = 10, height: number = 10): string => {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    if (ctx) {
      ctx.fillStyle = '#f3f4f6';
      ctx.fillRect(0, 0, width, height);
    }
    
    return canvas.toDataURL();
  },

  /**
   * 檢查圖片是否可訪問
   */
  checkImageAccessibility: async (src: string): Promise<boolean> => {
    try {
      const response = await fetch(src, { method: 'HEAD' });
      return response.ok;
    } catch {
      return false;
    }
  },

  /**
   * 獲取圖片尺寸
   */
  getImageDimensions: (src: string): Promise<{ width: number; height: number }> => {
    return new Promise((resolve, reject) => {
      const img = new (globalThis.Image || window.Image)();
      img.onload = () => {
        resolve({ width: img.naturalWidth, height: img.naturalHeight });
      };
      img.onerror = reject;
      img.src = src;
    });
  },

  /**
   * 生成響應式 sizes 屬性
   */
  generateResponsiveSizes: (breakpoints: Record<string, string>): string => {
    const sizeEntries = Object.entries(breakpoints);
    const sizeStrings = sizeEntries.map(([breakpoint, size]) => {
      if (breakpoint === 'default') {
        return size;
      }
      return `(max-width: ${breakpoint}) ${size}`;
    });
    
    return sizeStrings.join(', ');
  }
};

const ResponsiveImageExports = {
  ResponsiveImage,
  AvatarImage,
  CardImage,
  imageUtils
};

export default ResponsiveImageExports;
</file>

<file path="src/hooks/useContainerQuery.ts">
import React, { useEffect, useRef, useState } from 'react';

/**
 * 容器查詢工具類型定義
 */
export interface ContainerQueryOptions {
  containerName?: string;
  containerType?: 'inline-size' | 'block-size' | 'size' | 'style';
  fallbackBreakpoint?: number;
}

/**
 * 容器查詢 Hook
 * 提供容器查詢功能的 React Hook
 */
export const useContainerQuery = (
  breakpoint: number,
  options: ContainerQueryOptions = {}
) => {
  const containerRef = useRef<HTMLElement>(null);
  const [isMatched, setIsMatched] = useState(false);
  
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;
    
    // 檢查瀏覽器是否支持容器查詢
    if (!CSS.supports('container-type', 'inline-size')) {
      // 降級到 ResizeObserver
      const resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const { inlineSize } = entry.borderBoxSize[0];
          setIsMatched(inlineSize >= breakpoint);
        }
      });
      
      resizeObserver.observe(container);
      
      return () => {
        resizeObserver.disconnect();
      };
    }
    
    // 使用原生容器查詢
    const { containerName = 'component', containerType = 'inline-size' } = options;
    
    // 設置容器屬性
    container.style.containerType = containerType;
    container.style.containerName = containerName;
    
    // 監聽容器大小變化
    const mediaQuery = `(min-width: ${breakpoint}px)`;
    const containerQuery = window.matchMedia(`@container ${containerName} ${mediaQuery}`);
    
    const handleChange = (e: MediaQueryListEvent) => {
      setIsMatched(e.matches);
    };
    
    // 初始化匹配状态
    const initialMatch = containerQuery.matches;
    
    containerQuery.addEventListener('change', handleChange);
    
    // 使用 setTimeout 避免同步设置状态
    setTimeout(() => {
      setIsMatched(initialMatch);
    }, 0);
    
    return () => {
      containerQuery.removeEventListener('change', handleChange);
    };
  }, [breakpoint, options]);
  
  return { containerRef, isMatched };
};

/**
 * 容器查詢工具函數
 */
export const containerQueryUtils = {
  /**
   * 檢查瀏覽器是否支持容器查詢
   */
  isSupported: (): boolean => {
    return CSS.supports('container-type', 'inline-size');
  },
  
  /**
   * 為元素設置容器查詢屬性
   */
  setupContainer: (
    element: HTMLElement,
    options: ContainerQueryOptions = {}
  ): void => {
    const { containerName = 'component', containerType = 'inline-size' } = options;
    element.style.containerType = containerType;
    element.style.containerName = containerName;
  },
  
  /**
   * 創建容器查詢媒體查詢字符串
   */
  createQuery: (
    containerName: string,
    condition: string
  ): string => {
    return `@container ${containerName} (${condition})`;
  },
  
  /**
   * 獲取容器查詢斷點配置
   */
  getBreakpoints: () => ({
    xs: 280,
    sm: 320,
    md: 480,
    lg: 640,
    xl: 800,
    '2xl': 1024
  }),
  
  /**
   * 生成容器查詢 CSS 類名
   */
  generateClassName: (
    baseClass: string,
    breakpoint: string,
    condition: string
  ): string => {
    return `${baseClass}-cq-${breakpoint}-${condition}`;
  }
};

/**
 * 容器查詢組件包裝器
 */
interface ContainerQueryWrapperProps {
  children: React.ReactNode;
  containerName?: string;
  containerType?: 'inline-size' | 'block-size' | 'size';
  className?: string;
}

export const ContainerQueryWrapper = React.forwardRef<HTMLDivElement, ContainerQueryWrapperProps>(
  function ContainerQueryWrapper({ children, containerName = 'component', containerType = 'inline-size', className = '' }, ref) {
    const internalRef = useRef<HTMLDivElement>(null);
    
    // 合并外部 ref 和内部 ref
    const setRef = React.useCallback((node: HTMLDivElement | null) => {
      // 设置内部 ref
      internalRef.current = node;
      
      // 设置外部 ref（如果存在）
      if (typeof ref === 'function') {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
      
      // 设置容器查询
      if (node) {
        containerQueryUtils.setupContainer(node, {
          containerName,
          containerType
        });
      }
    }, [ref, containerName, containerType]);
    
    /* eslint-disable react-hooks/refs */
    return React.createElement(
      'div',
      {
        ref: setRef,
        className: `container-query-${containerName} ${className}`,
        style: {
          containerType,
          containerName
        } as React.CSSProperties
      },
      children
    );
    /* eslint-enable react-hooks/refs */
  }
);

const containerQueryExports = {
  useContainerQuery,
  containerQueryUtils,
  ContainerQueryWrapper
};

export default containerQueryExports;
</file>

<file path="src/hooks/useSwipe.ts">
import { useState, useEffect, useCallback } from 'react';

interface SwipeDirection {
  x: number;
  y: number;
}

interface SwipeHandlers {
  onSwipeLeft?: () => void;
  onSwipeRight?: () => void;
  onSwipeUp?: () => void;
  onSwipeDown?: () => void;
  onPinchStart?: (distance: number) => void;
  onPinchMove?: (distance: number, scale: number) => void;
  onPinchEnd?: () => void;
  onTap?: () => void;
  onDoubleTap?: () => void;
  onLongPress?: () => void;
}

interface UseSwipeOptions {
  threshold?: number; // 最小滑動距離
  preventDefaultTouchmoveEvent?: boolean;
  trackMouse?: boolean; // 是否追蹤滑鼠事件（用於桌面測試）
  longPressDelay?: number; // 長按延遲時間（毫秒）
  doubleTapDelay?: number; // 雙擊延遲時間（毫秒）
  pinchThreshold?: number; // 捏合手勢閾值
}

export const useSwipe = (
  handlers: SwipeHandlers,
  options: UseSwipeOptions = {}
) => {
  const {
    threshold = 50,
    preventDefaultTouchmoveEvent = false,
    trackMouse = false,
    longPressDelay = 500,
    doubleTapDelay = 300,
    // pinchThreshold: _pinchThreshold = 10
  } = options;

  const [startPos, setStartPos] = useState<SwipeDirection>({ x: 0, y: 0 });
  const [endPos, setEndPos] = useState<SwipeDirection>({ x: 0, y: 0 });
  const [isSwiping, setIsSwiping] = useState(false);
  const [isPinching, setIsPinching] = useState(false);
  const [initialPinchDistance, setInitialPinchDistance] = useState(0);
  const [lastTapTime, setLastTapTime] = useState(0);
  const [longPressTimer, setLongPressTimer] = useState<NodeJS.Timeout | null>(null);
  const [touchStartTime, setTouchStartTime] = useState(0);

  // 計算兩點間距離（用於捏合手勢）
  const getDistance = useCallback((touch1: Touch, touch2: Touch): number => {
    const dx = touch1.clientX - touch2.clientX;
    const dy = touch1.clientY - touch2.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }, []);

  const handleStart = useCallback((clientX: number, clientY: number) => {
    setStartPos({ x: clientX, y: clientY });
    setEndPos({ x: clientX, y: clientY });
    setIsSwiping(true);
    setTouchStartTime(Date.now());

    // 設置長按計時器
    const timer = setTimeout(() => {
      handlers.onLongPress?.();
      setIsSwiping(false);
    }, longPressDelay);
    setLongPressTimer(timer);
  }, [handlers, longPressDelay]);

  const handleMove = useCallback((clientX: number, clientY: number) => {
    if (!isSwiping) return;
    setEndPos({ x: clientX, y: clientY });
  }, [isSwiping]);

  const handleEnd = useCallback(() => {
    // 清除長按計時器
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      setLongPressTimer(null);
    }

    if (!isSwiping && !isPinching) return;
    
    const deltaX = endPos.x - startPos.x;
    const deltaY = endPos.y - startPos.y;
    const absDeltaX = Math.abs(deltaX);
    const absDeltaY = Math.abs(deltaY);
    const touchDuration = Date.now() - touchStartTime;

    // 處理捏合手勢結束
    if (isPinching) {
      handlers.onPinchEnd?.();
      setIsPinching(false);
      setInitialPinchDistance(0);
      return;
    }

    // 判斷是否為點擊（短時間且移動距離小）
    if (touchDuration < 200 && Math.max(absDeltaX, absDeltaY) < 10) {
      const now = Date.now();
      const timeSinceLastTap = now - lastTapTime;
      
      if (timeSinceLastTap < doubleTapDelay) {
        // 雙擊
        handlers.onDoubleTap?.();
      } else {
        // 單擊
        handlers.onTap?.();
      }
      
      setLastTapTime(now);
      setIsSwiping(false);
      return;
    }

    // 判斷是否達到滑動閾值
    if (Math.max(absDeltaX, absDeltaY) < threshold) {
      setIsSwiping(false);
      return;
    }

    // 判斷滑動方向（優先處理較大的軸向移動）
    if (absDeltaX > absDeltaY) {
      // 水平滑動
      if (deltaX > 0) {
        handlers.onSwipeRight?.();
      } else {
        handlers.onSwipeLeft?.();
      }
    } else {
      // 垂直滑動
      if (deltaY > 0) {
        handlers.onSwipeDown?.();
      } else {
        handlers.onSwipeUp?.();
      }
    }

    setIsSwiping(false);
  }, [startPos, endPos, threshold, handlers, isSwiping, isPinching, longPressTimer, touchStartTime, lastTapTime, doubleTapDelay]);

  // 觸摸事件處理
  const onTouchStart = useCallback((e: TouchEvent) => {
    if (e.touches.length === 1) {
      // 單指觸摸
      const touch = e.touches[0];
      handleStart(touch.clientX, touch.clientY);
    } else if (e.touches.length === 2) {
      // 雙指觸摸（捏合手勢）
      const distance = getDistance(e.touches[0], e.touches[1]);
      setInitialPinchDistance(distance);
      setIsPinching(true);
      setIsSwiping(false);
      handlers.onPinchStart?.(distance);
      
      // 清除長按計時器
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        setLongPressTimer(null);
      }
    }
  }, [handleStart, getDistance, handlers, longPressTimer]);

  const onTouchMove = useCallback((e: TouchEvent) => {
    if (preventDefaultTouchmoveEvent) {
      e.preventDefault();
    }

    if (e.touches.length === 1 && isSwiping) {
      // 單指滑動
      const touch = e.touches[0];
      handleMove(touch.clientX, touch.clientY);
    } else if (e.touches.length === 2 && isPinching) {
      // 雙指捏合
      const distance = getDistance(e.touches[0], e.touches[1]);
      const scale = distance / initialPinchDistance;
      handlers.onPinchMove?.(distance, scale);
    }
  }, [handleMove, preventDefaultTouchmoveEvent, isSwiping, isPinching, getDistance, initialPinchDistance, handlers]);

  const onTouchEnd = useCallback(() => {
    handleEnd();
  }, [handleEnd]);

  // 滑鼠事件處理（用於桌面測試）
  const onMouseDown = useCallback((e: MouseEvent) => {
    if (!trackMouse) return;
    handleStart(e.clientX, e.clientY);
  }, [handleStart, trackMouse]);

  const onMouseMove = useCallback((e: MouseEvent) => {
    if (!trackMouse) return;
    handleMove(e.clientX, e.clientY);
  }, [handleMove, trackMouse]);

  const onMouseUp = useCallback(() => {
    if (!trackMouse) return;
    handleEnd();
  }, [handleEnd, trackMouse]);

  // 綁定事件監聽器
  useEffect(() => {
    const element = document;

    // 觸摸事件
    element.addEventListener('touchstart', onTouchStart, { passive: true });
    element.addEventListener('touchmove', onTouchMove, { passive: !preventDefaultTouchmoveEvent });
    element.addEventListener('touchend', onTouchEnd, { passive: true });

    // 滑鼠事件（可選）
    if (trackMouse) {
      element.addEventListener('mousedown', onMouseDown);
      element.addEventListener('mousemove', onMouseMove);
      element.addEventListener('mouseup', onMouseUp);
    }

    return () => {
      element.removeEventListener('touchstart', onTouchStart);
      element.removeEventListener('touchmove', onTouchMove);
      element.removeEventListener('touchend', onTouchEnd);
      
      if (trackMouse) {
        element.removeEventListener('mousedown', onMouseDown);
        element.removeEventListener('mousemove', onMouseMove);
        element.removeEventListener('mouseup', onMouseUp);
      }
    };
  }, [
    onTouchStart, onTouchMove, onTouchEnd,
    onMouseDown, onMouseMove, onMouseUp,
    trackMouse, preventDefaultTouchmoveEvent
  ]);

  return {
    isSwiping,
    isPinching,
    swipeDirection: {
      x: endPos.x - startPos.x,
      y: endPos.y - startPos.y
    },
    // 觸摸事件處理器（用於手動綁定）
    touchHandlers: {
      onTouchStart,
      onTouchMove,
      onTouchEnd
    },
    // 滑鼠事件處理器（用於手動綁定）
    mouseHandlers: trackMouse ? {
      onMouseDown,
      onMouseMove,
      onMouseUp
    } : undefined
  };
};

export default useSwipe;
</file>

<file path="src/services/apiService.ts">
import { Persona, DebateContext, SourceReference, GeminiResponse } from '@/types';

/**
 * API 客戶端服務 - 處理前端與後端 API 的通信
 */
export class ApiService {
  private static baseUrl = '/api';

  /**
   * 生成替身回應
   */
  static async generatePersonaResponse(
    persona: Persona,
    context: DebateContext,
    searchResults?: SourceReference[]
  ): Promise<GeminiResponse> {
    try {
      const response = await fetch(`${this.baseUrl}/debate/enhanced`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          action: 'speak',
          persona,
          context,
          searchResults,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to generate persona response');
      }

      return data.response;
    } catch (error) {
      console.error('Error generating persona response:', error);
      throw error;
    }
  }

  /**
   * 搜尋議題相關資訊
   */
  static async searchTopicInformation(
    topic: string,
    personas: Persona[]
  ): Promise<{
    keywords: string[];
    searchResults: SourceReference[];
  }> {
    try {
      const response = await fetch(`${this.baseUrl}/search/enhanced`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          action: 'grounding',
          topic,
          personas,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to search topic information');
      }

      return {
        keywords: data.keywords,
        searchResults: data.results,
      };
    } catch (error) {
      console.error('Error searching topic information:', error);
      throw error;
    }
  }

  /**
   * 分析議題並生成關鍵詞
   */
  static async analyzeTopicAndGenerateKeywords(
    topic: string,
    personas: Persona[]
  ): Promise<string[]> {
    try {
      const response = await fetch(`${this.baseUrl}/search/enhanced`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          action: 'keywords',
          topic,
          personas,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to analyze topic');
      }

      return data.keywords;
    } catch (error) {
      console.error('Error analyzing topic:', error);
      throw error;
    }
  }

  /**
   * 執行自定義搜尋
   */
  static async performCustomSearch(
    topic: string,
    keywords?: string[]
  ): Promise<SourceReference[]> {
    try {
      const response = await fetch(`${this.baseUrl}/search/enhanced`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          action: 'search',
          topic,
          keywords,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to perform custom search');
      }

      return data.results;
    } catch (error) {
      console.error('Error performing custom search:', error);
      throw error;
    }
  }

  /**
   * 批量生成替身回應
   */
  static async generateBatchPersonaResponses(
    requests: Array<{
      persona: Persona;
      context: DebateContext;
      searchResults?: SourceReference[];
    }>
  ): Promise<GeminiResponse[]> {
    try {
      const promises = requests.map(request =>
        this.generatePersonaResponse(request.persona, request.context, request.searchResults)
      );

      const responses = await Promise.allSettled(promises);
      
      return responses.map((result, index) => {
        if (result.status === 'fulfilled') {
          return result.value;
        } else {
          console.error(`Failed to generate response for persona ${requests[index].persona.name}:`, result.reason);
          return {
            content: `抱歉，${requests[index].persona.name} 暫時無法回應。`,
            tendencyScore: 5,
            error: result.reason instanceof Error ? result.reason.message : 'Unknown error',
          };
        }
      });
    } catch (error) {
      console.error('Error generating batch persona responses:', error);
      throw error;
    }
  }

  /**
   * 健康檢查
   */
  static async healthCheck(): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/health`, {
        method: 'GET',
      });

      return response.ok;
    } catch (error) {
      console.error('Health check failed:', error);
      return false;
    }
  }

  /**
   * 錯誤重試機制
   */
  static async withRetry<T>(
    operation: () => Promise<T>,
    maxRetries: number = 3,
    delay: number = 1000
  ): Promise<T> {
    let lastError: Error;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error('Unknown error');
        
        if (attempt === maxRetries) {
          throw lastError;
        }

        console.warn(`Attempt ${attempt} failed, retrying in ${delay}ms...`, lastError.message);
        await new Promise(resolve => setTimeout(resolve, delay));
        delay *= 2; // 指數退避
      }
    }

    throw lastError!;
  }

  /**
   * 帶重試的替身回應生成
   */
  static async generatePersonaResponseWithRetry(
    persona: Persona,
    context: DebateContext,
    searchResults?: SourceReference[],
    maxRetries: number = 3
  ): Promise<GeminiResponse> {
    return this.withRetry(
      () => this.generatePersonaResponse(persona, context, searchResults),
      maxRetries
    );
  }

  /**
   * 帶重試的搜尋功能
   */
  static async searchTopicInformationWithRetry(
    topic: string,
    personas: Persona[],
    maxRetries: number = 3
  ): Promise<{
    keywords: string[];
    searchResults: SourceReference[];
  }> {
    return this.withRetry(
      () => this.searchTopicInformation(topic, personas),
      maxRetries
    );
  }
}

export default ApiService;
</file>

<file path="src/services/consensusManager.ts">
import { Statement, ConsensusData, Persona } from '@/types';
import { consensusUtils } from '@/utils';

/**
 * 投票機制類型
 */
export type VotingMethod = 'simple' | 'weighted' | 'ranked' | 'consensus';

/**
 * 投票選項
 */
export interface VotingOption {
  id: string;
  label: string;
  description?: string;
  value: number; // 1-10 的支持度
}

/**
 * 投票結果
 */
export interface VotingResult {
  optionId: string;
  votes: {
    personaId: string;
    personaName: string;
    score: number;
    reasoning?: string;
    weight?: number;
  }[];
  totalScore: number;
  averageScore: number;
  weightedScore?: number;
  supportRate: number;
}

/**
 * 投票會話
 */
export interface VotingSession {
  id: string;
  topic: string;
  method: VotingMethod;
  options: VotingOption[];
  participants: Persona[];
  results: VotingResult[];
  status: 'pending' | 'active' | 'completed' | 'cancelled';
  startTime: number;
  endTime?: number;
  consensusData?: ConsensusData;
}

/**
 * 共識計算和投票機制管理器
 */
export class ConsensusManager {
  private votingSessions: Map<string, VotingSession> = new Map();
  private onSessionUpdate?: (session: VotingSession) => void;
  private onConsensusReached?: (session: VotingSession, consensus: ConsensusData) => void;

  constructor(options?: {
    onSessionUpdate?: (session: VotingSession) => void;
    onConsensusReached?: (session: VotingSession, consensus: ConsensusData) => void;
  }) {
    if (options) {
      this.onSessionUpdate = options.onSessionUpdate;
      this.onConsensusReached = options.onConsensusReached;
    }
  }

  /**
   * 創建投票會話
   */
  createVotingSession(
    topic: string,
    method: VotingMethod,
    participants: Persona[],
    options: Omit<VotingOption, 'id'>[] = []
  ): VotingSession {
    const sessionId = this.generateSessionId();
    
    // 如果沒有提供選項，創建默認的支持/反對選項
    const votingOptions: VotingOption[] = options.length > 0 
      ? options.map((opt, index) => ({ ...opt, id: `option_${index}` }))
      : [
          { id: 'support', label: '支持', description: '支持此議題', value: 8 },
          { id: 'oppose', label: '反對', description: '反對此議題', value: 3 },
          { id: 'neutral', label: '中立', description: '保持中立立場', value: 5 },
        ];

    const session: VotingSession = {
      id: sessionId,
      topic,
      method,
      options: votingOptions,
      participants,
      results: votingOptions.map(option => ({
        optionId: option.id,
        votes: [],
        totalScore: 0,
        averageScore: 0,
        supportRate: 0,
      })),
      status: 'pending',
      startTime: Date.now(),
    };

    this.votingSessions.set(sessionId, session);
    this.onSessionUpdate?.(session);
    
    return session;
  }

  /**
   * 開始投票會話
   */
  startVotingSession(sessionId: string): boolean {
    const session = this.votingSessions.get(sessionId);
    if (!session || session.status !== 'pending') {
      return false;
    }

    session.status = 'active';
    this.onSessionUpdate?.(session);
    return true;
  }

  /**
   * 提交投票
   */
  submitVote(
    sessionId: string,
    personaId: string,
    optionId: string,
    score: number,
    reasoning?: string
  ): boolean {
    const session = this.votingSessions.get(sessionId);
    if (!session || session.status !== 'active') {
      return false;
    }

    // 驗證分數範圍
    if (score < 1 || score > 10) {
      throw new Error('投票分數必須在 1-10 之間');
    }

    // 找到對應的結果記錄
    const result = session.results.find(r => r.optionId === optionId);
    if (!result) {
      return false;
    }

    // 找到參與者
    const persona = session.participants.find(p => p.id === personaId);
    if (!persona) {
      return false;
    }

    // 移除該參與者之前的投票（如果有）
    result.votes = result.votes.filter(v => v.personaId !== personaId);

    // 添加新投票
    const weight = this.calculatePersonaWeight(persona, session.method);
    result.votes.push({
      personaId,
      personaName: persona.name,
      score,
      reasoning,
      weight,
    });

    // 重新計算結果
    this.recalculateResults(session);
    this.onSessionUpdate?.(session);

    // 檢查是否所有人都已投票
    if (this.isVotingComplete(session)) {
      this.completeVotingSession(sessionId);
    }

    return true;
  }

  /**
   * 批量提交投票（基於辯論陳述）
   */
  submitVotesFromStatements(
    sessionId: string,
    statements: Statement[]
  ): boolean {
    const session = this.votingSessions.get(sessionId);
    if (!session || session.status !== 'active') {
      return false;
    }

    // 根據陳述的傾向度分數自動分配投票
    statements.forEach(statement => {
      const score = statement.tendencyScore;
      let optionId: string;

      // 根據傾向度分數決定投票選項
      if (score >= 7) {
        optionId = 'support';
      } else if (score <= 4) {
        optionId = 'oppose';
      } else {
        optionId = 'neutral';
      }

      this.submitVote(
        sessionId,
        statement.personaId,
        optionId,
        score,
        statement.content.substring(0, 100) + '...'
      );
    });

    return true;
  }

  /**
   * 完成投票會話
   */
  completeVotingSession(sessionId: string): boolean {
    const session = this.votingSessions.get(sessionId);
    if (!session || session.status !== 'active') {
      return false;
    }

    session.status = 'completed';
    session.endTime = Date.now();

    // 計算最終共識
    const consensusData = this.calculateFinalConsensus(session);
    session.consensusData = consensusData;

    this.onSessionUpdate?.(session);
    this.onConsensusReached?.(session, consensusData);

    return true;
  }

  /**
   * 取消投票會話
   */
  cancelVotingSession(sessionId: string): boolean {
    const session = this.votingSessions.get(sessionId);
    if (!session) {
      return false;
    }

    session.status = 'cancelled';
    session.endTime = Date.now();
    this.onSessionUpdate?.(session);

    return true;
  }

  /**
   * 獲取投票會話
   */
  getVotingSession(sessionId: string): VotingSession | undefined {
    return this.votingSessions.get(sessionId);
  }

  /**
   * 獲取所有投票會話
   */
  getAllVotingSessions(): VotingSession[] {
    return Array.from(this.votingSessions.values());
  }

  /**
   * 計算參與者權重
   */
  private calculatePersonaWeight(persona: Persona, method: VotingMethod): number {
    switch (method) {
      case 'simple':
        return 1;
      case 'weighted':
        // 基於專業度和經驗計算權重
        const expertiseWeight = persona.ragFocus.length * 0.2;
        const temperatureWeight = (1 - persona.temperature) * 0.3; // 較低溫度表示更理性
        return Math.max(0.5, Math.min(2, 1 + expertiseWeight + temperatureWeight));
      case 'ranked':
        return 1; // 排序投票中每票權重相等
      case 'consensus':
        return 1; // 共識機制中每票權重相等
      default:
        return 1;
    }
  }

  /**
   * 重新計算投票結果
   */
  private recalculateResults(session: VotingSession): void {
    session.results.forEach(result => {
      if (result.votes.length === 0) {
        result.totalScore = 0;
        result.averageScore = 0;
        result.weightedScore = 0;
        result.supportRate = 0;
        return;
      }

      // 計算總分和平均分
      result.totalScore = result.votes.reduce((sum, vote) => sum + vote.score, 0);
      result.averageScore = result.totalScore / result.votes.length;

      // 計算加權分數
      const totalWeight = result.votes.reduce((sum, vote) => sum + (vote.weight || 1), 0);
      result.weightedScore = result.votes.reduce(
        (sum, vote) => sum + (vote.score * (vote.weight || 1)), 0
      ) / totalWeight;

      // 計算支持率
      result.supportRate = result.averageScore / 10;
    });
  }

  /**
   * 檢查投票是否完成
   */
  private isVotingComplete(session: VotingSession): boolean {
    const totalVotes = session.results.reduce((sum, result) => sum + result.votes.length, 0);
    return totalVotes >= session.participants.length;
  }

  /**
   * 計算最終共識
   */
  private calculateFinalConsensus(session: VotingSession): ConsensusData {
    // 收集所有投票分數
    const allScores: number[] = [];
    const allWeights: number[] = [];

    session.results.forEach(result => {
      result.votes.forEach(vote => {
        allScores.push(vote.score);
        allWeights.push(vote.weight || 1);
      });
    });

    // 使用進階共識計算
    const consensusReport = consensusUtils.generateConsensusReport(
      allScores,
      allWeights,
      [] // 暫時不提供歷史數據
    );

    return {
      supportRate: consensusReport.basic.supportRate,
      opposeRate: consensusReport.basic.opposeRate,
      consensusReached: consensusReport.basic.consensusReached,
      threshold: consensusReport.basic.threshold,
      finalScores: consensusReport.basic.finalScores,
      confidence: consensusReport.weighted.confidenceLevel,
      recommendation: consensusReport.summary.recommendation,
      nextSteps: consensusReport.summary.nextSteps,
    };
  }

  /**
   * 生成會話 ID
   */
  private generateSessionId(): string {
    return `voting_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * 獲取投票統計
   */
  getVotingStatistics(sessionId: string): {
    totalParticipants: number;
    votedParticipants: number;
    participationRate: number;
    averageScore: number;
    scoreDistribution: Record<string, number>;
    topOption: { optionId: string; label: string; score: number } | null;
  } | null {
    const session = this.votingSessions.get(sessionId);
    if (!session) return null;

    const totalParticipants = session.participants.length;
    const votedParticipants = new Set(
      session.results.flatMap(r => r.votes.map(v => v.personaId))
    ).size;

    const participationRate = totalParticipants > 0 ? votedParticipants / totalParticipants : 0;

    const allScores = session.results.flatMap(r => r.votes.map(v => v.score));
    const averageScore = allScores.length > 0 
      ? allScores.reduce((sum, score) => sum + score, 0) / allScores.length 
      : 0;

    // 分數分布
    const scoreDistribution: Record<string, number> = {};
    for (let i = 1; i <= 10; i++) {
      scoreDistribution[i.toString()] = allScores.filter(score => score === i).length;
    }

    // 最高分選項
    const topResult = session.results.reduce((top, current) => 
      current.averageScore > (top?.averageScore || 0) ? current : top
    , session.results[0]);

    const topOption = topResult ? {
      optionId: topResult.optionId,
      label: session.options.find(opt => opt.id === topResult.optionId)?.label || '',
      score: topResult.averageScore,
    } : null;

    return {
      totalParticipants,
      votedParticipants,
      participationRate,
      averageScore,
      scoreDistribution,
      topOption,
    };
  }

  /**
   * 清理已完成的會話
   */
  cleanup(maxAge: number = 24 * 60 * 60 * 1000): number { // 默認 24 小時
    const now = Date.now();
    let cleanedCount = 0;

    for (const [sessionId, session] of this.votingSessions.entries()) {
      if (session.status === 'completed' || session.status === 'cancelled') {
        const sessionAge = now - (session.endTime || session.startTime);
        if (sessionAge > maxAge) {
          this.votingSessions.delete(sessionId);
          cleanedCount++;
        }
      }
    }

    return cleanedCount;
  }
}
</file>

<file path="src/styles/components.css">
/* 添加 line-clamp 工具類 */
@layer utilities {
  .line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
  
  .line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }
  
  .line-clamp-3 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
  }
}

/* 自定義動畫 */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.animate-fade-in-up {
  animation: fadeInUp 0.3s ease-out;
}

.animate-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* 改進的焦點樣式 */
.focus-ring {
  @apply focus:outline-none focus:ring-4 focus:ring-blue-500/20;
}

/* 卡片懸停效果 */
.card-hover {
  @apply transition-all duration-300 ease-out hover:shadow-lg hover:scale-[1.02];
}

/* 按鈕樣式 */
.btn-primary {
  @apply bg-blue-600 text-white px-4 py-2 rounded-lg font-medium transition-colors hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-500/20 disabled:opacity-50 disabled:cursor-not-allowed;
}

.btn-secondary {
  @apply bg-gray-100 text-gray-700 px-4 py-2 rounded-lg font-medium transition-colors hover:bg-gray-200 focus:outline-none focus:ring-4 focus:ring-gray-500/20 disabled:opacity-50 disabled:cursor-not-allowed;
}

/* 響應式間距 */
.container-padding {
  @apply px-4 sm:px-6 lg:px-8;
}

/* 文字截斷 */
.text-truncate {
  @apply overflow-hidden whitespace-nowrap text-ellipsis;
}

/* 滾動條樣式 */
.custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: #cbd5e1 #f1f5f9;
}

.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}
</file>

<file path="src/types/gemini.ts">
// Gemini API related types

export interface GeminiResponse {
  content: string;
  tendencyScore: number;
  reasoning?: {
    analyze: string;
    critique: string;
    strategy: string;
  };
  sources?: SourceReference[];
  searchQueries?: string[];
  error?: string;
  metadata?: {
    searchQueries?: string[];
    groundingMetadata?: GroundingMetadata;
  };
}

export interface SourceReference {
  url: string;
  title: string;
  snippet: string;
  relevanceScore?: number;
}

export interface GroundingMetadata {
  groundingChunks?: GroundingChunk[];
  groundingSupports?: GroundingSupport[];
  webSearchQueries?: string[];
  [key: string]: unknown;
}

export interface GroundingChunk {
  web?: {
    uri?: string;
    title?: string;
    snippet?: string;
  };
}

export interface GroundingSupport {
  segment?: {
    startIndex?: number;
    endIndex?: number;
  };
  groundingChunkIndices?: number[];
}

export interface DebateStateData {
  error?: string;
  currentSpeaker?: string;
  round?: number;
  [key: string]: unknown;
}

export interface PersistedState {
  rooms?: unknown[];
  availablePersonas?: unknown[];
  userPreferences?: unknown;
  debateHistory?: unknown[];
  [key: string]: unknown;
}

// Gemini API response interface compatible with Google Generative AI
export interface GeminiApiResponse {
  response?: {
    text(): string;
    candidates?: Array<{
      groundingMetadata?: GroundingMetadata; // Use any to be compatible with Google's types
    }>;
  };
  [key: string]: unknown;
}
</file>

<file path="src/types/index.ts">
// Core Types for Virtual Meeting Room System

export interface Persona {
  id: string;
  name: string;
  role: string;               // 角色
  identity?: string;          // 核心身份
  primeDirective?: string;    // 最高目標
  toneStyle?: string;         // 辯論風格
  defaultBias?: string;       // 預設傾向
  ragFocus: string[];         // 搜尋重點
  temperature: number;        // 創造性參數 (0.1-1.0)
  systemPrompt: string;       // 系統提示詞
  avatar?: string;            // 頭像 URL
  color?: string;             // 主題顏色
  isActive?: boolean;         // 是否參與當前辯論
}

export interface Statement {
  id: string;
  personaId: string;
  personaName: string;        // 發言者姓名
  content: string;
  timestamp: number;
  round: number;
  tendencyScore: number;      // 傾向度分數 (1-10)
  sources?: SourceReference[];
  references: SourceReference[]; // 引用資料
  tags: string[];             // 標籤
  reasoning?: {
    analyze: string;          // 解析階段
    critique: string;         // 批判階段
    strategy: string;         // 策略階段
  };
}

export interface SourceReference {
  url: string;
  title: string;
  snippet: string;
  relevanceScore?: number;
}

export interface SearchResult {
  query: string;
  results: SourceReference[];
  timestamp: number;
  personaFocus: string[];
}

export interface ConsensusData {
  supportRate: number;        // 支持度 (0-1)
  opposeRate: number;         // 反對度 (0-1)
  consensusReached: boolean;  // 是否達成共識
  threshold: number;          // 共識門檻 (預設 0.7)
  finalScores: Record<string, number>; // 各替身最終分數
  confidence?: number;        // 信心水準 (0-1)
  recommendation?: string;    // 建議
  nextSteps?: string[];       // 下一步行動
}

export interface MeetingRoom {
  id: string;
  name: string;
  topic: string;
  createdAt: number;
  updatedAt: number;
  status: DebateStatus;
  participants: Persona[];
  moderator?: Persona;          // 主持人
  statements: Statement[];
  searchResults: SearchResult[];
  consensus?: ConsensusData;
  settings: MeetingSettings;
  isTopicGenerated?: boolean;   // 主題是否由AI生成
}

export interface MeetingSettings {
  maxRounds: number;          // 最大回合數 (3-10)
  consensusThreshold: number; // 共識門檻 (0.5-0.9)
  timeoutPerRound: number;    // 每回合超時時間 (秒)
  allowUserIntervention: boolean; // 允許用戶干預
  autoSaveInterval: number;   // 自動保存間隔 (秒)
}

export type DebateStatus = 
  | 'idle'          // 閒置
  | 'preparing'     // 準備中
  | 'searching'     // 搜尋資料
  | 'debating'      // 辯論中
  | 'voting'        // 投票階段
  | 'completed'     // 已完成
  | 'paused'        // 暫停
  | 'error';        // 錯誤

export interface DebateContext {
  topic: string;
  currentRound: number;
  maxRounds: number;
  previousStatements: Statement[];
  searchResults: SearchResult[];
  activePersonas: Persona[];
  currentSpeaker?: string;
}

export interface GeminiResponse {
  content: string;
  tendencyScore: number;
  reasoning?: {
    analyze: string;
    critique: string;
    strategy: string;
  };
  sources?: SourceReference[];
  searchQueries?: string[];
  error?: string;
}

export interface StorageData {
  personas: Persona[];
  meetingRooms: MeetingRoom[];
  userPreferences: UserPreferences;
  version: string;
}

export interface UserPreferences {
  theme: 'light' | 'dark' | 'auto';
  language: 'zh-TW' | 'zh-CN' | 'en';
  autoSave: boolean;
  notificationsEnabled: boolean;
  defaultMeetingSettings: MeetingSettings;
}
</file>

<file path="src/types/store.ts">
// Store related types

export interface DebateRecord {
  id: string;
  roomId: string;
  roomName: string;
  topic: string;
  participants: string[];
  startTime: number;
  endTime?: number;
  totalRounds: number;
  finalConsensus?: {
    supportRate: number;
    opposeRate: number;
    consensusReached: boolean;
  };
  keyInsights: string[];
}

export interface NotificationData {
  type: 'info' | 'success' | 'warning' | 'error';
  title: string;
  message: string;
  autoClose?: boolean;
  duration?: number;
}

export interface PersistedRoomState {
  rooms?: Record<string, unknown>[];
  availablePersonas?: Record<string, unknown>[];
  userPreferences?: Record<string, unknown>;
  [key: string]: unknown;
}
</file>

<file path="src/utils/fluidTypography.ts">
/**
 * 流體排版工具函數
 * 基於數學公式計算 CSS clamp() 函數的參數
 */

export interface FluidTypographyConfig {
  minSize: number;      // 最小字體大小 (px)
  maxSize: number;      // 最大字體大小 (px)
  minScreen: number;    // 最小屏幕寬度 (px)
  maxScreen: number;    // 最大屏幕寬度 (px)
  unit?: 'rem' | 'px';  // 輸出單位
  baseFontSize?: number; // 基礎字體大小，用於 rem 轉換
}

export interface FluidTypographyResult {
  clampValue: string;
  vwValue: number;
  remValue: number;
  cssCustomProperty?: string;
}

/**
 * 流體排版計算器
 */
export class FluidTypographyCalculator {
  private baseFontSize: number;
  
  constructor(baseFontSize: number = 16) {
    this.baseFontSize = baseFontSize;
  }
  
  /**
   * 計算流體排版參數
   * 使用公式：v = (100 * (y2 - y1)) / (x2 - x1)
   *          r = (x1 * y2 - x2 * y1) / (x1 - x2)
   */
  calculate(config: FluidTypographyConfig): FluidTypographyResult {
    const { minSize, maxSize, minScreen, maxScreen, unit = 'rem', baseFontSize = this.baseFontSize } = config;
    
    // 計算 viewport 寬度值 (vw)
    const vwValue = (100 * (maxSize - minSize)) / (maxScreen - minScreen);
    
    // 計算相對大小值 (rem)
    const remValuePx = (minScreen * maxSize - maxScreen * minSize) / (minScreen - maxScreen);
    const remValue = remValuePx / baseFontSize;
    
    // 轉換最小值和最大值到指定單位
    const minValue = unit === 'rem' ? minSize / baseFontSize : minSize;
    const maxValue = unit === 'rem' ? maxSize / baseFontSize : maxSize;
    
    // 生成 clamp 值
    const clampValue = `clamp(${minValue}${unit}, ${vwValue.toFixed(3)}vw + ${remValue.toFixed(3)}rem, ${maxValue}${unit})`;
    
    return {
      clampValue,
      vwValue: Number(vwValue.toFixed(3)),
      remValue: Number(remValue.toFixed(3)),
      cssCustomProperty: `--fluid-${minSize}-${maxSize}: ${clampValue};`
    };
  }
  
  /**
   * 批量計算多個流體排版配置
   */
  calculateBatch(configs: Record<string, FluidTypographyConfig>): Record<string, FluidTypographyResult> {
    const results: Record<string, FluidTypographyResult> = {};
    
    for (const [key, config] of Object.entries(configs)) {
      results[key] = this.calculate(config);
    }
    
    return results;
  }
  
  /**
   * 生成 CSS 自定義屬性
   */
  generateCSSCustomProperties(configs: Record<string, FluidTypographyConfig>): string {
    const results = this.calculateBatch(configs);
    const cssProperties: string[] = [];
    
    for (const [key, result] of Object.entries(results)) {
      cssProperties.push(`  --fluid-${key}: ${result.clampValue};`);
    }
    
    return `:root {\n${cssProperties.join('\n')}\n}`;
  }
  
  /**
   * 驗證流體排版在特定視窗寬度下的值
   */
  validateAtViewport(config: FluidTypographyConfig, viewportWidth: number): number {
    const { minSize, maxSize, minScreen, maxScreen } = config;
    
    if (viewportWidth <= minScreen) {
      return minSize;
    }
    
    if (viewportWidth >= maxScreen) {
      return maxSize;
    }
    
    // 線性插值計算
    const ratio = (viewportWidth - minScreen) / (maxScreen - minScreen);
    return minSize + (maxSize - minSize) * ratio;
  }
}

/**
 * 預設的流體排版配置
 */
export const defaultFluidTypographyConfigs: Record<string, FluidTypographyConfig> = {
  'heading-1': {
    minSize: 24,    // 1.5rem
    maxSize: 48,    // 3rem
    minScreen: 320,
    maxScreen: 1920,
    unit: 'rem'
  },
  'heading-2': {
    minSize: 20,    // 1.25rem
    maxSize: 36,    // 2.25rem
    minScreen: 320,
    maxScreen: 1920,
    unit: 'rem'
  },
  'heading-3': {
    minSize: 18,    // 1.125rem
    maxSize: 30,    // 1.875rem
    minScreen: 320,
    maxScreen: 1920,
    unit: 'rem'
  },
  'body': {
    minSize: 14,    // 0.875rem
    maxSize: 18,    // 1.125rem
    minScreen: 320,
    maxScreen: 1920,
    unit: 'rem'
  },
  'small': {
    minSize: 12,    // 0.75rem
    maxSize: 14,    // 0.875rem
    minScreen: 320,
    maxScreen: 1920,
    unit: 'rem'
  }
};

/**
 * 流體排版工具函數
 */
export const fluidTypographyUtils = {
  /**
   * 創建流體排版計算器實例
   */
  createCalculator: (baseFontSize?: number) => new FluidTypographyCalculator(baseFontSize),
  
  /**
   * 快速計算流體排版
   */
  quickCalculate: (minSize: number, maxSize: number, minScreen: number = 320, maxScreen: number = 1920) => {
    const calculator = new FluidTypographyCalculator();
    return calculator.calculate({
      minSize,
      maxSize,
      minScreen,
      maxScreen,
      unit: 'rem'
    });
  },
  
  /**
   * 生成預設配置的 CSS
   */
  generateDefaultCSS: () => {
    const calculator = new FluidTypographyCalculator();
    return calculator.generateCSSCustomProperties(defaultFluidTypographyConfigs);
  },
  
  /**
   * 檢查流體排版的可訪問性
   */
  checkAccessibility: (config: FluidTypographyConfig): {
    isAccessible: boolean;
    warnings: string[];
  } => {
    const warnings: string[] = [];
    let isAccessible = true;
    
    // 檢查最小字體大小
    if (config.minSize < 12) {
      warnings.push('最小字體大小小於 12px，可能影響可讀性');
      isAccessible = false;
    }
    
    // 檢查縮放比例
    const scaleRatio = config.maxSize / config.minSize;
    if (scaleRatio > 3) {
      warnings.push('字體縮放比例過大，可能在某些設備上顯示異常');
    }
    
    // 檢查屏幕寬度範圍
    if (config.maxScreen - config.minScreen < 600) {
      warnings.push('屏幕寬度範圍過小，流體效果可能不明顯');
    }
    
    return { isAccessible, warnings };
  }
};

const fluidTypographyExports = {
  FluidTypographyCalculator,
  fluidTypographyUtils,
  defaultFluidTypographyConfigs
};

export default fluidTypographyExports;
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
    './src/hooks/**/*.{js,ts,jsx,tsx,mdx}',
    './src/utils/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    // 語義化響應式斷點配置
    screens: {
      'mobile': '320px',    // 小型手機
      'tablet': '640px',    // 平板和大型手機  
      'laptop': '1024px',   // 筆記本電腦
      'desktop': '1280px',  // 桌面顯示器
      'wide': '1536px',     // 超寬屏幕
    },
    extend: {
      // 動畫和過渡
      animation: {
        'fade-in': 'fadeIn 0.3s ease-out',
        'slide-up': 'slideUp 0.3s ease-out',
        'slide-down': 'slideDown 0.3s ease-out',
        'scale-in': 'scaleIn 0.2s ease-out',
        'drawer-slide': 'drawerSlide 0.3s ease-out',
      },
      
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { transform: 'translateY(20px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
        slideDown: {
          '0%': { transform: 'translateY(-20px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
        scaleIn: {
          '0%': { transform: 'scale(0.95)', opacity: '0' },
          '100%': { transform: 'scale(1)', opacity: '1' },
        },
        drawerSlide: {
          '0%': { transform: 'translateX(-100%)' },
          '100%': { transform: 'translateX(0)' },
        },
      },
    },
  },
  plugins: [],
}

export default config
</file>

<file path="tests/touch-interactions.spec.ts">
import { test, expect } from '@playwright/test';

/**
 * 觸摸交互測試
 */
test.describe('觸摸交互測試', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/personas');
  });

  test('觸摸按鈕提供正確的反饋', async ({ page }) => {
    const button = page.locator('button').first();
    
    // 模擬觸摸開始
    await button.dispatchEvent('touchstart', {
      touches: [{ clientX: 100, clientY: 100 }]
    });
    
    // 檢查按鈕是否有按下狀態
    await expect(button).toHaveClass(/scale-95|active/);
    
    // 模擬觸摸結束
    await button.dispatchEvent('touchend');
    
    // 檢查按鈕狀態恢復
    await page.waitForTimeout(200);
    await expect(button).not.toHaveClass(/scale-95|active/);
  });

  test('長按手勢正確觸發', async ({ page }) => {
    const card = page.locator('.touch-card').first();
    
    // 模擬長按
    await card.dispatchEvent('touchstart', {
      touches: [{ clientX: 100, clientY: 100 }]
    });
    
    // 等待長按延遲時間
    await page.waitForTimeout(600);
    
    // 檢查長按效果
    await expect(card).toHaveClass(/long-pressing/);
    
    // 結束觸摸
    await card.dispatchEvent('touchend');
  });

  test('滑動手勢正確識別', async ({ page }) => {
    const swipeArea = page.locator('.gesture-area').first();
    
    // 模擬向右滑動
    await swipeArea.dispatchEvent('touchstart', {
      touches: [{ clientX: 100, clientY: 100 }]
    });
    
    await swipeArea.dispatchEvent('touchmove', {
      touches: [{ clientX: 200, clientY: 100 }]
    });
    
    await swipeArea.dispatchEvent('touchend');
    
    // 檢查滑動效果（這裡需要根據實際實現調整）
    await page.waitForTimeout(100);
  });

  test('捏合手勢正確處理', async ({ page }) => {
    const zoomArea = page.locator('.gesture-area').first();
    
    // 模擬雙指捏合
    await zoomArea.dispatchEvent('touchstart', {
      touches: [
        { clientX: 100, clientY: 100 },
        { clientX: 200, clientY: 200 }
      ]
    });
    
    // 模擬捏合動作
    await zoomArea.dispatchEvent('touchmove', {
      touches: [
        { clientX: 120, clientY: 120 },
        { clientX: 180, clientY: 180 }
      ]
    });
    
    await zoomArea.dispatchEvent('touchend');
    
    await page.waitForTimeout(100);
  });
});

/**
 * 容器查詢測試
 */
test.describe('容器查詢測試', () => {
  test('PersonaCard 在不同容器寬度下正確響應', async ({ page }) => {
    await page.goto('/personas');
    
    // 測試不同視窗寬度
    const viewports = [
      { width: 320, expectedLayout: 'column' },
      { width: 480, expectedLayout: 'row' },
      { width: 800, expectedLayout: 'grid' }
    ];
    
    for (const { width, expectedLayout } of viewports) {
      await page.setViewportSize({ width, height: 800 });
      await page.waitForTimeout(100);
      
      const card = page.locator('.persona-card').first();
      
      switch (expectedLayout) {
        case 'column':
          await expect(card).toHaveClass(/cq-flex-col/);
          break;
        case 'row':
          await expect(card).toHaveClass(/persona-card-narrow/);
          break;
        case 'grid':
          await expect(card).toHaveClass(/persona-card-wide/);
          break;
      }
    }
  });

  test('容器查詢降級策略正常工作', async ({ page }) => {
    // 禁用容器查詢支持（模擬舊瀏覽器）
    await page.addInitScript(() => {
      // 模擬不支持容器查詢的瀏覽器
      Object.defineProperty(CSS, 'supports', {
        value: (property: string) => {
          if (property === 'container-type') return false;
          return true;
        }
      });
    });
    
    await page.goto('/personas');
    
    // 檢查降級樣式是否正確應用
    const container = page.locator('.container-query-card').first();
    await expect(container).toHaveCSS('width', '100%');
  });
});

/**
 * 流體排版測試
 */
test.describe('流體排版測試', () => {
  test('標題字體大小正確縮放', async ({ page }) => {
    await page.goto('/');
    
    const heading = page.locator('.fluid-heading-1').first();
    
    // 測試不同視窗寬度下的字體大小
    const viewports = [
      { width: 320, minSize: 20, maxSize: 28 },
      { width: 768, minSize: 28, maxSize: 36 },
      { width: 1920, minSize: 40, maxSize: 48 }
    ];
    
    for (const { width, minSize, maxSize } of viewports) {
      await page.setViewportSize({ width, height: 800 });
      await page.waitForTimeout(100);
      
      const fontSize = await heading.evaluate((el) => {
        return parseFloat(window.getComputedStyle(el).fontSize);
      });
      
      expect(fontSize).toBeGreaterThanOrEqual(minSize);
      expect(fontSize).toBeLessThanOrEqual(maxSize);
    }
  });

  test('流體間距正確應用', async ({ page }) => {
    await page.goto('/');
    
    const element = page.locator('.fluid-space-md').first();
    
    const viewports = [320, 768, 1920];
    
    for (const width of viewports) {
      await page.setViewportSize({ width, height: 800 });
      await page.waitForTimeout(100);
      
      const margin = await element.evaluate((el) => {
        const styles = window.getComputedStyle(el);
        return parseFloat(styles.marginTop);
      });
      
      // 檢查間距是否在合理範圍內
      expect(margin).toBeGreaterThan(0);
      expect(margin).toBeLessThan(100);
    }
  });
});

/**
 * 圖片響應式測試
 */
test.describe('響應式圖片測試', () => {
  test('圖片在不同設備上正確加載', async ({ page }) => {
    await page.goto('/personas');
    
    const images = page.locator('img');
    const imageCount = await images.count();
    
    for (let i = 0; i < Math.min(imageCount, 3); i++) {
      const img = images.nth(i);
      
      // 檢查圖片是否加載成功
      await expect(img).toBeVisible();
      
      const naturalWidth = await img.evaluate((el: HTMLImageElement) => el.naturalWidth);
      expect(naturalWidth).toBeGreaterThan(0);
      
      // 檢查圖片是否有正確的 alt 屬性
      const alt = await img.getAttribute('alt');
      expect(alt).toBeTruthy();
    }
  });

  test('AvatarImage 組件正確處理錯誤', async ({ page }) => {
    // 注入一個會失敗的圖片 URL
    await page.goto('/personas');
    
    await page.evaluate(() => {
      const img = document.querySelector('img');
      if (img) {
        img.src = 'https://invalid-url.com/image.jpg';
      }
    });
    
    await page.waitForTimeout(1000);
    
    // 檢查是否顯示了降級內容
    const fallback = page.locator('.bg-gray-300');
    await expect(fallback).toBeVisible();
  });
});

/**
 * Web Vitals 性能測試
 */
test.describe('Web Vitals 性能測試', () => {
  test('LCP 性能指標符合標準', async ({ page }) => {
    await page.goto('/');
    
    // 等待 LCP 測量
    const lcp = await page.evaluate(() => {
      return new Promise<number>((resolve) => {
        new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const lastEntry = entries[entries.length - 1];
          resolve(lastEntry.startTime);
        }).observe({ entryTypes: ['largest-contentful-paint'] });
        
        // 5秒後超時
        setTimeout(() => resolve(0), 5000);
      });
    });
    
    if (lcp > 0) {
      expect(lcp).toBeLessThan(2500); // 2.5秒標準
    }
  });

  test('CLS 性能指標符合標準', async ({ page }) => {
    await page.goto('/');
    
    // 測量 CLS
    const cls = await page.evaluate(() => {
      return new Promise<number>((resolve) => {
        let clsValue = 0;
        
        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            const layoutShiftEntry = entry as PerformanceEntry & { hadRecentInput?: boolean; value?: number };
            if (!layoutShiftEntry.hadRecentInput) {
              clsValue += layoutShiftEntry.value || 0;
            }
          }
        }).observe({ entryTypes: ['layout-shift'] });
        
        // 3秒後返回結果
        setTimeout(() => resolve(clsValue), 3000);
      });
    });
    
    expect(cls).toBeLessThan(0.1); // 0.1 標準
  });
});

/**
 * 跨瀏覽器兼容性測試
 */
test.describe('跨瀏覽器兼容性測試', () => {
  test('CSS Grid 佈局在所有瀏覽器中正常工作', async ({ page }) => {
    await page.goto('/');
    
    const gridContainer = page.locator('.layout-grid-main, .card-grid-responsive').first();
    
    // 檢查 Grid 佈局是否正確應用
    const display = await gridContainer.evaluate((el) => {
      return window.getComputedStyle(el).display;
    });
    
    expect(display).toBe('grid');
    
    // 檢查 Grid 項目是否正確排列
    const gridItems = gridContainer.locator('> *');
    const itemCount = await gridItems.count();
    
    if (itemCount > 0) {
      const firstItem = gridItems.first();
      const position = await firstItem.boundingBox();
      expect(position).toBeTruthy();
    }
  });

  test('Flexbox 佈局在所有瀏覽器中正常工作', async ({ page }) => {
    await page.goto('/personas');
    
    const flexContainer = page.locator('.flex, .cq-flex-row, .cq-flex-col').first();
    
    const display = await flexContainer.evaluate((el) => {
      return window.getComputedStyle(el).display;
    });
    
    expect(display).toBe('flex');
  });
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/api/health/route.ts">
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    // 檢查環境變數
    const geminiApiKey = process.env.GEMINI_API_KEY;
    
    if (!geminiApiKey || geminiApiKey === 'your_gemini_api_key_here') {
      return NextResponse.json(
        { 
          status: 'error',
          message: 'Gemini API key not configured',
          timestamp: Date.now(),
        },
        { status: 503 }
      );
    }

    // 基本健康檢查
    const healthStatus = {
      status: 'healthy',
      timestamp: Date.now(),
      version: process.env.NEXT_PUBLIC_APP_VERSION || '1.0.0',
      environment: process.env.NODE_ENV || 'development',
      services: {
        gemini: 'configured',
        database: 'local_storage',
        search: 'google_grounding',
      },
    };

    return NextResponse.json(healthStatus);
  } catch (error) {
    console.error('Health check failed:', error);
    return NextResponse.json(
      { 
        status: 'error',
        message: 'Health check failed',
        timestamp: Date.now(),
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/search/enhanced/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { getGeminiService } from '@/services/geminiService';
import { Persona } from '@/types';

export async function POST(request: NextRequest) {
  try {
    const { action, ...params } = await request.json();
    
    const geminiService = getGeminiService();
    
    switch (action) {
      case 'grounding': {
        const { topic, personas } = params;
        
        if (!topic || !personas) {
          return NextResponse.json(
            { error: 'Topic and personas are required for grounding search' },
            { status: 400 }
          );
        }

        const keywords = await geminiService.analyzeTopicAndGenerateKeywords(topic, personas);
        const searchResults = await geminiService.searchTopicInformation(topic, keywords);

        return NextResponse.json({
          query: topic,
          keywords,
          results: searchResults,
          timestamp: Date.now(),
          personaFocus: personas.flatMap((p: Persona) => p.ragFocus),
          success: true,
        });
      }
      
      case 'keywords': {
        const { topic, personas } = params;
        
        if (!topic || !personas) {
          return NextResponse.json(
            { error: 'Topic and personas are required for keyword generation' },
            { status: 400 }
          );
        }

        const keywords = await geminiService.analyzeTopicAndGenerateKeywords(topic, personas);

        return NextResponse.json({
          topic,
          keywords,
          success: true,
        });
      }
      
      case 'search': {
        const { topic, keywords } = params;
        
        if (!topic) {
          return NextResponse.json(
            { error: 'Topic is required for search' },
            { status: 400 }
          );
        }

        const searchKeywords = keywords || [topic];
        const searchResults = await geminiService.searchTopicInformation(topic, searchKeywords);

        return NextResponse.json({
          query: topic,
          keywords: searchKeywords,
          results: searchResults,
          timestamp: Date.now(),
          success: true,
        });
      }
      
      default:
        return NextResponse.json(
          { error: `Unknown search action: ${action}` },
          { status: 400 }
        );
    }
  } catch (error) {
    console.error('Error in search API:', error);
    return NextResponse.json(
      { 
        error: 'Failed to perform search operation',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="src/components/ConsensusDisplay.tsx">
import React, { useState } from 'react';
import { ConsensusData, Statement } from '@/types';
import { VotingSession } from '@/services/consensusManager';

interface ConsensusDisplayProps {
  consensusData?: ConsensusData;
  statements: Statement[];
  onVotingComplete?: (session: VotingSession) => void;
  className?: string;
}

export const ConsensusDisplay: React.FC<ConsensusDisplayProps> = ({
  consensusData,
  statements,
  
  className = '',
}) => {
  
  
  
  const [showDetails, setShowDetails] = useState(false);

  // 計算實時共識數據
  const calculateRealTimeConsensus = (): ConsensusData | null => {
    if (statements.length === 0) return null;

    const scores = statements.map(s => s.tendencyScore);
    const totalScores = scores.reduce((sum, score) => sum + score, 0);
    const maxPossibleScore = scores.length * 10;
    const minPossibleScore = scores.length * 1;

    const supportRate = totalScores / maxPossibleScore;
    const opposeRate = (maxPossibleScore - totalScores) / (maxPossibleScore - minPossibleScore);
    const threshold = 0.7;
    const consensusReached = supportRate > threshold || opposeRate > threshold;

    const finalScores: Record<string, number> = {};
    statements.forEach((statement) => {
      finalScores[statement.personaId] = statement.tendencyScore;
    });

    return {
      supportRate,
      opposeRate,
      consensusReached,
      threshold,
      finalScores,
      confidence: Math.max(supportRate, opposeRate),
    };
  };

  const currentConsensus = consensusData || calculateRealTimeConsensus();

  const getConsensusLevel = (data: ConsensusData) => {
    const maxRate = Math.max(data.supportRate, data.opposeRate);
    if (maxRate >= 0.8) return { level: 'strong', color: 'green', text: '強烈共識' };
    if (maxRate >= 0.6) return { level: 'moderate', color: 'yellow', text: '中等共識' };
    if (maxRate >= 0.4) return { level: 'weak', color: 'orange', text: '微弱共識' };
    return { level: 'none', color: 'red', text: '無共識' };
  };

  const getProgressBarColor = (rate: number, type: 'support' | 'oppose') => {
    if (type === 'support') {
      return rate > 0.7 ? 'bg-green-500' : rate > 0.5 ? 'bg-green-400' : 'bg-green-300';
    } else {
      return rate > 0.7 ? 'bg-red-500' : rate > 0.5 ? 'bg-red-400' : 'bg-red-300';
    }
  };

  if (!currentConsensus) {
    return (
      <div className={`bg-white rounded-lg shadow-lg p-6 ${className}`}>
        <div className="text-center text-gray-500">
          <div className="text-4xl mb-2">📊</div>
          <p>尚無數據，等待辯論開始...</p>
        </div>
      </div>
    );
  }

  const consensusLevel = getConsensusLevel(currentConsensus);

  return (
    <div className={`bg-white rounded-lg shadow-lg p-6 ${className}`}>
      {/* 標題和狀態 */}
      <div className="flex items-center justify-between mb-6">
        <h3 className="text-lg font-semibold text-gray-900">共識分析</h3>
        <div className="flex items-center space-x-2">
          <span className={`px-3 py-1 rounded-full text-sm font-medium ${
            consensusLevel.color === 'green' ? 'bg-green-100 text-green-800' :
            consensusLevel.color === 'yellow' ? 'bg-yellow-100 text-yellow-800' :
            consensusLevel.color === 'orange' ? 'bg-orange-100 text-orange-800' :
            'bg-red-100 text-red-800'
          }`}>
            {consensusLevel.text}
          </span>
          <button
            onClick={() => setShowDetails(!showDetails)}
            className="text-gray-400 hover:text-gray-600"
          >
            {showDetails ? '📊' : '📈'}
          </button>
        </div>
      </div>

      {/* 主要指標 */}
      <div className="grid grid-cols-2 gap-4 mb-6">
        {/* 支持度 */}
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <span className="text-sm font-medium text-gray-700">支持度</span>
            <span className="text-sm text-gray-600">
              {(currentConsensus.supportRate * 100).toFixed(1)}%
            </span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-3">
            <div
              className={`h-3 rounded-full transition-all duration-500 ${getProgressBarColor(currentConsensus.supportRate, 'support')}`}
              style={{ width: `${currentConsensus.supportRate * 100}%` }}
            ></div>
          </div>
        </div>

        {/* 反對度 */}
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <span className="text-sm font-medium text-gray-700">反對度</span>
            <span className="text-sm text-gray-600">
              {(currentConsensus.opposeRate * 100).toFixed(1)}%
            </span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-3">
            <div
              className={`h-3 rounded-full transition-all duration-500 ${getProgressBarColor(currentConsensus.opposeRate, 'oppose')}`}
              style={{ width: `${currentConsensus.opposeRate * 100}%` }}
            ></div>
          </div>
        </div>
      </div>

      {/* 共識狀態 */}
      <div className="mb-6">
        <div className={`p-4 rounded-lg border-2 ${
          currentConsensus.consensusReached
            ? 'border-green-200 bg-green-50'
            : 'border-gray-200 bg-gray-50'
        }`}>
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <span className="text-lg">
                {currentConsensus.consensusReached ? '✅' : '⏳'}
              </span>
              <span className="font-medium">
                {currentConsensus.consensusReached ? '已達成共識' : '尚未達成共識'}
              </span>
            </div>
            <span className="text-sm text-gray-600">
              門檻: {(currentConsensus.threshold * 100).toFixed(0)}%
            </span>
          </div>
          
          {currentConsensus.confidence !== undefined && (
            <div className="mt-2">
              <div className="flex justify-between items-center text-sm">
                <span className="text-gray-600">信心水準</span>
                <span className="font-medium">
                  {(currentConsensus.confidence * 100).toFixed(1)}%
                </span>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* 詳細信息 */}
      {showDetails && (
        <div className="space-y-4">
          {/* 參與者分數 */}
          <div>
            <h4 className="text-sm font-medium text-gray-700 mb-2">參與者分數分布</h4>
            <div className="space-y-2">
              {Object.entries(currentConsensus.finalScores).map(([personaId, score]) => {
                const statement = statements.find(s => s.personaId === personaId);
                return (
                  <div key={personaId} className="flex items-center justify-between">
                    <span className="text-sm text-gray-600">
                      {statement?.personaName || personaId}
                    </span>
                    <div className="flex items-center space-x-2">
                      <div className="w-20 bg-gray-200 rounded-full h-2">
                        <div
                          className="h-2 bg-blue-500 rounded-full"
                          style={{ width: `${(score / 10) * 100}%` }}
                        ></div>
                      </div>
                      <span className="text-sm font-medium w-8 text-right">
                        {score.toFixed(1)}
                      </span>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>

          {/* 建議和下一步 */}
          {(currentConsensus.recommendation || currentConsensus.nextSteps) && (
            <div className="p-3 bg-blue-50 rounded-lg">
              {currentConsensus.recommendation && (
                <p className="text-sm text-blue-800 mb-2">
                  <strong>建議:</strong> {currentConsensus.recommendation}
                </p>
              )}
              {currentConsensus.nextSteps && currentConsensus.nextSteps.length > 0 && (
                <div className="text-sm text-blue-700">
                  <strong>下一步:</strong>
                  <ul className="list-disc list-inside mt-1 space-y-1">
                    {currentConsensus.nextSteps.map((step, index) => (
                      <li key={index}>{step}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
        </div>
      )}

      {/* 統計摘要 */}
      <div className="mt-6 pt-4 border-t border-gray-200">
        <div className="grid grid-cols-3 gap-4 text-center">
          <div>
            <div className="text-lg font-semibold text-gray-900">
              {statements.length}
            </div>
            <div className="text-xs text-gray-600">總發言數</div>
          </div>
          <div>
            <div className="text-lg font-semibold text-gray-900">
              {statements.length > 0 ? (statements.reduce((sum, s) => sum + s.tendencyScore, 0) / statements.length).toFixed(1) : '0'}
            </div>
            <div className="text-xs text-gray-600">平均分數</div>
          </div>
          <div>
            <div className="text-lg font-semibold text-gray-900">
              {new Set(statements.map(s => s.personaId)).size}
            </div>
            <div className="text-xs text-gray-600">參與者數</div>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/DebateControlPanel.tsx">
import React, { useState } from 'react';
import { DebateStatus } from '@/types';

interface DebateControlPanelProps {
  debateStatus: DebateStatus;
  currentRound: number;
  totalStatements: number;
  loading: boolean;
  onStart: (initialTopic?: string) => void;
  onPause: () => void;
  onResume: () => void;
  onStop: () => void;
  onNextRound: () => void;
  onReset: () => void;
  onTopicGenerated?: (topic: string) => void;
  disabled?: boolean;
}

export const DebateControlPanel: React.FC<DebateControlPanelProps> = ({
  debateStatus,
  currentRound,
  totalStatements,
  loading,
  onStart,
  onPause,
  onResume,
  onStop,
  onNextRound,
  onReset,
  
  disabled = false,
}) => {
  const [showConfirmReset, setShowConfirmReset] = useState(false);
  const [initialTopic, setInitialTopic] = useState('');
  const [showTopicInput, setShowTopicInput] = useState(false);

  const isDebating = debateStatus === 'debating';
  const isPaused = debateStatus === 'paused';
  const isCompleted = debateStatus === 'completed';
  const isError = debateStatus === 'error';
  const canStart = debateStatus === 'preparing' || isCompleted || isError;
  const canPause = isDebating && !loading;
  const canResume = isPaused;
  const canStop = isDebating || isPaused;
  const canNextRound = isDebating && !loading;

  const handleReset = () => {
    if (showConfirmReset) {
      onReset();
      setShowConfirmReset(false);
    } else {
      setShowConfirmReset(true);
      setTimeout(() => setShowConfirmReset(false), 3000);
    }
  };

  const handleStartWithTopic = () => {
    if (initialTopic.trim()) {
      onStart(initialTopic.trim());
      setInitialTopic('');
      setShowTopicInput(false);
    } else {
      onStart();
    }
  };

  const handleTopicKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleStartWithTopic();
    } else if (e.key === 'Escape') {
      setShowTopicInput(false);
      setInitialTopic('');
    }
  };

  const getStatusIcon = () => {
    switch (debateStatus) {
      case 'preparing': return '⚙️';
      case 'debating': return '🗣️';
      case 'paused': return '⏸️';
      case 'completed': return '✅';
      case 'error': return '❌';
      case 'searching': return '🔍';
      default: return '❓';
    }
  };

  return (
    <div className="card-mobile">
      {/* 標題區域 - 響應式優化 */}
      <div className="flex flex-col tablet:flex-row tablet:items-center tablet:justify-between gap-3 tablet:gap-0 mb-4 tablet:mb-6">
        <div className="flex items-center space-x-3 tablet:space-x-4">
          <div className="text-xl tablet:text-2xl">{getStatusIcon()}</div>
          <div className="flex-1 min-w-0">
            <h3 className="text-base tablet:text-lg font-semibold text-gray-900 prevent-overflow">辯論控制台</h3>
            <p className="text-xs tablet:text-sm text-gray-600">
              第 {currentRound} 輪 • {totalStatements} 個發言
            </p>
          </div>
        </div>
        
        {loading && (
          <div className="flex items-center text-xs tablet:text-sm text-gray-500">
            <div className="animate-spin rounded-full h-3 w-3 tablet:h-4 tablet:w-4 border-b-2 border-blue-500 mr-2"></div>
            處理中...
          </div>
        )}
      </div>

      {/* 初始議題輸入 - 移動端優化 */}
      {showTopicInput && canStart && (
        <div className="mb-4 p-3 tablet:p-4 bg-blue-50 rounded-lg border border-blue-200">
          <label className="block text-xs tablet:text-sm font-medium text-gray-700 mb-2">
            輸入第一個討論議題（可選）
          </label>
          <div className="flex flex-col tablet:flex-row gap-2">
            <input
              type="text"
              value={initialTopic}
              onChange={(e) => setInitialTopic(e.target.value)}
              onKeyDown={handleTopicKeyDown}
              placeholder="例如：我們應該如何應對氣候變化？"
              className="btn-touch flex-1 px-3 py-3 tablet:py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm tablet:text-base prevent-overflow"
              autoFocus
            />
            <div className="flex gap-2">
              <button
                onClick={handleStartWithTopic}
                className="btn-touch-lg flex-1 tablet:flex-none px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm tablet:text-base"
              >
                開始
              </button>
              <button
                onClick={() => {
                  setShowTopicInput(false);
                  setInitialTopic('');
                }}
                className="btn-touch-lg flex-1 tablet:flex-none px-4 py-3 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition-colors text-sm tablet:text-base"
              >
                取消
              </button>
            </div>
          </div>
          <p className="text-xs text-gray-500 mt-2">
            如果不輸入議題，AI將根據第一個發言自動生成會議主題
          </p>
        </div>
      )}

      {/* 主要控制按鈕 - 移動端單列布局 */}
      <div className="flex flex-col tablet:grid tablet:grid-cols-2 gap-3 mb-4">
        {canStart && (
          <>
            <button
              onClick={() => setShowTopicInput(true)}
              disabled={disabled || loading}
              className="btn-touch-lg flex items-center justify-center px-4 py-4 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors touch-feedback text-sm tablet:text-base"
            >
              <span className="mr-2 text-lg">▶️</span>
              設定議題開始
            </button>
            <button
              onClick={() => onStart()}
              disabled={disabled || loading}
              className="btn-touch-lg flex items-center justify-center px-4 py-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors touch-feedback text-sm tablet:text-base"
            >
              <span className="mr-2 text-lg">🚀</span>
              直接開始
            </button>
          </>
        )}

        {canPause && (
          <button
            onClick={onPause}
            disabled={disabled}
            className="btn-touch-lg flex items-center justify-center px-4 py-4 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors touch-feedback text-sm tablet:text-base"
          >
            <span className="mr-2 text-lg">⏸️</span>
            暫停
          </button>
        )}

        {canResume && (
          <button
            onClick={onResume}
            disabled={disabled || loading}
            className="btn-touch-lg flex items-center justify-center px-4 py-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors touch-feedback text-sm tablet:text-base"
          >
            <span className="mr-2 text-lg">▶️</span>
            繼續
          </button>
        )}

        {canStop && (
          <button
            onClick={onStop}
            disabled={disabled}
            className="btn-touch-lg flex items-center justify-center px-4 py-4 bg-red-600 text-white rounded-lg hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors touch-feedback text-sm tablet:text-base"
          >
            <span className="mr-2 text-lg">⏹️</span>
            停止
          </button>
        )}
      </div>

      {/* 次要控制按鈕 - 移動端單列布局 */}
      <div className="flex flex-col tablet:grid tablet:grid-cols-2 gap-3">
        {canNextRound && (
          <button
            onClick={onNextRound}
            disabled={disabled}
            className="btn-touch-lg flex items-center justify-center px-4 py-4 tablet:py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors touch-feedback text-sm tablet:text-base"
          >
            <span className="mr-2 text-lg">⏭️</span>
            下一輪
          </button>
        )}

        <button
          onClick={handleReset}
          disabled={disabled || loading}
          className={`btn-touch-lg flex items-center justify-center px-4 py-4 tablet:py-3 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed touch-feedback text-sm tablet:text-base ${
            showConfirmReset
              ? 'bg-red-600 text-white hover:bg-red-700'
              : 'bg-gray-600 text-white hover:bg-gray-700'
          }`}
        >
          <span className="mr-2 text-lg">{showConfirmReset ? '⚠️' : '🔄'}</span>
          {showConfirmReset ? '確認重置' : '重置'}
        </button>
      </div>

      {/* 狀態說明 - 移動端優化 */}
      <div className="mt-4 p-3 bg-gray-50 rounded-lg">
        <div className="text-xs tablet:text-sm text-gray-600 prevent-overflow">
          {debateStatus === 'preparing' && '準備開始辯論，請確認所有設定後點擊開始。'}
          {debateStatus === 'debating' && '辯論進行中，AI 替身正在生成發言內容。'}
          {debateStatus === 'paused' && '辯論已暫停，可以繼續或停止辯論。'}
          {debateStatus === 'completed' && '辯論已完成，可以查看結果或重新開始。'}
          {debateStatus === 'error' && '辯論過程中發生錯誤，請檢查設定後重新開始。'}
          {debateStatus === 'searching' && 'AI 正在搜尋相關資料以支持論點。'}
          {debateStatus === 'idle' && '可以設定初始議題開始辯論，或直接開始讓AI自動生成主題。'}
        </div>
      </div>

      {/* 快捷鍵提示 - 桌面端顯示 */}
      <div className="mt-4 text-xs text-gray-500 hidden laptop:block">
        <p>快捷鍵: Space (暫停/繼續) • Enter (下一輪) • Esc (停止)</p>
      </div>

      {/* 移動端操作提示 */}
      <div className="mt-4 text-xs text-gray-500 laptop:hidden">
        <p>💡 提示: 使用浮動按鈕快速控制辯論進度</p>
      </div>
    </div>
  );
};
</file>

<file path="src/components/EditableTopicHeader.tsx">
import React, { useState, useEffect } from 'react';
import { Edit2, Check, X, Sparkles, MessageSquare } from 'lucide-react';

interface EditableTopicHeaderProps {
  topic: string;
  isGenerated?: boolean;
  onTopicChange: (newTopic: string) => void;
  className?: string;
}

export const EditableTopicHeader: React.FC<EditableTopicHeaderProps> = ({
  topic,
  isGenerated = false,
  onTopicChange,
  className = '',
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(topic);
  const [showGeneratedBadge, setShowGeneratedBadge] = useState(isGenerated);

  // 使用 useEffect 來同步外部 props 變化
  useEffect(() => {
    if (!isEditing) {
      setEditValue(topic);
    }
  }, [topic, isEditing]);

  useEffect(() => {
    setShowGeneratedBadge(isGenerated);
  }, [isGenerated]);

  const handleSave = () => {
    if (editValue.trim() && editValue !== topic) {
      onTopicChange(editValue.trim());
      setShowGeneratedBadge(false); // 手動編輯後移除AI生成標記
    }
    setIsEditing(false);
  };

  const handleCancel = () => {
    setEditValue(topic);
    setIsEditing(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleSave();
    } else if (e.key === 'Escape') {
      handleCancel();
    }
  };

  return (
    <div className={`flex items-center gap-3 ${className}`}>
      {/* 會議主題圖標 */}
      <div className="w-8 h-8 bg-blue-500 rounded-lg flex items-center justify-center flex-shrink-0">
        <MessageSquare className="w-4 h-4 text-white" />
      </div>

      {/* 主題內容 */}
      <div className="flex-1 min-w-0">
        {isEditing ? (
          <div className="flex items-center gap-2">
            <input
              type="text"
              value={editValue}
              onChange={(e) => setEditValue(e.target.value)}
              onKeyDown={handleKeyDown}
              className="flex-1 px-3 py-2 border border-blue-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-lg font-semibold"
              placeholder="輸入會議主題..."
              autoFocus
            />
            <button
              onClick={handleSave}
              className="p-2 text-green-600 hover:bg-green-50 rounded-lg transition-colors"
              title="保存"
            >
              <Check className="w-4 h-4" />
            </button>
            <button
              onClick={handleCancel}
              className="p-2 text-gray-400 hover:bg-gray-50 rounded-lg transition-colors"
              title="取消"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        ) : (
          <div className="flex items-center gap-2 group">
            <h1 className="text-lg sm:text-xl font-semibold text-gray-900 truncate">
              {topic || '未設定會議主題'}
            </h1>
            
            {/* AI生成標記 */}
            {showGeneratedBadge && (
              <div className="flex items-center gap-1 px-2 py-1 bg-purple-100 text-purple-700 rounded-full text-xs font-medium">
                <Sparkles className="w-3 h-3" />
                <span>AI生成</span>
              </div>
            )}
            
            {/* 編輯按鈕 */}
            <button
              onClick={() => setIsEditing(true)}
              className="p-1.5 text-gray-400 hover:text-blue-500 hover:bg-blue-50 rounded-lg transition-colors opacity-0 group-hover:opacity-100"
              title="編輯主題"
            >
              <Edit2 className="w-4 h-4" />
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

export default EditableTopicHeader;
</file>

<file path="src/components/ModeratorSelectionPanel.tsx">
import React, { useState } from 'react';
import { Persona } from '@/types';
import { Crown, Users, Check } from 'lucide-react';

interface ModeratorCardProps {
  persona: Persona;
  isSelected: boolean;
  onClick: () => void;
}

const ModeratorCard: React.FC<ModeratorCardProps> = ({
  persona,
  isSelected,
  onClick,
}) => {
  return (
    <button
      onClick={onClick}
      className={`
        relative w-full p-4 rounded-xl border-2 transition-all duration-300 ease-out
        min-h-[160px] flex flex-col items-center text-center
        hover:shadow-lg hover:scale-[1.02] active:scale-[0.98]
        focus:outline-none focus:ring-4 focus:ring-amber-500/20
        ${isSelected 
          ? 'border-amber-500 bg-amber-50 shadow-md' 
          : 'border-gray-200 bg-white hover:border-gray-300'
        }
      `}
      aria-pressed={isSelected}
      aria-label={`選擇 ${persona.name} 作為主持人`}
    >
      {/* 選中狀態指示器 */}
      {isSelected && (
        <div className="absolute top-3 right-3 w-6 h-6 bg-amber-500 rounded-full flex items-center justify-center text-white">
          <Check className="w-4 h-4" />
        </div>
      )}

      {/* 主持人皇冠圖標 */}
      <div className="absolute top-3 left-3">
        <Crown className="w-5 h-5 text-amber-500" />
      </div>

      {/* 頭像 */}
      <div 
        className="w-12 h-12 rounded-full flex items-center justify-center text-white font-bold text-lg mb-3 shadow-md"
        style={{ backgroundColor: persona.color || '#f59e0b' }}
      >
        {persona.name.charAt(0)}
      </div>

      {/* 姓名和角色 */}
      <h3 className="font-semibold text-base text-gray-900 mb-2">
        {persona.name}
      </h3>
      
      <div className="px-3 py-1 bg-amber-100 text-amber-800 rounded-full text-sm font-medium mb-3">
        主持人
      </div>

      {/* 描述 */}
      <p className="text-sm text-gray-600 line-clamp-2 flex-1">
        {persona.identity || '專業的會議主持人'}
      </p>
    </button>
  );
};

interface ModeratorSelectionPanelProps {
  availablePersonas: Persona[];
  selectedModerator?: Persona;
  onModeratorSelect: (persona: Persona | undefined) => void;
  className?: string;
}

export const ModeratorSelectionPanel: React.FC<ModeratorSelectionPanelProps> = ({
  availablePersonas,
  selectedModerator,
  onModeratorSelect,
  className = '',
}) => {
  const [showSelection, setShowSelection] = useState(false);

  // 過濾出適合做主持人的人格（可以根據需要調整條件）
  const moderatorCandidates = availablePersonas.filter(persona => 
    persona.role.includes('主持') || 
    persona.role.includes('協調') || 
    persona.role.includes('管理') ||
    persona.name.includes('主持')
  );

  // 如果沒有專門的主持人，使用所有可用人格
  const candidates = moderatorCandidates.length > 0 ? moderatorCandidates : availablePersonas;

  const handleModeratorClick = (persona: Persona) => {
    if (selectedModerator?.id === persona.id) {
      // 如果點擊已選中的主持人，則取消選擇
      onModeratorSelect(undefined);
    } else {
      // 選擇新的主持人
      onModeratorSelect(persona);
    }
  };

  return (
    <div className={`w-full ${className}`}>
      {/* 主持人選擇區域 */}
      <div className="mb-6">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 bg-amber-500 rounded-lg flex items-center justify-center">
              <Crown className="w-5 h-5 text-white" />
            </div>
            <div>
              <h3 className="text-lg font-bold text-gray-900">會議主持人</h3>
              <p className="text-sm text-gray-600">選擇一位AI主持人來引導討論（可選）</p>
            </div>
          </div>
          
          <button
            onClick={() => setShowSelection(!showSelection)}
            className="px-4 py-2 bg-amber-100 text-amber-700 rounded-lg hover:bg-amber-200 transition-colors"
          >
            {showSelection ? '收起選擇' : '選擇主持人'}
          </button>
        </div>

        {/* 當前選中的主持人 */}
        {selectedModerator && (
          <div className="p-4 bg-amber-50 rounded-lg border border-amber-200 mb-4">
            <div className="flex items-center gap-3">
              <div 
                className="w-10 h-10 rounded-full flex items-center justify-center text-white font-bold"
                style={{ backgroundColor: selectedModerator.color || '#f59e0b' }}
              >
                {selectedModerator.name.charAt(0)}
              </div>
              <div className="flex-1">
                <div className="flex items-center gap-2">
                  <Crown className="w-4 h-4 text-amber-500" />
                  <span className="font-semibold text-gray-900">{selectedModerator.name}</span>
                  <span className="text-sm text-amber-600">（主持人）</span>
                </div>
                <p className="text-sm text-gray-600">{selectedModerator.identity}</p>
              </div>
              <button
                onClick={() => onModeratorSelect(undefined)}
                className="text-gray-400 hover:text-red-500 transition-colors"
                aria-label="移除主持人"
              >
                ×
              </button>
            </div>
          </div>
        )}

        {/* 主持人選擇網格 */}
        {showSelection && (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 p-4 bg-gray-50 rounded-lg">
            {candidates.length > 0 ? (
              candidates.map((persona) => (
                <ModeratorCard
                  key={persona.id}
                  persona={persona}
                  isSelected={selectedModerator?.id === persona.id}
                  onClick={() => handleModeratorClick(persona)}
                />
              ))
            ) : (
              <div className="col-span-full text-center py-8">
                <Crown className="w-12 h-12 text-gray-400 mx-auto mb-3" />
                <p className="text-gray-600">沒有可用的主持人候選</p>
              </div>
            )}
          </div>
        )}

        {/* 無主持人選項 */}
        {!selectedModerator && !showSelection && (
          <div className="p-4 bg-gray-50 rounded-lg border-2 border-dashed border-gray-300">
            <div className="text-center">
              <Users className="w-8 h-8 text-gray-400 mx-auto mb-2" />
              <p className="text-gray-600 text-sm">未選擇主持人</p>
              <p className="text-gray-500 text-xs">辯論將由參與者自由進行</p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default ModeratorSelectionPanel;
</file>

<file path="src/components/PersonaCard.tsx">
import React from 'react';
import { Persona } from '@/types';
import { User, Settings, Trash2, Edit3 } from 'lucide-react';
import { colorUtils } from '@/utils';
import { ContainerQueryWrapper } from '@/hooks';
import { AvatarImage } from './ResponsiveImage';
import { TouchCard, TouchIconButton } from './TouchComponents';

interface PersonaCardProps {
  persona: Persona;
  isSelected?: boolean;
  onToggle?: () => void;
  onEdit?: () => void;
  onDelete?: () => void;
  showControls?: boolean;
}

export const PersonaCard: React.FC<PersonaCardProps> = ({
  persona,
  isSelected = false,
  onToggle,
  onEdit,
  onDelete,
  showControls = true,
}) => {
  const cardStyle = {
    borderColor: persona.color || '#6b7280',
    backgroundColor: isSelected ? `${persona.color}10` : 'white',
  };

  const avatarStyle = {
    backgroundColor: persona.color || '#6b7280',
    color: colorUtils.isDark(persona.color || '#6b7280') ? 'white' : 'black',
  };

  return (
    <ContainerQueryWrapper
      containerName="card"
      containerType="inline-size"
      className="w-full"
    >
      <TouchCard
        className={`
          card-mobile cq-flex-col persona-card-narrow persona-card-wide
          ${isSelected ? 'shadow-lg scale-105 ring-2 ring-blue-500' : 'shadow-sm'}
          prevent-overflow
        `}
        style={cardStyle}
        onClick={onToggle}
      >
      {/* 頭像和基本資訊 - 響應式優化 */}
      <div className="flex items-start gap-3 mb-3">
        {persona.avatar ? (
          <AvatarImage
            src={persona.avatar}
            alt={persona.name}
            size="lg"
            className="w-12 h-12 tablet:w-14 tablet:h-14"
            fallbackText={persona.name.charAt(0)}
          />
        ) : (
          <div
            className="w-12 h-12 tablet:w-14 tablet:h-14 rounded-full flex items-center justify-center text-sm font-bold flex-shrink-0"
            style={avatarStyle}
          >
            <User className="w-6 h-6 tablet:w-7 tablet:h-7" />
          </div>
        )}
        
        <div className="flex-1 min-w-0">
          <h3 className="fluid-heading-3 font-semibold text-gray-900 prevent-overflow">
            {persona.name}
          </h3>
          <p className="fluid-small text-gray-600 line-clamp-2 prevent-overflow">
            {persona.identity}
          </p>
        </div>

        {/* 控制按鈕 - 觸摸優化 */}
        {showControls && (
          <div className="flex gap-1 flex-shrink-0">
            {onEdit && (
              <TouchIconButton
                icon={<Edit3 className="w-4 h-4" />}
                onClick={() => onEdit()}
                size="sm"
                variant="ghost"
                ariaLabel="編輯替身"
                className="text-gray-400 hover:text-blue-600"
              />
            )}
            {onDelete && (
              <TouchIconButton
                icon={<Trash2 className="w-4 h-4" />}
                onClick={() => onDelete()}
                size="sm"
                variant="ghost"
                ariaLabel="刪除替身"
                className="text-gray-400 hover:text-red-600"
              />
            )}
          </div>
        )}
      </div>

      {/* 核心原則 - 移動端優化 */}
      <div className="mb-3">
        <p className="text-xs text-gray-500 mb-1">核心原則</p>
        <p className="text-xs tablet:text-sm text-gray-700 line-clamp-2 prevent-overflow">
          {persona.primeDirective}
        </p>
      </div>

      {/* 溫度設定 - 觸摸友好 */}
      <div className="mb-3">
        <div className="flex justify-between items-center mb-2">
          <span className="text-xs text-gray-500">創造性</span>
          <span className="text-xs font-mono text-gray-600 bg-gray-100 px-2 py-1 rounded">
            {persona.temperature.toFixed(1)}
          </span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-3 tablet:h-2">
          <div
            className="h-3 tablet:h-2 rounded-full transition-all duration-300"
            style={{
              width: `${persona.temperature * 100}%`,
              backgroundColor: persona.color || '#6b7280',
            }}
          />
        </div>
      </div>

      {/* 專業領域標籤 - 響應式網格 */}
      <div className="mb-3">
        <p className="text-xs text-gray-500 mb-2">專業領域</p>
        <div className="flex flex-wrap gap-1">
          {persona.ragFocus.slice(0, 2).map((focus, index) => (
            <span
              key={index}
              className="px-2 py-1 text-xs rounded-full bg-gray-100 text-gray-700 prevent-overflow"
            >
              {focus}
            </span>
          ))}
          {persona.ragFocus.length > 2 && (
            <span className="px-2 py-1 text-xs rounded-full bg-gray-100 text-gray-500">
              +{persona.ragFocus.length - 2}
            </span>
          )}
        </div>
      </div>

      {/* 狀態指示器 - 移動端優化 */}
      <div className="flex justify-between items-center">
        <div className="flex items-center gap-2">
          <div
            className={`w-3 h-3 tablet:w-2 tablet:h-2 rounded-full ${
              persona.isActive ? 'bg-green-500' : 'bg-gray-300'
            }`}
          />
          <span className="text-xs text-gray-500">
            {persona.isActive ? '已選中' : '未選中'}
          </span>
        </div>
        
        <Settings className="w-4 h-4 text-gray-400" />
      </div>

      {/* 選中狀態覆蓋層 */}
        {isSelected && (
          <div className="absolute inset-0 border-2 border-blue-500 rounded-lg pointer-events-none animate-pulse" />
        )}
      </TouchCard>
    </ContainerQueryWrapper>
  );
};
</file>

<file path="src/components/PersonaEditor.tsx">
import React, { useState, useEffect } from 'react';
import { Persona } from '@/types';
import { X, Save, Plus, Minus, Palette } from 'lucide-react';
import { validatePersona } from '@/utils';

interface PersonaEditorProps {
  persona?: Persona;
  isOpen: boolean;
  onClose: () => void;
  onSave: (persona: Omit<Persona, 'id'>) => void;
}

const PRESET_COLORS = [
  '#1f2937', '#dc2626', '#059669', '#7c3aed',
  '#ea580c', '#0891b2', '#be123c', '#166534',
  '#7c2d12', '#581c87', '#92400e', '#1e40af',
];

export const PersonaEditor: React.FC<PersonaEditorProps> = ({
  persona,
  isOpen,
  onClose,
  onSave,
}) => {
  const [formData, setFormData] = useState({
    name: '',
    role: '',
    identity: '',
    primeDirective: '',
    toneStyle: '',
    defaultBias: '',
    ragFocus: [''],
    temperature: 0.7,
    systemPrompt: '',
    color: '#6b7280',
    avatar: '',
    isActive: false,
  });

  const [errors, setErrors] = useState<string[]>([]);

  // 初始化表單數據
  const initializeFormData = React.useCallback(() => {
    if (persona) {
      return {
        name: persona.name,
        role: persona.role,
        identity: persona.identity || '',
        primeDirective: persona.primeDirective || '',
        toneStyle: persona.toneStyle || '',
        defaultBias: persona.defaultBias || '',
        ragFocus: [...persona.ragFocus],
        temperature: persona.temperature,
        systemPrompt: persona.systemPrompt,
        color: persona.color || '#6b7280',
        avatar: persona.avatar || '',
        isActive: persona.isActive || false,
      };
    } else {
      return {
        name: '',
        role: '',
        identity: '',
        primeDirective: '',
        toneStyle: '',
        defaultBias: '',
        ragFocus: [''],
        temperature: 0.7,
        systemPrompt: '',
        color: '#6b7280',
        avatar: '',
        isActive: false,
      };
    }
  }, [persona]);

  // 當對話框打開時重置表單
  useEffect(() => {
    if (isOpen) {
      const newFormData = initializeFormData();
      // 使用 setTimeout 避免同步 setState
      setTimeout(() => {
        setFormData(newFormData);
        setErrors([]);
      }, 0);
    }
  }, [isOpen, initializeFormData]);

  const handleInputChange = (field: string, value: unknown) => {
    setFormData(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleRagFocusChange = (index: number, value: string) => {
    const newRagFocus = [...formData.ragFocus];
    newRagFocus[index] = value;
    setFormData(prev => ({
      ...prev,
      ragFocus: newRagFocus,
    }));
  };

  const addRagFocus = () => {
    setFormData(prev => ({
      ...prev,
      ragFocus: [...prev.ragFocus, ''],
    }));
  };

  const removeRagFocus = (index: number) => {
    if (formData.ragFocus.length > 1) {
      const newRagFocus = formData.ragFocus.filter((_, i) => i !== index);
      setFormData(prev => ({
        ...prev,
        ragFocus: newRagFocus,
      }));
    }
  };

  const handleSave = () => {
    // 過濾空的 ragFocus
    const cleanedFormData = {
      ...formData,
      ragFocus: formData.ragFocus.filter(focus => focus.trim().length > 0),
    };

    const validationErrors = validatePersona(cleanedFormData);
    if (validationErrors.length > 0) {
      setErrors(validationErrors);
      return;
    }

    onSave(cleanedFormData as Persona);
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
        {/* Header */}
        <div className="flex justify-between items-center p-6 border-b">
          <h2 className="text-xl font-semibold text-gray-900">
            {persona ? '編輯替身' : '創建新替身'}
          </h2>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 transition-colors"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Form */}
        <div className="p-6 space-y-6">
          {/* 錯誤訊息 */}
          {errors.length > 0 && (
            <div className="bg-red-50 border border-red-200 rounded-lg p-4">
              <h3 className="text-sm font-medium text-red-800 mb-2">請修正以下錯誤：</h3>
              <ul className="text-sm text-red-700 space-y-1">
                {errors.map((error, index) => (
                  <li key={index}>• {error}</li>
                ))}
              </ul>
            </div>
          )}

          {/* 基本資訊 */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                替身名稱 *
              </label>
              <input
                type="text"
                value={formData.name}
                onChange={(e) => handleInputChange('name', e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                placeholder="例如：CEO、技術專家"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                頭像 URL
              </label>
              <input
                type="url"
                value={formData.avatar}
                onChange={(e) => handleInputChange('avatar', e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                placeholder="https://example.com/avatar.jpg"
              />
            </div>
          </div>

          {/* 身份描述 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              身份描述 *
            </label>
            <textarea
              value={formData.identity}
              onChange={(e) => handleInputChange('identity', e.target.value)}
              rows={2}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="描述這個替身的職位、背景和專業技能"
            />
          </div>

          {/* 核心原則 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              核心原則 *
            </label>
            <textarea
              value={formData.primeDirective}
              onChange={(e) => handleInputChange('primeDirective', e.target.value)}
              rows={2}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="這個替身的最高目標和不可動搖的信仰"
            />
          </div>

          {/* 辯論風格 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              辯論風格 *
            </label>
            <textarea
              value={formData.toneStyle}
              onChange={(e) => handleInputChange('toneStyle', e.target.value)}
              rows={2}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="描述這個替身的語氣、用詞習慣和引用偏好"
            />
          </div>

          {/* 預設傾向 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              預設傾向
            </label>
            <textarea
              value={formData.defaultBias}
              onChange={(e) => handleInputChange('defaultBias', e.target.value)}
              rows={2}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="當資訊不足時的預設態度和偏好"
            />
          </div>

          {/* 搜尋重點 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              專業領域 *
            </label>
            <div className="space-y-2">
              {formData.ragFocus.map((focus, index) => (
                <div key={index} className="flex gap-2">
                  <input
                    type="text"
                    value={focus}
                    onChange={(e) => handleRagFocusChange(index, e.target.value)}
                    className="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    placeholder="例如：財務分析、技術趨勢"
                  />
                  {formData.ragFocus.length > 1 && (
                    <button
                      onClick={() => removeRagFocus(index)}
                      className="px-3 py-2 text-red-600 hover:bg-red-50 rounded-lg transition-colors"
                    >
                      <Minus className="w-4 h-4" />
                    </button>
                  )}
                </div>
              ))}
              <button
                onClick={addRagFocus}
                className="flex items-center gap-2 px-3 py-2 text-blue-600 hover:bg-blue-50 rounded-lg transition-colors"
              >
                <Plus className="w-4 h-4" />
                添加專業領域
              </button>
            </div>
          </div>

          {/* 溫度設定 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              創造性參數: {formData.temperature.toFixed(1)}
            </label>
            <input
              type="range"
              min="0.1"
              max="1.0"
              step="0.1"
              value={formData.temperature}
              onChange={(e) => handleInputChange('temperature', parseFloat(e.target.value))}
              className="w-full"
            />
            <div className="flex justify-between text-xs text-gray-500 mt-1">
              <span>保守 (0.1)</span>
              <span>平衡 (0.5)</span>
              <span>創新 (1.0)</span>
            </div>
          </div>

          {/* 顏色選擇 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              主題顏色
            </label>
            <div className="flex items-center gap-3">
              <div
                className="w-8 h-8 rounded-full border-2 border-gray-300"
                style={{ backgroundColor: formData.color }}
              />
              <div className="flex flex-wrap gap-2">
                {PRESET_COLORS.map((color) => (
                  <button
                    key={color}
                    onClick={() => handleInputChange('color', color)}
                    className={`w-6 h-6 rounded-full border-2 transition-all ${
                      formData.color === color ? 'border-gray-800 scale-110' : 'border-gray-300'
                    }`}
                    style={{ backgroundColor: color }}
                  />
                ))}
              </div>
              <Palette className="w-4 h-4 text-gray-400" />
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="flex justify-end gap-3 p-6 border-t bg-gray-50">
          <button
            onClick={onClose}
            className="px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors"
          >
            取消
          </button>
          <button
            onClick={handleSave}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors flex items-center gap-2"
          >
            <Save className="w-4 h-4" />
            保存
          </button>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/PersonaSelectionPanel.tsx">
import React, { useState } from 'react';
import { Persona } from '@/types';
import { Check, Users, Sparkles } from 'lucide-react';

interface PersonaCardProps {
  persona: Persona;
  isSelected: boolean;
  isDisabled: boolean;
  onClick: () => void;
}

const PersonaCard: React.FC<PersonaCardProps> = ({
  persona,
  isSelected,
  isDisabled,
  onClick,
}) => {
  return (
    <button
      onClick={onClick}
      disabled={isDisabled}
      className={`
        btn-touch card-mobile relative w-full transition-all duration-300 ease-out
        min-h-[160px] tablet:min-h-[180px] laptop:min-h-[200px] flex flex-col items-center text-center
        hover:shadow-lg hover:scale-[1.02] active:scale-[0.98] touch-feedback
        focus:outline-none focus:ring-4 focus:ring-blue-500/20
        disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100
        prevent-overflow
        ${isSelected 
          ? 'border-blue-500 bg-blue-50 shadow-md ring-2 ring-blue-500' 
          : 'border-gray-200 bg-white hover:border-gray-300'
        }
      `}
      style={{
        borderColor: isSelected ? persona.color : undefined,
        backgroundColor: isSelected ? `${persona.color}10` : undefined,
      }}
      aria-pressed={isSelected}
      aria-label={`選擇 ${persona.name} (${persona.role})`}
    >
      {/* 選中狀態指示器 */}
      {isSelected && (
        <div 
          className="absolute top-3 right-3 w-6 h-6 rounded-full flex items-center justify-center text-white"
          style={{ backgroundColor: persona.color }}
        >
          <Check className="w-4 h-4" />
        </div>
      )}

      {/* 頭像 - 響應式優化 */}
      <div 
        className="w-12 h-12 tablet:w-14 tablet:h-14 laptop:w-16 laptop:h-16 rounded-full flex items-center justify-center text-white font-bold text-sm tablet:text-lg laptop:text-xl mb-3 shadow-md flex-shrink-0"
        style={{ backgroundColor: persona.color }}
      >
        {persona.name.charAt(0)}
      </div>

      {/* 姓名和角色 - 移動端優化 */}
      <h3 className="font-semibold text-sm tablet:text-base laptop:text-lg text-gray-900 mb-2 prevent-overflow">
        {persona.name}
      </h3>
      
      <div 
        className="px-2 tablet:px-3 py-1 rounded-full text-xs tablet:text-sm font-medium text-white mb-3"
        style={{ backgroundColor: persona.color }}
      >
        {persona.role}
      </div>

      {/* 描述 - 響應式文字 */}
      <p className="text-xs tablet:text-sm text-gray-600 line-clamp-2 mb-3 flex-1 px-1 prevent-overflow">
        {persona.identity || '專業的辯論參與者'}
      </p>

      {/* 專業領域標籤 - 移動端顯示優化 */}
      <div className="flex flex-wrap gap-1 justify-center">
        {persona.ragFocus.slice(0, 1).map((focus, index) => (
          <span 
            key={index}
            className="px-2 py-1 bg-gray-100 text-gray-600 text-xs rounded-md prevent-overflow"
          >
            {focus}
          </span>
        ))}
        {persona.ragFocus.length > 1 && (
          <span className="px-2 py-1 bg-gray-100 text-gray-600 text-xs rounded-md">
            +{persona.ragFocus.length - 1}
          </span>
        )}
      </div>
    </button>
  );
};

interface PersonaSelectionPanelProps {
  availablePersonas: Persona[];
  selectedPersonas: Persona[];
  onPersonaToggle: (persona: Persona) => void;
  maxPersonas?: number;
  className?: string;
}

export const PersonaSelectionPanel: React.FC<PersonaSelectionPanelProps> = ({
  availablePersonas,
  selectedPersonas,
  onPersonaToggle,
  maxPersonas = 6,
  className = '',
}) => {
  const [animatingCards, setAnimatingCards] = useState<Set<string>>(new Set());

  const handlePersonaClick = (persona: Persona) => {
    // 添加動畫效果
    setAnimatingCards(prev => new Set(prev).add(persona.id));
    
    // 執行選擇邏輯
    onPersonaToggle(persona);
    
    // 移除動畫狀態
    setTimeout(() => {
      setAnimatingCards(prev => {
        const newSet = new Set(prev);
        newSet.delete(persona.id);
        return newSet;
      });
    }, 300);
  };

  const isPersonaSelected = (persona: Persona) => {
    return selectedPersonas.some(p => p.id === persona.id);
  };

  const isPersonaDisabled = (persona: Persona) => {
    return !isPersonaSelected(persona) && selectedPersonas.length >= maxPersonas;
  };

  return (
    <div className={`w-full h-full flex flex-col overflow-hidden ${className}`}>
      {/* 標題區域 - 響應式優化 */}
      <div className="flex-shrink-0 mb-4 tablet:mb-6">
        <div className="flex items-center gap-3 mb-4">
          <div className="w-8 h-8 tablet:w-10 tablet:h-10 bg-blue-500 rounded-lg flex items-center justify-center">
            <Users className="w-4 h-4 tablet:w-5 tablet:h-5 text-white" />
          </div>
          <div className="flex-1 min-w-0">
            <h2 className="text-lg tablet:text-xl laptop:text-2xl font-bold text-gray-900 prevent-overflow">選擇辯論參與者</h2>
            <p className="text-sm tablet:text-base text-gray-600 prevent-overflow">點擊卡片來選擇或取消選擇AI人格</p>
          </div>
        </div>

        {/* 選擇狀態指示器 - 移動端優化 */}
        <div className="flex flex-col tablet:flex-row tablet:items-center tablet:justify-between gap-2 tablet:gap-0 p-3 tablet:p-4 bg-gray-50 rounded-lg">
          <div className="flex items-center gap-2">
            <Sparkles className="w-4 h-4 tablet:w-5 tablet:h-5 text-blue-500" />
            <span className="font-medium text-gray-900 text-sm tablet:text-base">
              已選擇 {selectedPersonas.length} / {maxPersonas} 個參與者
            </span>
          </div>
          
          {selectedPersonas.length >= maxPersonas && (
            <div className="text-xs tablet:text-sm text-amber-600 bg-amber-50 px-2 tablet:px-3 py-1 rounded-full">
              已達到最大參與者數量
            </div>
          )}
        </div>
      </div>

      {/* 可滾動的內容區域 */}
      <div className="flex-1 overflow-y-auto">
        {/* 人格卡片網格 - 響應式網格 */}
        <div className="grid-responsive-cards mb-4 tablet:mb-6">
          {availablePersonas.map((persona) => (
            <div
              key={persona.id}
              className={`
                transition-transform duration-300
                ${animatingCards.has(persona.id) ? 'scale-105' : ''}
              `}
            >
              <PersonaCard
                persona={persona}
                isSelected={isPersonaSelected(persona)}
                isDisabled={isPersonaDisabled(persona)}
                onClick={() => handlePersonaClick(persona)}
              />
            </div>
          ))}
        </div>

        {/* 已選擇的參與者預覽 - 移動端優化 */}
        {selectedPersonas.length > 0 && (
          <div className="mb-4 tablet:mb-6 p-3 tablet:p-4 laptop:p-6 bg-blue-50 rounded-xl border border-blue-200">
            <h3 className="font-semibold text-gray-900 mb-3 tablet:mb-4 text-sm tablet:text-base">已選擇的參與者</h3>
            <div className="flex flex-wrap gap-2 tablet:gap-3">
              {selectedPersonas.map((persona) => (
                <div
                  key={persona.id}
                  className="flex items-center gap-2 px-2 tablet:px-3 py-1 tablet:py-2 bg-white rounded-lg shadow-sm border"
                >
                  <div 
                    className="w-5 h-5 tablet:w-6 tablet:h-6 rounded-full flex items-center justify-center text-white text-xs font-bold"
                    style={{ backgroundColor: persona.color }}
                  >
                    {persona.name.charAt(0)}
                  </div>
                  <span className="text-xs tablet:text-sm font-medium text-gray-900 prevent-overflow">
                    {persona.name}
                  </span>
                  <button
                    onClick={() => handlePersonaClick(persona)}
                    className="btn-touch w-5 h-5 tablet:w-4 tablet:h-4 text-gray-400 hover:text-red-500 transition-colors touch-area"
                    aria-label={`移除 ${persona.name}`}
                  >
                    ×
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* 空狀態 - 響應式優化 */}
        {availablePersonas.length === 0 && (
          <div className="text-center py-8 tablet:py-12">
            <Users className="w-12 h-12 tablet:w-16 tablet:h-16 text-gray-400 mx-auto mb-4" />
            <h3 className="text-base tablet:text-lg font-semibold text-gray-900 mb-2">
              沒有可用的人格
            </h3>
            <p className="text-sm tablet:text-base text-gray-600">
              請聯繫管理員添加AI人格
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default PersonaSelectionPanel;
</file>

<file path="src/components/TouchComponents.tsx">
import React, { useState, useCallback, useRef, useEffect } from 'react';

/**
 * 觸摸友好按鈕組件屬性
 */
export interface TouchButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  onLongPress?: () => void;
  disabled?: boolean;
  size?: 'sm' | 'md' | 'lg';
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost';
  className?: string;
  longPressDelay?: number;
  enableRipple?: boolean;
  enableHaptic?: boolean;
}

/**
 * 觸摸友好按鈕組件
 * 提供觸摸反饋、長按支持和觸覺反饋
 */
export const TouchButton: React.FC<TouchButtonProps> = ({
  children,
  onClick,
  onLongPress,
  disabled = false,
  size = 'md',
  variant = 'primary',
  className = '',
  longPressDelay = 500,
  enableRipple = true,
  enableHaptic = true
}) => {
  const [isPressed, setIsPressed] = useState(false);
  const [isLongPressing, setIsLongPressing] = useState(false);
  const buttonRef = useRef<HTMLButtonElement>(null);
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);
  const rippleRef = useRef<HTMLDivElement>(null);

  // 觸覺反饋
  const triggerHaptic = useCallback((type: 'light' | 'medium' | 'heavy' = 'light') => {
    if (!enableHaptic || !navigator.vibrate) return;
    
    const patterns = {
      light: [10],
      medium: [20],
      heavy: [30]
    };
    
    navigator.vibrate(patterns[type]);
  }, [enableHaptic]);

  // 波紋效果
  const createRipple = useCallback((event: React.MouseEvent | React.TouchEvent) => {
    if (!enableRipple || !buttonRef.current || !rippleRef.current) return;

    const button = buttonRef.current;
    const ripple = rippleRef.current;
    const rect = button.getBoundingClientRect();
    
    let clientX: number, clientY: number;
    
    if ('touches' in event) {
      clientX = event.touches[0].clientX;
      clientY = event.touches[0].clientY;
    } else {
      clientX = event.clientX;
      clientY = event.clientY;
    }
    
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    
    ripple.style.left = `${x}px`;
    ripple.style.top = `${y}px`;
    ripple.style.animation = 'none';
    void ripple.offsetHeight; // 觸發重排
    ripple.style.animation = 'touch-ripple 0.6s linear';
  }, [enableRipple]);

  // 處理按下
  const handlePressStart = useCallback((event: React.MouseEvent | React.TouchEvent) => {
    if (disabled) return;
    
    setIsPressed(true);
    createRipple(event);
    triggerHaptic('light');
    
    // 設置長按計時器
    if (onLongPress) {
      longPressTimer.current = setTimeout(() => {
        setIsLongPressing(true);
        triggerHaptic('medium');
        onLongPress();
      }, longPressDelay);
    }
  }, [disabled, createRipple, triggerHaptic, onLongPress, longPressDelay]);

  // 處理釋放
  const handlePressEnd = useCallback(() => {
    if (disabled) return;
    
    setIsPressed(false);
    setIsLongPressing(false);
    
    // 清除長按計時器
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
    }
  }, [disabled]);

  // 處理點擊
  const handleClick = useCallback(() => {
    if (disabled || isLongPressing) return;
    
    triggerHaptic('light');
    onClick?.();
  }, [disabled, isLongPressing, triggerHaptic, onClick]);

  // 清理計時器
  useEffect(() => {
    return () => {
      if (longPressTimer.current) {
        clearTimeout(longPressTimer.current);
      }
    };
  }, []);

  // 樣式類名
  const sizeClasses = {
    sm: 'touch-target-sm text-sm px-3 py-1.5',
    md: 'touch-target-md text-base px-4 py-2',
    lg: 'touch-target-lg text-lg px-6 py-3'
  };

  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800',
    secondary: 'bg-gray-600 text-white hover:bg-gray-700 active:bg-gray-800',
    outline: 'border-2 border-blue-600 text-blue-600 hover:bg-blue-50 active:bg-blue-100',
    ghost: 'text-blue-600 hover:bg-blue-50 active:bg-blue-100'
  };

  const baseClasses = `
    relative overflow-hidden rounded-lg font-medium transition-all duration-150
    focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2
    disabled:opacity-50 disabled:cursor-not-allowed
    gesture-area no-zoom
    ${sizeClasses[size]}
    ${variantClasses[variant]}
    ${isPressed ? 'scale-95' : ''}
    ${isLongPressing ? 'long-pressing' : ''}
    ${className}
  `;

  return (
    <button
      ref={buttonRef}
      className={baseClasses}
      disabled={disabled}
      onClick={handleClick}
      onMouseDown={handlePressStart}
      onMouseUp={handlePressEnd}
      onMouseLeave={handlePressEnd}
      onTouchStart={handlePressStart}
      onTouchEnd={handlePressEnd}
      onTouchCancel={handlePressEnd}
    >
      {children}
      
      {/* 波紋效果 */}
      {enableRipple && (
        <div
          ref={rippleRef}
          className="absolute w-1 h-1 bg-white/30 rounded-full pointer-events-none"
          style={{ transform: 'scale(0)' }}
        />
      )}
      
      {/* 長按指示器 */}
      {isLongPressing && (
        <div className="absolute inset-0 bg-white/10 rounded-lg animate-pulse" />
      )}
    </button>
  );
};

/**
 * 觸摸友好圖標按鈕組件
 */
export interface TouchIconButtonProps {
  icon: React.ReactNode;
  onClick?: () => void;
  onLongPress?: () => void;
  disabled?: boolean;
  size?: 'sm' | 'md' | 'lg';
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost';
  className?: string;
  ariaLabel: string;
}

export const TouchIconButton: React.FC<TouchIconButtonProps> = ({
  icon,
  ariaLabel,
  ...props
}) => {
  return (
    <TouchButton
      {...props}
      className={`!p-0 aspect-square ${props.className || ''}`}
      aria-label={ariaLabel}
    >
      {icon}
    </TouchButton>
  );
};

/**
 * 觸摸友好卡片組件
 */
export interface TouchCardProps {
  children: React.ReactNode;
  onClick?: () => void;
  onLongPress?: () => void;
  className?: string;
  enableHover?: boolean;
  style?: React.CSSProperties;
}

export const TouchCard: React.FC<TouchCardProps> = ({
  children,
  onClick,
  onLongPress,
  className = '',
  enableHover = true,
  style
}) => {
  const [isPressed, setIsPressed] = useState(false);
  const longPressTimer = useRef<NodeJS.Timeout | null>(null);

  const handlePressStart = useCallback(() => {
    setIsPressed(true);
    
    if (onLongPress) {
      longPressTimer.current = setTimeout(() => {
        onLongPress();
      }, 500);
    }
  }, [onLongPress]);

  const handlePressEnd = useCallback(() => {
    setIsPressed(false);
    
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
    }
  }, []);

  const handleClick = useCallback(() => {
    onClick?.();
  }, [onClick]);

  useEffect(() => {
    return () => {
      if (longPressTimer.current) {
        clearTimeout(longPressTimer.current);
      }
    };
  }, []);

  const baseClasses = `
    relative rounded-lg transition-all duration-200 cursor-pointer
    gesture-area no-zoom touch-feedback
    ${enableHover ? 'hover:shadow-md' : ''}
    ${isPressed ? 'scale-98' : ''}
    ${className}
  `;

  return (
    <div
      className={baseClasses}
      style={style}
      onClick={handleClick}
      onMouseDown={handlePressStart}
      onMouseUp={handlePressEnd}
      onMouseLeave={handlePressEnd}
      onTouchStart={handlePressStart}
      onTouchEnd={handlePressEnd}
      onTouchCancel={handlePressEnd}
    >
      {children}
    </div>
  );
};

const TouchComponentsExports = {
  TouchButton,
  TouchIconButton,
  TouchCard
};

export default TouchComponentsExports;
</file>

<file path="src/components/WebVitalsProvider.tsx">
'use client';

import { useEffect } from 'react';
import { initWebVitalsMonitoring } from '@/utils/webVitalsMonitor';

/**
 * Web Vitals 監控組件
 * 在應用啟動時初始化性能監控
 */
export const WebVitalsProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  useEffect(() => {
    // 只在生產環境或明確啟用時運行
    const shouldMonitor = process.env.NODE_ENV === 'production' || 
                         process.env.NEXT_PUBLIC_ENABLE_WEB_VITALS === 'true';

    if (shouldMonitor) {
      const monitor = initWebVitalsMonitoring({
        enableConsoleLogging: process.env.NODE_ENV === 'development',
        enableAnalytics: process.env.NODE_ENV === 'production',
        analyticsEndpoint: process.env.NEXT_PUBLIC_ANALYTICS_ENDPOINT,
        thresholds: {
          LCP: 2500,
          INP: 200,
          CLS: 0.1,
          FCP: 1800,
          TTFB: 800
        }
      });

      // 在開發環境中，5秒後生成報告
      if (process.env.NODE_ENV === 'development') {
        setTimeout(() => {
          const report = monitor.generateReport();
          console.group('📊 Web Vitals 性能報告');
          console.log('Core Web Vitals:', report.coreWebVitals);
          console.log('其他指標:', report.otherMetrics);
          console.log('總結:', report.summary);
          console.groupEnd();
        }, 5000);
      }

      // 清理函數
      return () => {
        monitor.cleanup();
      };
    }
  }, []);

  return <>{children}</>;
};

export default WebVitalsProvider;
</file>

<file path="src/hooks/index.ts">
export { useDebateOrchestrator, useDebateControl } from './useDebateOrchestrator';
export { useContainerQuery, containerQueryUtils, ContainerQueryWrapper } from './useContainerQuery';

// 可以在這裡添加其他 hooks 的導出
// export { usePersonaManager } from './usePersonaManager';
// export { useSearchResults } from './useSearchResults';
// export { useConsensusCalculator } from './useConsensusCalculator';
</file>

<file path="src/services/debateOrchestrator.ts">
import { Persona, DebateContext, Statement, SourceReference, ConsensusData, MeetingRoom } from '@/types';
import { ApiService } from './apiService';

import { calculateConsensus } from '@/utils';

/**
 * 辯論狀態枚舉
 */
export enum DebateState {
  IDLE = 'idle',
  INITIALIZING = 'initializing',
  SEARCHING = 'searching',
  READY = 'ready',
  RUNNING = 'running',
  PAUSED = 'paused',
  COMPLETED = 'completed',
  ERROR = 'error',
}

/**
 * 辯論事件類型
 */
export interface DebateEvent {
  type: string;
  timestamp: number;
  data?: unknown;
}

/**
 * 辯論協調器 - 負責管理辯論流程、替身輪替和狀態同步
 */
export class DebateOrchestrator {
  private currentRoom: MeetingRoom | null = null;
  private state: DebateState = DebateState.IDLE;
  private currentRound: number = 0;
  private currentSpeakerIndex: number = 0;
  private searchResults: SourceReference[] = [];
  private eventHistory: DebateEvent[] = [];
  private pausedAt: number | null = null;
  private totalPausedTime: number = 0;
  private startTime: number | null = null;
  
  // 事件回調
  private onStateChange?: (state: DebateState, data?: unknown) => void;
  private onStatementAdded?: (statement: Statement) => void;
  private onConsensusUpdate?: (consensus: ConsensusData) => void;
  private onError?: (error: string) => void;
  private onRoundComplete?: (round: number, roundData: unknown) => void;
  private onDebateComplete?: (result: unknown) => void;
  private onProgress?: (progress: { current: number; total: number; percentage: number }) => void;

  constructor(options?: {
    onStateChange?: (state: DebateState, data?: unknown) => void;
    onStatementAdded?: (statement: Statement) => void;
    onConsensusUpdate?: (consensus: ConsensusData) => void;
    onError?: (error: string) => void;
    onRoundComplete?: (round: number, roundData: unknown) => void;
    onDebateComplete?: (result: unknown) => void;
    onProgress?: (progress: { current: number; total: number; percentage: number }) => void;
  }) {
    if (options) {
      this.onStateChange = options.onStateChange;
      this.onStatementAdded = options.onStatementAdded;
      this.onConsensusUpdate = options.onConsensusUpdate;
      this.onError = options.onError;
      this.onRoundComplete = options.onRoundComplete;
      this.onDebateComplete = options.onDebateComplete;
      this.onProgress = options.onProgress;
    }
  }

  /**
   * 初始化辯論
   */
  async initializeDebate(room: MeetingRoom): Promise<void> {
    try {
      this.setState(DebateState.INITIALIZING);
      this.addEvent('debate_initialize_start', { roomId: room.id, topic: room.topic });
      
      this.currentRoom = room;
      this.currentRound = 0;
      this.currentSpeakerIndex = 0;
      this.eventHistory = [];
      this.pausedAt = null;
      this.totalPausedTime = 0;
      this.startTime = null;
      
      // 檢查參與者
      if (!room.participants || room.participants.length < 2) {
        throw new Error('至少需要 2 個替身參與辯論');
      }

      // 驗證會議室設定
      this.validateRoomSettings(room);

      // 執行議題搜尋
      await this.performTopicSearch();
      
      this.setState(DebateState.READY);
      this.addEvent('debate_initialize_complete');
    } catch (error) {
      this.handleError('初始化辯論失敗', error);
    }
  }

  /**
   * 驗證會議室設定
   */
  private validateRoomSettings(room: MeetingRoom): void {
    if (room.settings.maxRounds < 1 || room.settings.maxRounds > 20) {
      throw new Error('最大回合數必須在 1-20 之間');
    }
    
    if (room.settings.consensusThreshold < 0.5 || room.settings.consensusThreshold > 1) {
      throw new Error('共識門檻必須在 0.5-1 之間');
    }
    
    // 自動修正超時時間而非拋出錯誤
    if (room.settings.timeoutPerRound && room.settings.timeoutPerRound < 30000) {
      console.warn(`超時時間 ${room.settings.timeoutPerRound}ms 少於最小值，已自動調整為 30 秒`);
      room.settings.timeoutPerRound = 30000;
    }
    
    // 確保有默認超時時間
    if (!room.settings.timeoutPerRound) {
      room.settings.timeoutPerRound = 300000; // 5分鐘默認值
    }
  }

  /**
   * 開始辯論
   */
  async startDebate(): Promise<void> {
    try {
      if (!this.currentRoom) {
        throw new Error('未初始化會議室');
      }

      if (this.state === DebateState.RUNNING) {
        throw new Error('辯論已在進行中');
      }

      if (this.state !== DebateState.READY) {
        throw new Error('辯論尚未準備就緒');
      }

      this.setState(DebateState.RUNNING);
      this.currentRound = 1;
      this.currentSpeakerIndex = 0;
      this.startTime = Date.now();
      
      this.addEvent('debate_start', { 
        participants: this.currentRoom.participants.map(p => p.name),
        maxRounds: this.currentRoom.settings.maxRounds 
      });
      
      // 開始第一輪辯論
      await this.runDebateRounds();
    } catch (error) {
      this.handleError('開始辯論失敗', error);
    }
  }

  /**
   * 暫停辯論
   */
  pauseDebate(): void {
    if (this.state !== DebateState.RUNNING) {
      throw new Error('只能暫停正在進行的辯論');
    }

    this.setState(DebateState.PAUSED);
    this.pausedAt = Date.now();
    this.addEvent('debate_pause', { 
      round: this.currentRound,
      speaker: this.getCurrentSpeaker()?.name 
    });
  }

  /**
   * 恢復辯論
   */
  async resumeDebate(): Promise<void> {
    if (!this.currentRoom) {
      throw new Error('未初始化會議室');
    }

    if (this.state !== DebateState.PAUSED) {
      throw new Error('只能恢復已暫停的辯論');
    }

    // 計算暫停時間
    if (this.pausedAt) {
      this.totalPausedTime += Date.now() - this.pausedAt;
      this.pausedAt = null;
    }

    this.setState(DebateState.RUNNING);
    this.addEvent('debate_resume', { 
      round: this.currentRound,
      totalPausedTime: this.totalPausedTime 
    });
    
    // 繼續辯論流程
    await this.runDebateRounds();
  }

  /**
   * 停止辯論
   */
  stopDebate(): void {
    if (this.state === DebateState.IDLE || this.state === DebateState.COMPLETED) {
      return;
    }

    this.setState(DebateState.COMPLETED);
    this.addEvent('debate_stop', { 
      reason: 'manual_stop',
      round: this.currentRound 
    });
    
    // 計算最終結果
    this.calculateFinalResult();
  }

  /**
   * 執行議題搜尋
   */
  private async performTopicSearch(): Promise<void> {
    try {
      if (!this.currentRoom) return;

      this.setState(DebateState.SEARCHING);
      this.addEvent('search_start', { topic: this.currentRoom.topic });
      
      const { searchResults } = await ApiService.searchTopicInformationWithRetry(
        this.currentRoom.topic,
        this.currentRoom.participants
      );
      
      this.searchResults = searchResults;
      this.addEvent('search_complete', { 
        resultsCount: searchResults.length,
        sources: searchResults.map(r => r.url) 
      });
    } catch (error) {
      this.handleError('搜尋議題資訊失敗', error);
    }
  }

  /**
   * 執行辯論回合
   */
  private async runDebateRounds(): Promise<void> {
    try {
      while (this.state === DebateState.RUNNING && this.currentRoom && this.currentRound <= this.currentRoom.settings.maxRounds) {
        // 更新進度
        this.updateProgress();
        
        await this.runSingleRound();
        
        // 檢查是否達成共識
        const consensus = this.calculateCurrentConsensus();
        this.onConsensusUpdate?.(consensus);
        
        if (consensus.consensusReached) {
          this.setState(DebateState.COMPLETED);
          this.addEvent('consensus_reached', { 
            round: this.currentRound,
            consensus 
          });
          
          this.onDebateComplete?.({
            reason: 'consensus',
            consensus,
            rounds: this.currentRound,
            duration: this.getDebateDuration(),
            eventHistory: this.eventHistory,
          });
          return;
        }
        
        // 完成當前回合
        const roundData = {
          round: this.currentRound,
          statements: this.currentRoom.statements.filter(s => s.round === this.currentRound),
          consensus: consensus,
        };
        
        this.onRoundComplete?.(this.currentRound, roundData);
        this.addEvent('round_complete', roundData);
        
        this.currentRound++;
        this.currentSpeakerIndex = 0;
      }
      
      // 達到最大回合數
      if (this.currentRound > (this.currentRoom?.settings.maxRounds || 0)) {
        this.setState(DebateState.COMPLETED);
        this.addEvent('max_rounds_reached', { 
          maxRounds: this.currentRoom?.settings.maxRounds 
        });
        this.calculateFinalResult();
      }
    } catch (error) {
      this.handleError('執行辯論回合失敗', error);
    }
  }

  /**
   * 執行單一回合
   */
  private async runSingleRound(): Promise<void> {
    if (!this.currentRoom || this.state !== DebateState.RUNNING) return;

    const participants = this.currentRoom.participants;
    this.addEvent('round_start', { 
      round: this.currentRound,
      participants: participants.map(p => p.name) 
    });
    
    for (let i = 0; i < participants.length && this.state === DebateState.RUNNING; i++) {
      this.currentSpeakerIndex = i;
      const persona = participants[i];
      
      // 檢查超時設定
      const timeout = this.currentRoom.settings.timeoutPerRound;
      if (timeout) {
        await Promise.race([
          this.generatePersonaStatement(persona),
          this.createTimeoutPromise(timeout, persona.name)
        ]);
      } else {
        await this.generatePersonaStatement(persona);
      }
      
      // 短暫延遲，模擬思考時間
      await this.delay(1000);
    }
  }

  /**
   * 創建超時 Promise
   */
  private createTimeoutPromise(timeout: number, personaName: string): Promise<void> {
    return new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`${personaName} 發言超時 (${timeout}ms)`));
      }, timeout);
    });
  }

  /**
   * 生成替身發言
   */
  private async generatePersonaStatement(persona: Persona): Promise<void> {
    try {
      if (!this.currentRoom) return;

      this.addEvent('generating_statement', { persona: persona.name });
      
      const context: DebateContext = {
        topic: this.currentRoom.topic,
        currentRound: this.currentRound,
        maxRounds: this.currentRoom.settings.maxRounds,
        previousStatements: this.currentRoom.statements,
        searchResults: [{ 
          query: this.currentRoom.topic,
          results: this.searchResults,
          timestamp: Date.now(),
          personaFocus: persona.ragFocus,
        }],
        activePersonas: this.currentRoom.participants,
        currentSpeaker: persona.id,
      };

      const response = await ApiService.generatePersonaResponseWithRetry(
        persona,
        context,
        this.searchResults
      );

      const statement: Statement = {
        id: this.generateId(),
        personaId: persona.id,
        personaName: persona.name,
        content: response.content,
        timestamp: Date.now(),
        round: this.currentRound,
        tendencyScore: response.tendencyScore,
        sources: response.sources,
        references: response.sources || [],
        tags: [],
        reasoning: response.reasoning,
      };

      // 添加發言到會議室
      this.currentRoom.statements.push(statement);
      this.onStatementAdded?.(statement);
      
      this.addEvent('statement_added', { statement });
    } catch (error) {
      this.handleError(`生成 ${persona.name} 的發言失敗`, error);
    }
  }

  /**
   * 計算當前共識
   */
  private calculateCurrentConsensus(): ConsensusData {
    if (!this.currentRoom) {
      return {
        supportRate: 0,
        opposeRate: 0,
        consensusReached: false,
        threshold: 0.7,
        finalScores: {},
      };
    }

    const scores = this.currentRoom.statements.map(s => s.tendencyScore);
    const consensus = calculateConsensus(scores);
    
    // 計算各替身的最終分數
    const finalScores: Record<string, number> = {};
    this.currentRoom.participants.forEach(persona => {
      const personaStatements = this.currentRoom!.statements.filter(s => s.personaId === persona.id);
      if (personaStatements.length > 0) {
        const latestStatement = personaStatements[personaStatements.length - 1];
        finalScores[persona.id] = latestStatement.tendencyScore;
      }
    });

    return {
      ...consensus,
      finalScores,
    };
  }

  /**
   * 完成辯論
   */
  private completeDebate(reason: string): void {
    this.setState(DebateState.COMPLETED);
    this.addEvent('debate_complete', { reason });
    
    const finalResult = this.calculateFinalResult();
    this.onDebateComplete?.({
      reason,
      result: finalResult,
      rounds: this.currentRound,
      duration: this.getDebateDuration(),
      eventHistory: this.eventHistory,
    });
  }

  /**
   * 計算最終結果
   */
  private calculateFinalResult(): unknown {
    const consensus = this.calculateCurrentConsensus();
    this.onConsensusUpdate?.(consensus);
    
    return {
      consensus,
      totalRounds: this.currentRound,
      duration: this.getDebateDuration(),
      participants: this.currentRoom?.participants.map(p => ({
        name: p.name,
        statements: this.currentRoom?.statements.filter(s => s.personaId === p.id).length || 0,
        averageTendency: this.calculateAverageTendency(p.id),
      })) || [],
      eventHistory: this.eventHistory,
    };
  }

  /**
   * 計算替身的平均傾向度
   */
  private calculateAverageTendency(personaId: string): number {
    if (!this.currentRoom) return 5;
    
    const statements = this.currentRoom.statements.filter(s => s.personaId === personaId);
    if (statements.length === 0) return 5;
    
    const totalTendency = statements.reduce((sum, s) => sum + s.tendencyScore, 0);
    return Math.round((totalTendency / statements.length) * 10) / 10;
  }

  /**
   * 設定狀態
   */
  private setState(newState: DebateState): void {
    const oldState = this.state;
    this.state = newState;
    this.onStateChange?.(newState, { 
      oldState, 
      newState, 
      room: this.currentRoom,
      timestamp: Date.now() 
    });
  }

  /**
   * 添加事件到歷史記錄
   */
  private addEvent(type: string, data?: unknown): void {
    const event: DebateEvent = {
      type,
      timestamp: Date.now(),
      data,
    };
    this.eventHistory.push(event);
    
    // 限制事件歷史記錄數量
    if (this.eventHistory.length > 1000) {
      this.eventHistory = this.eventHistory.slice(-500);
    }
  }

  /**
   * 更新進度
   */
  private updateProgress(): void {
    if (!this.currentRoom) return;
    
    const current = this.currentRound;
    const total = this.currentRoom.settings.maxRounds;
    const percentage = Math.round((current / total) * 100);
    
    this.onProgress?.({ current, total, percentage });
  }

  /**
   * 獲取當前發言者
   */
  private getCurrentSpeaker(): Persona | undefined {
    if (!this.currentRoom) return undefined;
    return this.currentRoom.participants[this.currentSpeakerIndex];
  }

  /**
   * 獲取辯論持續時間
   */
  private getDebateDuration(): number {
    if (!this.startTime) return 0;
    return Date.now() - this.startTime - this.totalPausedTime;
  }

  /**
   * 處理錯誤
   */
  private handleError(message: string, error: unknown): void {
    console.error(message, error);
    this.setState(DebateState.ERROR);
    this.addEvent('error', { 
      message, 
      error: error instanceof Error ? error.message : String(error),
      round: this.currentRound,
      speaker: this.getCurrentSpeaker()?.name 
    });
    this.onError?.(error instanceof Error ? error.message : message);
  }

  

  /**
   * 延遲函數
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * 生成唯一 ID
   */
  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }

  

  /**
   * 重置協調器
   */
  reset(): void {
    this.setState(DebateState.IDLE);
    this.currentRoom = null;
    this.currentRound = 0;
    this.currentSpeakerIndex = 0;
    this.searchResults = [];
    this.eventHistory = [];
    this.pausedAt = null;
    this.totalPausedTime = 0;
    this.startTime = null;
    this.addEvent('orchestrator_reset');
  }

  /**
   * 獲取當前狀態
   */
  getState(): {
    state: DebateState;
    currentRound: number;
    currentSpeaker: Persona | undefined;
    room: MeetingRoom | null;
    searchResults: SourceReference[];
    progress: { current: number; total: number; percentage: number } | null;
    duration: number;
    eventHistory: DebateEvent[];
  } {
    const progress = this.currentRoom ? {
      current: this.currentRound,
      total: this.currentRoom.settings.maxRounds,
      percentage: Math.round((this.currentRound / this.currentRoom.settings.maxRounds) * 100)
    } : null;

    return {
      state: this.state,
      currentRound: this.currentRound,
      currentSpeaker: this.getCurrentSpeaker(),
      room: this.currentRoom,
      searchResults: this.searchResults,
      progress,
      duration: this.getDebateDuration(),
      eventHistory: this.eventHistory,
    };
  }

  /**
   * 獲取事件歷史
   */
  getEventHistory(): DebateEvent[] {
    return [...this.eventHistory];
  }

  /**
   * 獲取統計資訊
   */
  getStatistics(): {
    totalEvents: number;
    totalDuration: number;
    averageRoundDuration: number;
    pauseCount: number;
    errorCount: number;
  } {
    const pauseEvents = this.eventHistory.filter(e => e.type === 'debate_pause');
    const errorEvents = this.eventHistory.filter(e => e.type === 'error');
    const roundEvents = this.eventHistory.filter(e => e.type === 'round_complete');
    
    const totalDuration = this.getDebateDuration();
    const averageRoundDuration = roundEvents.length > 0 ? totalDuration / roundEvents.length : 0;

    return {
      totalEvents: this.eventHistory.length,
      totalDuration,
      averageRoundDuration,
      pauseCount: pauseEvents.length,
      errorCount: errorEvents.length,
    };
  }
}

export default DebateOrchestrator;
</file>

<file path="src/services/personaEngine.ts">
import { Persona, DebateContext, SourceReference } from '@/types';

/**
 * 替身人格引擎 - 負責管理和執行虛擬替身的人格特質
 */
export class PersonaEngine {
  /**
   * 建構替身的完整提示詞
   */
  static buildPersonaPrompt(
    persona: Persona,
    context: DebateContext,
    searchResults?: SourceReference[]
  ): string {
    const { topic, currentRound, previousStatements, activePersonas } = context;
    
    // 基礎人格設定
    const basePrompt = `
【替身身份設定】
身份：${persona.identity}
核心原則：${persona.primeDirective}
辯論風格：${persona.toneStyle}
預設傾向：${persona.defaultBias}
搜尋重點：${persona.ragFocus.join(', ')}

【辯論議題】
${topic}

【當前狀況】
- 辯論回合：第 ${currentRound} 回合
- 參與者：${activePersonas.map(p => p.name).join(', ')}
`;

    // 搜尋結果
    const searchContext = searchResults && searchResults.length > 0 ? `
【最新查證資訊】
請務必利用以下從網路搜尋獲得的最新事實/數據來支持或反駁你的論點：
${searchResults.map((result, index) => 
  `${index + 1}. ${result.title}\n   ${result.snippet}\n   來源：${result.url}`
).join('\n')}
` : '';

    // 辯論歷史
    const debateHistory = previousStatements.length > 0 ? `
【辯論歷史】
${previousStatements.map(stmt => {
  const speaker = activePersonas.find(p => p.id === stmt.personaId)?.name || '未知';
  return `${speaker}：${stmt.content}（傾向度：${stmt.tendencyScore}/10）`;
}).join('\n')}
` : '';

    // 上次發言重點（用於強制性推理）
    const lastStatement = previousStatements[previousStatements.length - 1];
    const challengeTarget = lastStatement ? `
【上次發言重點】
${activePersonas.find(p => p.id === lastStatement.personaId)?.name || '前一位發言者'} 主張：「${lastStatement.content}」
` : '';

    // 強制性三層推理指令
    const reasoningInstructions = PersonaEngine.buildReasoningInstructions(!!lastStatement);

    return basePrompt + searchContext + debateHistory + challengeTarget + reasoningInstructions;
  }

  /**
   * 建構強制性三層推理指令
   */
  private static buildReasoningInstructions(hasLastStatement: boolean): string {
    const analysisTarget = hasLastStatement ? '上次發言重點' : '當前議題';
    
    return `
【Chain of Thought 強制性推理流程】
在回應之前，你必須按照以下三個步驟進行深度思考（這些思考過程不會顯示給用戶）：

步驟一：解析階段 (ANALYZE)
- 仔細分析${analysisTarget}中的核心論點和假設
- 識別其中最薄弱的環節或與你核心原則衝突的部分
- 找出可能存在的邏輯漏洞、數據缺陷或偏見
- 評估論點的可信度和完整性

步驟二：批判階段 (CRITIQUE)  
- 基於你的專業背景和核心原則，對識別出的薄弱點進行深度批判
- 結合最新搜尋資訊，尋找能夠反駁或支持你觀點的具體證據
- 構建基於事實和邏輯的反駁論點
- 確保你的批判是建設性的，而非單純的否定

步驟三：策略階段 (STRATEGY)
- 制定你的回應策略，確保能夠有效傳達你的觀點
- 決定如何組織你的論點以達到最大說服力
- 規劃如何將辯論引導向對你有利的方向
- 準備針鋒相對的質疑和反問

【強制性輸出結構】
你的最終發言必須嚴格遵循以下結構：

1. 直接引用與挑戰 (30-40字)：
   - 明確引用前一位發言者的具體論點
   - 直接表達你的質疑或挑戰
   - 範例：「我必須質疑 [發言者] 提到的 [具體論點]，因為這忽略了 [關鍵因素]」

2. 證據支持的反駁 (80-120字)：
   - 提出你的核心反駁觀點
   - 引用搜尋結果中的具體數據或事實
   - 展示你的專業分析
   - 範例：「根據最新資料顯示，[具體數據] 表明 [你的觀點]。從 [你的專業角度] 來看，[詳細分析]」

3. 戰略性質疑 (20-30字)：
   - 提出一個直接、尖銳的問題
   - 將辯論的主動權轉移到對方
   - 範例：「那麼，[發言者] 如何解釋 [具體矛盾] 這個問題？」

4. 傾向度評分：
   - 格式：「傾向度分數：[1-10]/10」
   - 必須基於你的分析給出合理的分數

【質量要求】
- 總字數控制在 150-200 字之間
- 必須體現你的專業身份和核心原則
- 論點必須有理有據，避免空洞的修辭
- 語氣要符合你的辯論風格設定
- 確保每個部分都針鋒相對，避免泛泛而談

現在請開始你的深度推理和發言：
`;
  }

  /**
   * 解析替身回應，提取傾向度分數和推理過程
   */
  static parsePersonaResponse(content: string): {
    cleanContent: string;
    tendencyScore: number;
    reasoning?: {
      analyze: string;
      critique: string;
      strategy: string;
    };
    structureValidation: {
      hasDirectChallenge: boolean;
      hasEvidenceSupport: boolean;
      hasStrategicQuestion: boolean;
      hasTendencyScore: boolean;
      wordCount: number;
      qualityScore: number;
    };
  } {
    // 提取傾向度分數
    const tendencyMatch = content.match(/傾向度分數[：:]\s*(\d+)\/10/);
    const tendencyScore = tendencyMatch ? parseInt(tendencyMatch[1]) : 5;
    
    // 移除傾向度分數文字
    const cleanContent = content.replace(/傾向度分數[：:]\s*\d+\/10/, '').trim();
    
    // 嘗試提取推理過程（如果有的話）
    const reasoning = PersonaEngine.extractReasoning(content);
    
    // 驗證回應結構
    const structureValidation = PersonaEngine.validateResponseStructure(content);
    
    return {
      cleanContent,
      tendencyScore,
      reasoning,
      structureValidation,
    };
  }

  /**
   * 提取推理過程（如果存在於回應中）
   */
  private static extractReasoning(content: string): {
    analyze: string;
    critique: string;
    strategy: string;
  } | undefined {
    // 嘗試從內容中提取推理標記
    const analyzeMatch = content.match(/(?:分析|解析|ANALYZE)[：:](.+?)(?=(?:批判|質疑|CRITIQUE)|$)/i);
    const critiqueMatch = content.match(/(?:批判|質疑|CRITIQUE)[：:](.+?)(?=(?:策略|戰略|STRATEGY)|$)/i);
    const strategyMatch = content.match(/(?:策略|戰略|STRATEGY)[：:](.+?)(?=傾向度分數|$)/i);
    
    if (analyzeMatch || critiqueMatch || strategyMatch) {
      return {
        analyze: analyzeMatch?.[1]?.trim() || '',
        critique: critiqueMatch?.[1]?.trim() || '',
        strategy: strategyMatch?.[1]?.trim() || '',
      };
    }
    
    return undefined;
  }

  /**
   * 驗證回應結構的完整性和質量
   */
  private static validateResponseStructure(content: string): {
    hasDirectChallenge: boolean;
    hasEvidenceSupport: boolean;
    hasStrategicQuestion: boolean;
    hasTendencyScore: boolean;
    wordCount: number;
    qualityScore: number;
  } {
    const wordCount = content.replace(/\s+/g, '').length;
    
    // 檢查直接挑戰
    const challengePatterns = [
      /我必須質疑/,
      /我要挑戰/,
      /我不同意/,
      /我反對/,
      /這忽略了/,
      /這存在問題/
    ];
    const hasDirectChallenge = challengePatterns.some(pattern => pattern.test(content));
    
    // 檢查證據支持
    const evidencePatterns = [
      /根據.*資料/,
      /數據顯示/,
      /研究表明/,
      /事實證明/,
      /從.*角度/,
      /專業分析/
    ];
    const hasEvidenceSupport = evidencePatterns.some(pattern => pattern.test(content));
    
    // 檢查戰略性質疑
    const questionPatterns = [
      /如何解釋/,
      /怎麼看待/,
      /是否考慮/,
      /\?$/,
      /？$/
    ];
    const hasStrategicQuestion = questionPatterns.some(pattern => pattern.test(content));
    
    // 檢查傾向度分數
    const hasTendencyScore = /傾向度分數[：:]\s*\d+\/10/.test(content);
    
    // 計算質量分數
    let qualityScore = 0;
    if (hasDirectChallenge) qualityScore += 25;
    if (hasEvidenceSupport) qualityScore += 25;
    if (hasStrategicQuestion) qualityScore += 25;
    if (hasTendencyScore) qualityScore += 15;
    
    // 字數評分
    if (wordCount >= 150 && wordCount <= 250) {
      qualityScore += 10;
    } else if (wordCount >= 100 && wordCount < 150) {
      qualityScore += 5;
    }
    
    return {
      hasDirectChallenge,
      hasEvidenceSupport,
      hasStrategicQuestion,
      hasTendencyScore,
      wordCount,
      qualityScore,
    };
  }

  /**
   * 生成推理質量報告
   */
  static generateReasoningReport(
    persona: Persona,
    response: ReturnType<typeof PersonaEngine.parsePersonaResponse>
  ): {
    overallQuality: 'excellent' | 'good' | 'fair' | 'poor';
    suggestions: string[];
    strengths: string[];
  } {
    const { structureValidation } = response;
    const { qualityScore } = structureValidation;
    
    let overallQuality: 'excellent' | 'good' | 'fair' | 'poor';
    if (qualityScore >= 90) overallQuality = 'excellent';
    else if (qualityScore >= 70) overallQuality = 'good';
    else if (qualityScore >= 50) overallQuality = 'fair';
    else overallQuality = 'poor';
    
    const suggestions: string[] = [];
    const strengths: string[] = [];
    
    // 分析優點
    if (structureValidation.hasDirectChallenge) {
      strengths.push('成功進行了直接挑戰');
    }
    if (structureValidation.hasEvidenceSupport) {
      strengths.push('提供了證據支持');
    }
    if (structureValidation.hasStrategicQuestion) {
      strengths.push('包含了戰略性質疑');
    }
    
    // 分析改進建議
    if (!structureValidation.hasDirectChallenge) {
      suggestions.push('需要更直接地挑戰對方論點');
    }
    if (!structureValidation.hasEvidenceSupport) {
      suggestions.push('應該引用更多具體數據或事實');
    }
    if (!structureValidation.hasStrategicQuestion) {
      suggestions.push('缺少戰略性的反問或質疑');
    }
    if (structureValidation.wordCount < 100) {
      suggestions.push('回應內容過於簡短，需要更詳細的論述');
    }
    if (structureValidation.wordCount > 300) {
      suggestions.push('回應內容過長，需要更簡潔的表達');
    }
    
    return {
      overallQuality,
      suggestions,
      strengths,
    };
  }

  /**
   * 驗證替身配置的完整性
   */
  static validatePersona(persona: Partial<Persona>): string[] {
    const errors: string[] = [];
    
    if (!persona.name || persona.name.trim().length === 0) {
      errors.push('替身名稱不能為空');
    }
    
    if (!persona.identity || persona.identity.trim().length === 0) {
      errors.push('身份描述不能為空');
    }
    
    if (!persona.primeDirective || persona.primeDirective.trim().length === 0) {
      errors.push('核心原則不能為空');
    }
    
    if (!persona.toneStyle || persona.toneStyle.trim().length === 0) {
      errors.push('辯論風格不能為空');
    }
    
    if (typeof persona.temperature !== 'number' || persona.temperature < 0.1 || persona.temperature > 1.0) {
      errors.push('溫度參數必須在 0.1 到 1.0 之間');
    }
    
    if (!Array.isArray(persona.ragFocus) || persona.ragFocus.length === 0) {
      errors.push('搜尋重點至少需要一個項目');
    }
    
    return errors;
  }

  /**
   * 生成替身的搜尋關鍵詞
   */
  static generateSearchKeywords(persona: Persona, topic: string): string[] {
    const keywords = [topic];
    
    // 添加替身的搜尋重點
    keywords.push(...persona.ragFocus);
    
    // 根據身份添加相關關鍵詞
    if (persona.identity?.includes('CEO') || persona.identity?.includes('執行長')) {
      keywords.push('企業戰略', '商業模式', '市場競爭');
    }
    
    if (persona.identity?.includes('CTO') || persona.identity?.includes('技術長')) {
      keywords.push('技術趨勢', '創新技術', '技術架構');
    }
    
    if (persona.identity?.includes('CFO') || persona.identity?.includes('財務長')) {
      keywords.push('財務分析', '投資回報', '成本效益');
    }
    
    if (persona.identity?.includes('環保') || persona.identity?.includes('環境')) {
      keywords.push('環境影響', '可持續發展', '綠色技術');
    }
    
    if (persona.identity?.includes('法律') || persona.identity?.includes('律師')) {
      keywords.push('法律法規', '合規要求', '法律風險');
    }
    
    if (persona.identity?.includes('市場') || persona.identity?.includes('分析師')) {
      keywords.push('市場調研', '消費者行為', '市場趨勢');
    }
    
    // 去重並限制數量
    return [...new Set(keywords)].slice(0, 8);
  }

  /**
   * 計算替身之間的相似度
   */
  static calculatePersonaSimilarity(persona1: Persona, persona2: Persona): number {
    let similarity = 0;
    
    // 比較搜尋重點的重疊度
    const focus1 = new Set(persona1.ragFocus);
    const focus2 = new Set(persona2.ragFocus);
    const intersection = new Set([...focus1].filter(x => focus2.has(x)));
    const union = new Set([...focus1, ...focus2]);
    
    const focussimilarity = intersection.size / union.size;
    similarity += focussimilarity * 0.4;
    
    // 比較溫度參數的相似度
    const tempSimilarity = 1 - Math.abs(persona1.temperature - persona2.temperature);
    similarity += tempSimilarity * 0.2;
    
    // 比較身份描述的相似度（簡單的關鍵詞匹配）
    const identity1Words = (persona1.identity || '').toLowerCase().split(/\s+/);
    const identity2Words = (persona2.identity || '').toLowerCase().split(/\s+/);
    const identityIntersection = identity1Words.filter(word => identity2Words.includes(word));
    const identitySimilarity = identityIntersection.length / Math.max(identity1Words.length, identity2Words.length);
    similarity += identitySimilarity * 0.4;
    
    return Math.min(similarity, 1);
  }

  /**
   * 為替身生成建議的顏色
   */
  static suggestPersonaColor(persona: Persona): string {
    const identity = (persona.identity || '').toLowerCase();
    
    if (identity.includes('ceo') || identity.includes('執行長')) {
      return '#1f2937'; // 深灰色 - 權威
    }
    
    if (identity.includes('cto') || identity.includes('技術')) {
      return '#059669'; // 綠色 - 創新
    }
    
    if (identity.includes('cfo') || identity.includes('財務')) {
      return '#dc2626'; // 紅色 - 謹慎
    }
    
    if (identity.includes('環保') || identity.includes('環境')) {
      return '#16a34a'; // 綠色 - 環保
    }
    
    if (identity.includes('法律') || identity.includes('律師')) {
      return '#7c3aed'; // 紫色 - 嚴謹
    }
    
    if (identity.includes('市場') || identity.includes('分析')) {
      return '#ea580c'; // 橙色 - 分析
    }
    
    // 預設顏色
    const colors = ['#0891b2', '#be123c', '#166534', '#7c2d12', '#581c87', '#92400e', '#1e40af'];
    return colors[Math.floor(Math.random() * colors.length)];
  }
}

export default PersonaEngine;
</file>

<file path="src/services/topicService.ts">
interface TopicGenerationRequest {
  firstStatement: string;
  context?: string;
}

export async function generateTopicFromStatement(
  request: TopicGenerationRequest
): Promise<string> {
  try {
    const response = await fetch('/api/generate-topic', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data.topic || '討論議題';
  } catch (error) {
    console.error('生成主題失敗:', error);
    return '討論議題'; // 返回默認主題
  }
}

export async function analyzeStatementForTopic(statement: string): Promise<string> {
  // 簡單的本地分析邏輯，提取關鍵詞作為主題
  const keywords = extractKeywords(statement);
  
  if (keywords.length > 0) {
    return keywords.slice(0, 3).join('、') + '相關討論';
  }
  
  return '討論議題';
}

function extractKeywords(text: string): string[] {
  // 移除標點符號和停用詞
  const stopWords = ['的', '是', '在', '有', '和', '與', '或', '但', '然而', '因此', '所以', '如果', '那麼', '這個', '那個', '我們', '你們', '他們'];
  
  const words = text
    .replace(/[^\u4e00-\u9fa5a-zA-Z0-9\s]/g, '') // 保留中文、英文、數字
    .split(/\s+/)
    .filter(word => word.length > 1 && !stopWords.includes(word));
  
  // 簡單的詞頻統計
  const wordCount: Record<string, number> = {};
  words.forEach(word => {
    wordCount[word] = (wordCount[word] || 0) + 1;
  });
  
  // 按頻率排序並返回前幾個關鍵詞
  return Object.entries(wordCount)
    .sort(([, a], [, b]) => b - a)
    .slice(0, 5)
    .map(([word]) => word);
}
</file>

<file path="src/stores/index.ts">
import { useMeetingRoomStore } from './enhancedMeetingRoomStore';
import { useDebateHistoryStore, useNotificationStore } from './additionalStores';

// 重新導出所有 stores
export { useMeetingRoomStore, useDebateHistoryStore, useNotificationStore };

// 導出原始的 store（向後兼容）
export { useMeetingRoomStore as useMeetingRoomStoreOriginal } from './meetingRoomStore';

// Store 組合 hooks
export const useStores = () => ({
  meetingRoom: useMeetingRoomStore(),
  debateHistory: useDebateHistoryStore(),
  notification: useNotificationStore(),
});

// 選擇器 hooks
export const useMeetingRoomSelectors = () => {
  const store = useMeetingRoomStore();
  
  return {
    // 基本選擇器
    currentRoom: store.currentRoom,
    rooms: store.rooms,
    availablePersonas: store.availablePersonas,
    debateStatus: store.debateStatus,
    isLoading: store.isLoading,
    error: store.error,
    
    // 計算選擇器
    activePersonas: store.availablePersonas.filter(p => p.isActive),
    inactivePersonas: store.availablePersonas.filter(p => !p.isActive),
    currentStatements: store.currentRoom?.statements || [],
    latestStatement: store.currentRoom?.statements[store.currentRoom.statements.length - 1],
    consensusData: store.currentRoom?.consensus,
    isDebateActive: ['preparing', 'searching', 'debating'].includes(store.debateStatus),
    canStartDebate: store.availablePersonas.filter(p => p.isActive).length >= 2 && store.currentRoom !== null,
    
    // 統計選擇器
    totalRooms: store.rooms.length,
    totalPersonas: store.availablePersonas.length,
    activePersonaCount: store.availablePersonas.filter(p => p.isActive).length,
    completedRooms: store.rooms.filter(r => r.status === 'completed').length,
  };
};

export const useDebateHistorySelectors = () => {
  const store = useDebateHistoryStore();
  
  return {
    // 基本選擇器
    debateHistory: store.debateHistory,
    analytics: store.analytics,
    
    // 計算選擇器
    recentDebates: store.debateHistory.slice(0, 10),
    totalDebates: store.analytics.totalDebates,
    averageRounds: store.analytics.averageRounds,
    consensusRate: store.analytics.consensusRate,
    
    // 功能選擇器
    getDebatesByTopic: store.getDebatesByTopic,
    getDebatesByPersona: store.getDebatesByPersona,
  };
};

export const useNotificationSelectors = () => {
  const store = useNotificationStore();
  
  return {
    // 基本選擇器
    notifications: store.notifications,
    unreadCount: store.getUnreadCount(),
    
    // 計算選擇器
    recentNotifications: store.notifications.slice(0, 5),
    unreadNotifications: store.notifications.filter(n => !n.read),
    errorNotifications: store.notifications.filter(n => n.type === 'error'),
    
    // 功能選擇器
    hasUnread: store.getUnreadCount() > 0,
    hasErrors: store.notifications.some(n => n.type === 'error' && !n.read),
  };
};

// 組合 actions
export const useActions = () => {
  const meetingRoom = useMeetingRoomStore();
  const debateHistory = useDebateHistoryStore();
  const notification = useNotificationStore();
  
  return {
    // 會議室 actions
    createRoom: meetingRoom.createRoom,
    selectRoom: meetingRoom.selectRoom,
    updateRoom: meetingRoom.updateRoom,
    deleteRoom: meetingRoom.deleteRoom,
    
    // 替身 actions
    addPersona: meetingRoom.addPersona,
    updatePersona: meetingRoom.updatePersona,
    deletePersona: meetingRoom.deletePersona,
    togglePersonaActive: meetingRoom.togglePersonaActive,
    duplicatePersona: meetingRoom.duplicatePersona,
    
    // 辯論 actions
    startDebate: meetingRoom.startDebate,
    pauseDebate: meetingRoom.pauseDebate,
    resumeDebate: meetingRoom.resumeDebate,
    stopDebate: meetingRoom.stopDebate,
    resetDebate: meetingRoom.resetDebate,
    
    // 發言 actions
    addStatement: meetingRoom.addStatement,
    updateStatement: meetingRoom.updateStatement,
    deleteStatement: meetingRoom.deleteStatement,
    
    // 歷史 actions
    addDebateRecord: debateHistory.addDebateRecord,
    clearHistory: debateHistory.clearHistory,
    exportHistory: debateHistory.exportHistory,
    importHistory: debateHistory.importHistory,
    
    // 通知 actions
    addNotification: notification.addNotification,
    markAsRead: notification.markAsRead,
    removeNotification: notification.removeNotification,
    clearAllNotifications: notification.clearAll,
    
    // 狀態 actions
    setLoading: meetingRoom.setLoading,
    setError: meetingRoom.setError,
    setDebateStatus: meetingRoom.setDebateStatus,
    setCurrentSpeaker: meetingRoom.setCurrentSpeaker,
    
    // 偏好 actions
    updateUserPreferences: meetingRoom.updateUserPreferences,
    enableAutoSave: meetingRoom.enableAutoSave,
    disableAutoSave: meetingRoom.disableAutoSave,
    
    // 重置 actions
    reset: meetingRoom.reset,
    resetAll: meetingRoom.resetAll,
  };
};

// 便利 hooks
export const useCurrentRoom = () => {
  return useMeetingRoomStore((state) => state.currentRoom);
};

export const useActivePersonas = () => {
  return useMeetingRoomStore((state) => state.availablePersonas.filter(p => p.isActive));
};

export const useDebateStatus = () => {
  return useMeetingRoomStore((state) => state.debateStatus);
};

export const useIsLoading = () => {
  return useMeetingRoomStore((state) => state.isLoading);
};

export const useError = () => {
  return useMeetingRoomStore((state) => state.error);
};

export const useUnreadNotifications = () => {
  return useNotificationStore((state) => state.notifications.filter(n => !n.read));
};

const storeExports = {
  useMeetingRoomStore,
  useDebateHistoryStore,
  useNotificationStore,
  useStores,
  useMeetingRoomSelectors,
  useDebateHistorySelectors,
  useNotificationSelectors,
  useActions,
  useCurrentRoom,
  useActivePersonas,
  useDebateStatus,
  useIsLoading,
  useError,
  useUnreadNotifications,
};

export default storeExports;
</file>

<file path="src/utils/index.ts">
// Utility functions for the Virtual Meeting Room system

/**
 * 生成唯一 ID
 */
export const generateId = (): string => {
  return Math.random().toString(36).substr(2, 9);
};

/**
 * 格式化時間戳
 */
export const formatTimestamp = (timestamp: number): string => {
  const date = new Date(timestamp);
  return date.toLocaleString('zh-TW', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  });
};

/**
 * 格式化相對時間
 */
export const formatRelativeTime = (timestamp: number): string => {
  const now = Date.now();
  const diff = now - timestamp;
  
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  
  if (days > 0) return `${days} 天前`;
  if (hours > 0) return `${hours} 小時前`;
  if (minutes > 0) return `${minutes} 分鐘前`;
  return `${seconds} 秒前`;
};

/**
 * 計算共識度
 */
/**
 * 進階共識計算工具
 */
export const consensusUtils: {
  calculateBasicConsensus: (scores: number[]) => {
    supportRate: number;
    opposeRate: number;
    consensusReached: boolean;
    threshold: number;
    finalScores: Record<string, number>;
  };
  calculateWeightedConsensus: (scores: number[], weights?: number[]) => {
    weightedSupportRate: number;
    weightedOpposeRate: number;
    consensusReached: boolean;
    threshold: number;
    weightedScores: Record<string, number>;
    confidenceLevel: number;
  };
  calculateDynamicConsensus: (historicalScores: number[][], timeWeights?: number[]) => {
    trendDirection: 'converging' | 'diverging' | 'stable';
    convergenceRate: number;
    predictedConsensus: number;
    stabilityIndex: number;
  };
  generateConsensusReport: (scores: number[], weights?: number[], historicalScores?: number[][]) => {
    basic: ReturnType<typeof consensusUtils.calculateBasicConsensus>;
    weighted: ReturnType<typeof consensusUtils.calculateWeightedConsensus>;
    dynamic: ReturnType<typeof consensusUtils.calculateDynamicConsensus>;
    summary: {
      overallConsensus: 'strong' | 'moderate' | 'weak' | 'none';
      recommendation: string;
      nextSteps: string[];
    };
  };
} = {
  /**
   * 計算基本共識度
   */
  calculateBasicConsensus: (scores: number[]): {
    supportRate: number;
    opposeRate: number;
    consensusReached: boolean;
    threshold: number;
    finalScores: Record<string, number>;
  } => {
    if (scores.length === 0) {
      return {
        supportRate: 0,
        opposeRate: 0,
        consensusReached: false,
        threshold: 0.7,
        finalScores: {},
      };
    }
    
    const totalScores = scores.reduce((sum, score) => sum + score, 0);
    const maxPossibleScore = scores.length * 10;
    const minPossibleScore = scores.length * 1;
    
    // 計算支持度和反對度
    const supportRate = totalScores / maxPossibleScore;
    const opposeRate = (maxPossibleScore - totalScores) / (maxPossibleScore - minPossibleScore);
    
    const threshold = 0.7;
    const consensusReached = supportRate > threshold || opposeRate > threshold;
    
    // 生成最終分數記錄
    const finalScores: Record<string, number> = {};
    scores.forEach((score, index) => {
      finalScores[`persona_${index}`] = score;
    });
    
    return {
      supportRate,
      opposeRate,
      consensusReached,
      threshold,
      finalScores,
    };
  },

  /**
   * 計算加權共識度（考慮替身的專業權重）
   */
  calculateWeightedConsensus: (
    scores: number[], 
    weights: number[] = []
  ): {
    weightedSupportRate: number;
    weightedOpposeRate: number;
    consensusReached: boolean;
    threshold: number;
    weightedScores: Record<string, number>;
    confidenceLevel: number;
  } => {
    if (scores.length === 0) {
      return {
        weightedSupportRate: 0,
        weightedOpposeRate: 0,
        consensusReached: false,
        threshold: 0.7,
        weightedScores: {},
        confidenceLevel: 0,
      };
    }

    // 如果沒有提供權重，則使用均等權重
    const normalizedWeights = weights.length === scores.length 
      ? weights.map(w => w / weights.reduce((sum, weight) => sum + weight, 0))
      : scores.map(() => 1 / scores.length);

    // 計算加權分數
    const weightedTotal = scores.reduce((sum, score, index) => 
      sum + (score * normalizedWeights[index]), 0
    );
    
    const maxWeightedScore = normalizedWeights.reduce((sum, weight) => sum + (weight * 10), 0);
    const minWeightedScore = normalizedWeights.reduce((sum, weight) => sum + (weight * 1), 0);

    const weightedSupportRate = weightedTotal / maxWeightedScore;
    const weightedOpposeRate = (maxWeightedScore - weightedTotal) / (maxWeightedScore - minWeightedScore);

    // 計算信心水準（基於分數的一致性）
    const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const variance = scores.reduce((sum, score) => sum + Math.pow(score - avgScore, 2), 0) / scores.length;
    const confidenceLevel = Math.max(0, 1 - (variance / 25)); // 25 是最大可能方差

    const threshold = 0.7;
    const consensusReached = weightedSupportRate > threshold || weightedOpposeRate > threshold;

    // 生成加權分數記錄
    const weightedScores: Record<string, number> = {};
    scores.forEach((score, index) => {
      weightedScores[`persona_${index}`] = score * normalizedWeights[index];
    });

    return {
      weightedSupportRate,
      weightedOpposeRate,
      consensusReached,
      threshold,
      weightedScores,
      confidenceLevel,
    };
  },

  /**
   * 計算動態共識度（考慮時間變化）
   */
  calculateDynamicConsensus: (
    historicalScores: number[][], 
    // _timeWeights: number[] = []
  ): {
    trendDirection: 'converging' | 'diverging' | 'stable';
    convergenceRate: number;
    predictedConsensus: number;
    stabilityIndex: number;
  } => {
    if (historicalScores.length < 2) {
      return {
        trendDirection: 'stable',
        convergenceRate: 0,
        predictedConsensus: 5,
        stabilityIndex: 0,
      };
    }

    // 計算每輪的方差
    const variances = historicalScores.map(scores => {
      const avg = scores.reduce((sum, score) => sum + score, 0) / scores.length;
      return scores.reduce((sum, score) => sum + Math.pow(score - avg, 2), 0) / scores.length;
    });

    // 判斷趨勢方向
    const recentVariances = variances.slice(-3);
    const isConverging = recentVariances.length >= 2 && 
      recentVariances[recentVariances.length - 1] < recentVariances[0];
    const isDiverging = recentVariances.length >= 2 && 
      recentVariances[recentVariances.length - 1] > recentVariances[0];

    let trendDirection: 'converging' | 'diverging' | 'stable' = 'stable';
    if (isConverging) trendDirection = 'converging';
    else if (isDiverging) trendDirection = 'diverging';

    // 計算收斂率
    const convergenceRate = recentVariances.length >= 2 
      ? (recentVariances[0] - recentVariances[recentVariances.length - 1]) / recentVariances[0]
      : 0;

    // 預測下一輪共識
    const lastRoundAvg = historicalScores[historicalScores.length - 1]
      .reduce((sum, score) => sum + score, 0) / historicalScores[historicalScores.length - 1].length;
    const predictedConsensus = Math.max(1, Math.min(10, lastRoundAvg + (convergenceRate * 2)));

    // 計算穩定性指數
    const stabilityIndex = Math.max(0, 1 - (variances[variances.length - 1] / 25));

    return {
      trendDirection,
      convergenceRate,
      predictedConsensus,
      stabilityIndex,
    };
  },

  /**
   * 生成共識報告
   */
  generateConsensusReport: (
    scores: number[],
    weights: number[] = [],
    historicalScores: number[][] = []
  ): {
    basic: ReturnType<typeof consensusUtils.calculateBasicConsensus>;
    weighted: ReturnType<typeof consensusUtils.calculateWeightedConsensus>;
    dynamic: ReturnType<typeof consensusUtils.calculateDynamicConsensus>;
    summary: {
      overallConsensus: 'strong' | 'moderate' | 'weak' | 'none';
      recommendation: string;
      nextSteps: string[];
    };
  } => {
    const basic = consensusUtils.calculateBasicConsensus(scores);
    const weighted = consensusUtils.calculateWeightedConsensus(scores, weights);
    const dynamic = consensusUtils.calculateDynamicConsensus(historicalScores);

    // 綜合評估
    let overallConsensus: 'strong' | 'moderate' | 'weak' | 'none' = 'none';
    if (basic.consensusReached && weighted.consensusReached && weighted.confidenceLevel > 0.8) {
      overallConsensus = 'strong';
    } else if (basic.consensusReached || weighted.consensusReached) {
      overallConsensus = 'moderate';
    } else if (Math.max(basic.supportRate, basic.opposeRate) > 0.5) {
      overallConsensus = 'weak';
    }

    // 生成建議
    let recommendation = '';
    const nextSteps: string[] = [];

    switch (overallConsensus) {
      case 'strong':
        recommendation = '已達成強烈共識，可以結束辯論並採取行動。';
        nextSteps.push('總結辯論要點', '制定實施計劃', '分配後續任務');
        break;
      case 'moderate':
        recommendation = '達成中等程度共識，建議再進行 1-2 輪辯論以鞏固觀點。';
        nextSteps.push('針對分歧點深入討論', '尋求更多證據支持', '嘗試找到折衷方案');
        break;
      case 'weak':
        recommendation = '共識較弱，需要更多輪辯論來縮小分歧。';
        nextSteps.push('重新檢視核心議題', '引入新的觀點或專家', '調整辯論策略');
        break;
      case 'none':
        recommendation = '尚未形成共識，建議重新定義議題或調整參與者。';
        nextSteps.push('重新審視議題定義', '考慮增加或更換參與者', '調整辯論規則');
        break;
    }

    return {
      basic,
      weighted,
      dynamic,
      summary: {
        overallConsensus,
        recommendation,
        nextSteps,
      },
    };
  },
};

// 向後兼容
export const calculateConsensus = consensusUtils.calculateBasicConsensus;

/**
 * 驗證替身配置
 */
export const validatePersona = (persona: unknown): string[] => {
  const errors: string[] = [];
  
  // Type guard to check if persona is an object
  if (!persona || typeof persona !== 'object') {
    errors.push('替身數據格式無效');
    return errors;
  }
  
  const p = persona as Record<string, unknown>;
  
  if (!p.name || typeof p.name !== 'string' || p.name.trim().length === 0) {
    errors.push('替身名稱不能為空');
  }
  
  if (!p.identity || typeof p.identity !== 'string' || p.identity.trim().length === 0) {
    errors.push('身份描述不能為空');
  }
  
  if (!p.primeDirective || typeof p.primeDirective !== 'string' || p.primeDirective.trim().length === 0) {
    errors.push('核心原則不能為空');
  }
  
  if (!p.toneStyle || typeof p.toneStyle !== 'string' || p.toneStyle.trim().length === 0) {
    errors.push('辯論風格不能為空');
  }
  
  if (typeof p.temperature !== 'number' || p.temperature < 0.1 || p.temperature > 1.0) {
    errors.push('溫度參數必須在 0.1 到 1.0 之間');
  }
  
  if (!Array.isArray(p.ragFocus) || p.ragFocus.length === 0) {
    errors.push('搜尋重點至少需要一個項目');
  }
  
  return errors;
};

/**
 * 深度複製對象
 */
export const deepClone = <T>(obj: T): T => {
  if (obj === null || typeof obj !== 'object') return obj;
  if (obj instanceof Date) return new Date(obj.getTime()) as unknown as T;
  if (obj instanceof Array) return obj.map(item => deepClone(item)) as unknown as T;
  if (typeof obj === 'object') {
    const clonedObj = {} as T;
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        clonedObj[key] = deepClone(obj[key]);
      }
    }
    return clonedObj;
  }
  return obj;
};

/**
 * 防抖函數
 */
export const debounce = <T extends (...args: unknown[]) => unknown>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout;
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
};

/**
 * 節流函數
 */
export const throttle = <T extends (...args: unknown[]) => unknown>(
  func: T,
  limit: number
): ((...args: Parameters<T>) => void) => {
  let inThrottle: boolean;
  
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
};

/**
 * 本地儲存工具
 */
export const storage = {
  get: <T>(key: string, defaultValue?: T): T | null => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue || null;
    } catch (error) {
      console.error('Error reading from localStorage:', error);
      return defaultValue || null;
    }
  },
  
  set: (key: string, value: unknown): boolean => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (error) {
      console.error('Error writing to localStorage:', error);
      return false;
    }
  },
  
  remove: (key: string): boolean => {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (error) {
      console.error('Error removing from localStorage:', error);
      return false;
    }
  },
  
  clear: (): boolean => {
    try {
      localStorage.clear();
      return true;
    } catch (error) {
      console.error('Error clearing localStorage:', error);
      return false;
    }
  },
};

/**
 * 顏色工具
 */
export const colorUtils = {
  /**
   * 生成隨機顏色
   */
  generateRandomColor: (): string => {
    const colors = [
      '#1f2937', '#dc2626', '#059669', '#7c3aed',
      '#ea580c', '#0891b2', '#be123c', '#166534',
      '#7c2d12', '#581c87', '#92400e', '#1e40af',
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  },
  
  /**
   * 將十六進制顏色轉換為 RGB
   */
  hexToRgb: (hex: string): { r: number; g: number; b: number } | null => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16),
    } : null;
  },
  
  /**
   * 獲取顏色的亮度
   */
  getLuminance: (hex: string): number => {
    const rgb = colorUtils.hexToRgb(hex);
    if (!rgb) return 0;
    
    const { r, g, b } = rgb;
    return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  },
  
  /**
   * 判斷是否為深色
   */
  isDark: (hex: string): boolean => {
    return colorUtils.getLuminance(hex) < 0.5;
  },
};

/**
 * 文字工具
 */
export const textUtils = {
  /**
   * 截斷文字
   */
  truncate: (text: string, maxLength: number): string => {
    if (text.length <= maxLength) return text;
    return text.slice(0, maxLength) + '...';
  },
  
  /**
   * 高亮關鍵詞
   */
  highlightKeywords: (text: string, keywords: string[]): string => {
    let highlightedText = text;
    keywords.forEach(keyword => {
      const regex = new RegExp(`(${keyword})`, 'gi');
      highlightedText = highlightedText.replace(regex, '<mark>$1</mark>');
    });
    return highlightedText;
  },
  
  /**
   * 移除 HTML 標籤
   */
  stripHtml: (html: string): string => {
    return html.replace(/<[^>]*>/g, '');
  },
  
  /**
   * 計算閱讀時間（以分鐘為單位）
   */
  calculateReadingTime: (text: string, wordsPerMinute: number = 200): number => {
    const words = text.trim().split(/\s+/).length;
    return Math.ceil(words / wordsPerMinute);
  },
};

/**
 * 錯誤處理工具
 */
export const errorUtils = {
  /**
   * 格式化錯誤訊息
   */
  formatError: (error: unknown): string => {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === 'string') {
      return error;
    }
    return '發生未知錯誤';
  },
  
  /**
   * 記錄錯誤
   */
  logError: (error: unknown, context?: string): void => {
    const errorMessage = errorUtils.formatError(error);
    const logMessage = context ? `[${context}] ${errorMessage}` : errorMessage;
    console.error(logMessage, error);
  },
};

/**
 * 從發言內容提取主題
 */
export const extractTopicFromContent = (content: string): string => {
  if (!content || content.trim().length === 0) {
    return '';
  }

  // 移除標點符號和多餘空格
  const cleanContent = content.replace(/[。！？，、；：""''（）【】《》]/g, ' ').trim();
  
  // 分割成詞語
  const words = cleanContent.split(/\s+/).filter(word => word.length > 1);
  
  // 如果內容太短，直接返回前30個字符
  if (words.length < 3) {
    return content.length > 30 ? content.substring(0, 30) + '...' : content;
  }
  
  // 尋找關鍵詞模式
  const keywordPatterns = [
    /關於(.{2,20})/,
    /討論(.{2,20})/,
    /針對(.{2,20})/,
    /對於(.{2,20})/,
    /我認為(.{2,20})/,
    /我們應該(.{2,20})/,
    /建議(.{2,20})/,
    /提議(.{2,20})/,
  ];
  
  // 嘗試匹配關鍵詞模式
  for (const pattern of keywordPatterns) {
    const match = content.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }
  
  // 如果沒有匹配到模式，取前幾個有意義的詞語
  const meaningfulWords = words.filter(word => 
    word.length >= 2 && 
    !['我們', '這個', '那個', '可以', '應該', '需要', '因為', '所以', '但是', '然而'].includes(word)
  );
  
  if (meaningfulWords.length >= 2) {
    const topic = meaningfulWords.slice(0, 3).join('');
    return topic.length > 20 ? topic.substring(0, 20) + '...' : topic;
  }
  
  // 最後備選：取前20個字符
  return content.length > 20 ? content.substring(0, 20) + '...' : content;
};

/**
 * 驗證工具
 */
export const validationUtils = {
  /**
   * 驗證電子郵件
   */
  isValidEmail: (email: string): boolean => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  },
  
  /**
   * 驗證 URL
   */
  isValidUrl: (url: string): boolean => {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  },
  
  /**
   * 驗證非空字串
   */
  isNonEmptyString: (value: unknown): boolean => {
    return typeof value === 'string' && value.trim().length > 0;
  },
  
  /**
   * 驗證數字範圍
   */
  isInRange: (value: number, min: number, max: number): boolean => {
    return typeof value === 'number' && value >= min && value <= max;
  },
};

// 導出流體排版工具
export { FluidTypographyCalculator, fluidTypographyUtils, defaultFluidTypographyConfigs } from './fluidTypography';

// 導出 Web Vitals 監控工具
export { WebVitalsMonitor, initWebVitalsMonitoring, getWebVitalsMonitor } from './webVitalsMonitor';
</file>

<file path="src/utils/webVitalsMonitor.ts">
import { onCLS, onINP, onFCP, onLCP, onTTFB, Metric } from 'web-vitals';

/**
 * Web Vitals 監控配置
 */
export interface WebVitalsConfig {
  enableConsoleLogging?: boolean;
  enableAnalytics?: boolean;
  analyticsEndpoint?: string;
  thresholds?: {
      LCP?: number;
      INP?: number;
      CLS?: number;
      FCP?: number;
      TTFB?: number;
    };
}

/**
 * 性能指標數據
 */
export interface PerformanceMetric {
  name: string;
  value: number;
  rating: 'good' | 'needs-improvement' | 'poor';
  timestamp: number;
  url: string;
  userAgent: string;
}

/**
 * Web Vitals 監控器
 */
export class WebVitalsMonitor {
  private config: WebVitalsConfig;
  private metrics: Map<string, PerformanceMetric> = new Map();
  private observers: Map<string, PerformanceObserver> = new Map();

  constructor(config: WebVitalsConfig = {}) {
    this.config = {
      enableConsoleLogging: true,
      enableAnalytics: false,
      thresholds: {
        LCP: 2500,  // 2.5s
        INP: 200,   // 200ms
        CLS: 0.1,   // 0.1
        FCP: 1800,  // 1.8s
        TTFB: 800   // 800ms
      },
      ...config
    };

    this.initializeMonitoring();
  }

  /**
   * 初始化性能監控
   */
  private initializeMonitoring(): void {
    // 監控 Core Web Vitals
    onCLS(this.handleMetric.bind(this));
    onINP(this.handleMetric.bind(this));
    onLCP(this.handleMetric.bind(this));
    
    // 監控其他重要指標
    onFCP(this.handleMetric.bind(this));
    onTTFB(this.handleMetric.bind(this));

    // 自定義性能監控
    this.setupCustomObservers();
  }

  /**
   * 設置自定義性能觀察器
   */
  private setupCustomObservers(): void {
    // 監控長任務
    if ('PerformanceObserver' in window) {
      try {
        const longTaskObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            this.handleLongTask(entry as PerformanceEntry);
          }
        });
        longTaskObserver.observe({ entryTypes: ['longtask'] });
        this.observers.set('longtask', longTaskObserver);
      } catch {
        console.warn('Long task observer not supported');
      }

      // 監控導航時間
      try {
        const navigationObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            this.handleNavigationTiming(entry as PerformanceNavigationTiming);
          }
        });
        navigationObserver.observe({ entryTypes: ['navigation'] });
        this.observers.set('navigation', navigationObserver);
      } catch {
        console.warn('Navigation observer not supported');
      }

      // 監控資源加載
      try {
        const resourceObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            this.handleResourceTiming(entry as PerformanceResourceTiming);
          }
        });
        resourceObserver.observe({ entryTypes: ['resource'] });
        this.observers.set('resource', resourceObserver);
      } catch {
        console.warn('Resource observer not supported');
      }
    }
  }

  /**
   * 處理 Web Vitals 指標
   */
  private handleMetric(metric: Metric): void {
    const performanceMetric: PerformanceMetric = {
      name: metric.name,
      value: metric.value,
      rating: metric.rating,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };

    this.metrics.set(metric.name, performanceMetric);

    if (this.config.enableConsoleLogging) {
      this.logMetric(performanceMetric);
    }

    if (this.config.enableAnalytics) {
      this.sendToAnalytics(performanceMetric);
    }

    // 檢查性能警告
    this.checkPerformanceWarnings(performanceMetric);
  }

  /**
   * 處理長任務
   */
  private handleLongTask(entry: PerformanceEntry): void {
    const duration = entry.duration;
    if (duration > 50) { // 超過 50ms 的任務
      const metric: PerformanceMetric = {
        name: 'Long Task',
        value: duration,
        rating: duration > 100 ? 'poor' : 'needs-improvement',
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent
      };

      if (this.config.enableConsoleLogging) {
        console.warn(`Long task detected: ${duration}ms`);
      }

      this.metrics.set(`longtask-${entry.startTime}`, metric);
    }
  }

  /**
   * 處理導航時間
   */
  private handleNavigationTiming(entry: PerformanceNavigationTiming): void {
    const metrics = {
      'DNS Lookup': entry.domainLookupEnd - entry.domainLookupStart,
      'TCP Connection': entry.connectEnd - entry.connectStart,
      'Request': entry.responseStart - entry.requestStart,
      'Response': entry.responseEnd - entry.responseStart,
      'DOM Processing': entry.domComplete - entry.domContentLoadedEventStart
    };

    for (const [name, value] of Object.entries(metrics)) {
      const metric: PerformanceMetric = {
        name,
        value,
        rating: this.getRating(name, value),
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent
      };

      this.metrics.set(name.toLowerCase().replace(' ', '-'), metric);
    }
  }

  /**
   * 處理資源加載時間
   */
  private handleResourceTiming(entry: PerformanceResourceTiming): void {
    const duration = entry.responseEnd - entry.startTime;
    
    // 只監控較慢的資源
    if (duration > 1000) {
      const metric: PerformanceMetric = {
        name: 'Slow Resource',
        value: duration,
        rating: duration > 3000 ? 'poor' : 'needs-improvement',
        timestamp: Date.now(),
        url: entry.name,
        userAgent: navigator.userAgent
      };

      this.metrics.set(`resource-${entry.startTime}`, metric);
    }
  }

  /**
   * 獲取性能評級
   */
  private getRating(metricName: string, value: number): 'good' | 'needs-improvement' | 'poor' {
    
    switch (metricName) {
      case 'LCP':
        return value <= 2500 ? 'good' : value <= 4000 ? 'needs-improvement' : 'poor';
      case 'INP':
        return value <= 200 ? 'good' : value <= 500 ? 'needs-improvement' : 'poor';
      case 'CLS':
        return value <= 0.1 ? 'good' : value <= 0.25 ? 'needs-improvement' : 'poor';
      case 'FCP':
        return value <= 1800 ? 'good' : value <= 3000 ? 'needs-improvement' : 'poor';
      case 'TTFB':
        return value <= 800 ? 'good' : value <= 1800 ? 'needs-improvement' : 'poor';
      default:
        return 'good';
    }
  }

  /**
   * 記錄指標
   */
  private logMetric(metric: PerformanceMetric): void {
    const color = metric.rating === 'good' ? 'green' : 
                  metric.rating === 'needs-improvement' ? 'orange' : 'red';
    
    console.log(
      `%c${metric.name}: ${metric.value.toFixed(2)}${metric.name === 'CLS' ? '' : 'ms'} (${metric.rating})`,
      `color: ${color}; font-weight: bold;`
    );
  }

  /**
   * 發送到分析服務
   */
  private sendToAnalytics(metric: PerformanceMetric): void {
    if (!this.config.analyticsEndpoint) return;

    fetch(this.config.analyticsEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(metric),
    }).catch(error => {
      console.error('Failed to send metric to analytics:', error);
    });
  }

  /**
   * 檢查性能警告
   */
  private checkPerformanceWarnings(metric: PerformanceMetric): void {
    if (metric.rating === 'poor') {
      console.warn(`Poor ${metric.name} performance detected: ${metric.value}ms`);
      
      // 提供優化建議
      this.provideOptimizationSuggestions(metric.name);
    }
  }

  /**
   * 提供優化建議
   */
  private provideOptimizationSuggestions(metricName: string): void {
    const suggestions: Record<string, string[]> = {
      'LCP': [
        '優化圖片大小和格式',
        '使用 CDN 加速資源加載',
        '減少關鍵渲染路徑中的資源',
        '使用 preload 預加載重要資源'
      ],
      'INP': [
        '減少 JavaScript 執行時間',
        '使用 Web Workers 處理重計算',
        '優化事件處理器',
        '延遲載入非關鍵 JavaScript',
        '避免長時間運行的任務',
        '優化第三方腳本'
      ],
      'CLS': [
        '為圖片和廣告設置尺寸屬性',
        '避免在現有內容上方插入內容',
        '使用 transform 動畫而非改變佈局屬性',
        '預留動態內容空間'
      ]
    };

    const metricSuggestions = suggestions[metricName];
    if (metricSuggestions) {
      console.group(`${metricName} 優化建議:`);
      metricSuggestions.forEach(suggestion => {
        console.log(`• ${suggestion}`);
      });
      console.groupEnd();
    }
  }

  /**
   * 獲取所有指標
   */
  public getMetrics(): Map<string, PerformanceMetric> {
    return new Map(this.metrics);
  }

  /**
   * 獲取特定指標
   */
  public getMetric(name: string): PerformanceMetric | undefined {
    return this.metrics.get(name);
  }

  /**
   * 生成性能報告
   */
  public generateReport(): {
    coreWebVitals: Record<string, PerformanceMetric>;
    otherMetrics: Record<string, PerformanceMetric>;
    summary: {
      totalMetrics: number;
      goodMetrics: number;
      needsImprovementMetrics: number;
      poorMetrics: number;
    };
  } {
    const coreWebVitals: Record<string, PerformanceMetric> = {};
    const otherMetrics: Record<string, PerformanceMetric> = {};
    
    let goodCount = 0;
    let needsImprovementCount = 0;
    let poorCount = 0;

    for (const [name, metric] of this.metrics) {
      if (['LCP', 'INP', 'CLS'].includes(metric.name)) {
        coreWebVitals[name] = metric;
      } else {
        otherMetrics[name] = metric;
      }

      switch (metric.rating) {
        case 'good':
          goodCount++;
          break;
        case 'needs-improvement':
          needsImprovementCount++;
          break;
        case 'poor':
          poorCount++;
          break;
      }
    }

    return {
      coreWebVitals,
      otherMetrics,
      summary: {
        totalMetrics: this.metrics.size,
        goodMetrics: goodCount,
        needsImprovementMetrics: needsImprovementCount,
        poorMetrics: poorCount
      }
    };
  }

  /**
   * 清理監控器
   */
  public cleanup(): void {
    for (const observer of this.observers.values()) {
      observer.disconnect();
    }
    this.observers.clear();
    this.metrics.clear();
  }
}

/**
 * 全局 Web Vitals 監控實例
 */
let globalMonitor: WebVitalsMonitor | null = null;

/**
 * 初始化 Web Vitals 監控
 */
export const initWebVitalsMonitoring = (config?: WebVitalsConfig): WebVitalsMonitor => {
  if (globalMonitor) {
    globalMonitor.cleanup();
  }
  
  globalMonitor = new WebVitalsMonitor(config);
  return globalMonitor;
};

/**
 * 獲取全局監控實例
 */
export const getWebVitalsMonitor = (): WebVitalsMonitor | null => {
  return globalMonitor;
};

const webVitalsExports = {
  WebVitalsMonitor,
  initWebVitalsMonitoring,
  getWebVitalsMonitor
};

export default webVitalsExports;
</file>

<file path="tests/responsive.spec.ts">
import { test, expect, Page } from '@playwright/test';

interface PerformanceMetrics {
  LCP?: number;
  FID?: number;
  CLS?: number;
  INP?: number;
  TTFB?: number;
}

/**
 * 響應式設計測試工具
 */
class ResponsiveTestUtils {
  constructor(private page: Page) {}

  /**
   * 設置視窗大小
   */
  async setViewport(width: number, height: number) {
    await this.page.setViewportSize({ width, height });
    // 等待佈局穩定
    await this.page.waitForTimeout(100);
  }

  /**
   * 檢查元素是否可見
   */
  async isElementVisible(selector: string): Promise<boolean> {
    try {
      const element = this.page.locator(selector);
      return await element.isVisible();
    } catch {
      return false;
    }
  }

  /**
   * 獲取元素尺寸
   */
  async getElementSize(selector: string) {
    const element = this.page.locator(selector);
    const box = await element.boundingBox();
    return box;
  }

  /**
   * 檢查文字是否被截斷
   */
  async isTextTruncated(selector: string): Promise<boolean> {
    const element = this.page.locator(selector);
    const { scrollWidth, clientWidth } = await element.evaluate((el) => ({
      scrollWidth: el.scrollWidth,
      clientWidth: el.clientWidth
    }));
    return scrollWidth > clientWidth;
  }

  /**
   * 檢查元素是否重疊
   */
  async areElementsOverlapping(selector1: string, selector2: string): Promise<boolean> {
    const box1 = await this.getElementSize(selector1);
    const box2 = await this.getElementSize(selector2);
    
    if (!box1 || !box2) return false;
    
    return !(
      box1.x + box1.width < box2.x ||
      box2.x + box2.width < box1.x ||
      box1.y + box1.height < box2.y ||
      box2.y + box2.height < box1.y
    );
  }

  /**
   * 檢查觸摸目標大小
   */
  async checkTouchTargetSize(selector: string, minSize: number = 44): Promise<boolean> {
    const box = await this.getElementSize(selector);
    if (!box) return false;
    
    return box.width >= minSize && box.height >= minSize;
  }

  /**
   * 測試容器查詢響應
   */
  async testContainerQuery(containerSelector: string, expectedChanges: Record<number, string[]>) {
    const container = this.page.locator(containerSelector);
    
    for (const [width, expectedClasses] of Object.entries(expectedChanges)) {
      // 調整容器寬度（通過調整視窗大小）
      await this.setViewport(parseInt(width), 800);
      
      // 檢查預期的類名是否存在
      for (const className of expectedClasses) {
        await expect(container).toHaveClass(new RegExp(className));
      }
    }
  }

  /**
   * 測試流體排版
   */
  async testFluidTypography(selector: string, viewports: { width: number; expectedSize: number }[]) {
    for (const { width, expectedSize } of viewports) {
      await this.setViewport(width, 800);
      
      const fontSize = await this.page.locator(selector).evaluate((el) => {
        return parseFloat(window.getComputedStyle(el).fontSize);
      });
      
      // 允許 ±2px 的誤差
      expect(Math.abs(fontSize - expectedSize)).toBeLessThanOrEqual(2);
    }
  }
}

/**
 * 響應式設計基礎測試
 */
test.describe('響應式設計測試', () => {
  let utils: ResponsiveTestUtils;

  test.beforeEach(async ({ page }) => {
    utils = new ResponsiveTestUtils(page);
    await page.goto('/');
  });

  test('主頁在不同設備上正確顯示', async ({ page }) => {
    const viewports = [
      { width: 320, height: 568, name: '小屏手機' },
      { width: 375, height: 667, name: '中屏手機' },
      { width: 768, height: 1024, name: '平板' },
      { width: 1280, height: 720, name: '桌面' },
      { width: 1920, height: 1080, name: '大屏桌面' }
    ];

    for (const viewport of viewports) {
      await page.setViewportSize(viewport);
      
      // 檢查主要元素是否可見
      await expect(page.locator('h1')).toBeVisible();
      await expect(page.locator('main')).toBeVisible();
      
      // 截圖對比
      await expect(page).toHaveScreenshot(`homepage-${viewport.name}.png`);
    }
  });

  test('PersonaCard 容器查詢響應', async ({ page }) => {
    await page.goto('/personas');
    
    // const _cardSelector = '.persona-card';
    const containerSelector = '.container-query-card';
    
    // 測試不同容器寬度下的佈局變化
    const expectedChanges = {
      280: ['cq-flex-col'],
      400: ['persona-card-narrow'],
      600: ['persona-card-wide']
    };
    
    await utils.testContainerQuery(containerSelector, expectedChanges);
  });

  test('流體排版在不同視窗下正確縮放', async () => {
    const headingSelector = '.fluid-heading-1';
    
    const viewports = [
      { width: 320, expectedSize: 24 },  // 1.5rem
      { width: 768, expectedSize: 32 },  // 約 2rem
      { width: 1920, expectedSize: 48 }  // 3rem
    ];
    
    await utils.testFluidTypography(headingSelector, viewports);
  });

  test('觸摸目標大小符合可訪問性標準', async ({ page }) => {
    await page.goto('/personas');
    
    // 檢查所有按鈕的觸摸目標大小
    const buttons = page.locator('button');
    const buttonCount = await buttons.count();
    
    for (let i = 0; i < buttonCount; i++) {
      const button = buttons.nth(i);
      const isVisible = await button.isVisible();
      
      if (isVisible) {
        const box = await button.boundingBox();
        if (box) {
          expect(box.width).toBeGreaterThanOrEqual(44);
          expect(box.height).toBeGreaterThanOrEqual(44);
        }
      }
    }
  });

  test('圖片響應式加載', async ({ page }) => {
    await page.goto('/personas');
    
    // 檢查圖片是否正確加載
    const images = page.locator('img');
    const imageCount = await images.count();
    
    for (let i = 0; i < imageCount; i++) {
      const img = images.nth(i);
      const isVisible = await img.isVisible();
      
      if (isVisible) {
        // 檢查圖片是否有 alt 屬性
        const alt = await img.getAttribute('alt');
        expect(alt).toBeTruthy();
        
        // 檢查圖片是否加載成功
        const naturalWidth = await img.evaluate((el: HTMLImageElement) => el.naturalWidth);
        expect(naturalWidth).toBeGreaterThan(0);
      }
    }
  });

  test('佈局在極小屏幕上不會破壞', async ({ page }) => {
    // 測試極小屏幕（如舊款手機）
    await utils.setViewport(240, 320);
    
    // 檢查是否有水平滾動條
    const hasHorizontalScroll = await page.evaluate(() => {
      return document.documentElement.scrollWidth > document.documentElement.clientWidth;
    });
    
    expect(hasHorizontalScroll).toBeFalsy();
    
    // 檢查主要內容是否仍然可見
    await expect(page.locator('main')).toBeVisible();
  });

  test('佈局在超大屏幕上正確顯示', async ({ page }) => {
    // 測試超大屏幕
    await utils.setViewport(3840, 2160);
    
    // 檢查內容是否居中且不會過度拉伸
    const main = page.locator('main');
    const box = await main.boundingBox();
    
    if (box) {
      // 內容寬度不應該超過合理範圍
      expect(box.width).toBeLessThanOrEqual(1920);
    }
  });
});

/**
 * 性能測試
 */
test.describe('響應式性能測試', () => {
  test('頁面加載性能', async ({ page }) => {
    // 開始性能監控
    await page.goto('/', { waitUntil: 'networkidle' });
    
    // 檢查 Core Web Vitals
    const metrics = await page.evaluate(() => {
      return new Promise((resolve) => {
        new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const metrics: Record<string, number> = {};
          
          entries.forEach((entry) => {
            if (entry.entryType === 'largest-contentful-paint') {
              metrics.LCP = entry.startTime;
            }
          });
          
          resolve(metrics);
        }).observe({ entryTypes: ['largest-contentful-paint'] });
        
        // 5秒後返回結果
        setTimeout(() => resolve({}), 5000);
      });
    });
    
    // LCP 應該小於 2.5 秒
    if ((metrics as PerformanceMetrics).LCP) {
      expect((metrics as PerformanceMetrics).LCP).toBeLessThan(2500);
    }
  });

  test('圖片加載性能', async ({ page }) => {
    await page.goto('/personas');
    
    // 監控圖片加載時間
    const imageLoadTimes: number[] = [];
    
    page.on('response', (response) => {
      if (response.url().match(/\.(jpg|jpeg|png|webp|avif)$/)) {
        // Note: response.timing() is not available in Playwright
        // Using alternative approach to measure image load time
        const startTime = Date.now();
        response.finished().then(() => {
          const loadTime = Date.now() - startTime;
          imageLoadTimes.push(loadTime);
        });
      }
    });
    
    await page.waitForLoadState('networkidle');
    
    // 圖片加載時間應該合理
    imageLoadTimes.forEach((time) => {
      expect(time).toBeLessThan(3000); // 3秒內
    });
  });
});

/**
 * 可訪問性測試
 */
test.describe('響應式可訪問性測試', () => {
  test('鍵盤導航在不同設備上正常工作', async ({ page }) => {
    await page.goto('/personas');
    
    const viewports = [
      { width: 320, height: 568 },
      { width: 768, height: 1024 },
      { width: 1920, height: 1080 }
    ];
    
    for (const viewport of viewports) {
      await page.setViewportSize(viewport);
      
      // 測試 Tab 鍵導航
      await page.keyboard.press('Tab');
      const focusedElement = await page.evaluate(() => document.activeElement?.tagName);
      expect(focusedElement).toBeTruthy();
    }
  });

  test('顏色對比度在不同主題下符合標準', async ({ page }) => {
    await page.goto('/');
    
    // 檢查主要文字元素的對比度
    const textElements = [
      'h1',
      'h2',
      'h3',
      'p',
      'button'
    ];
    
    for (const selector of textElements) {
      const elements = page.locator(selector);
      const count = await elements.count();
      
      for (let i = 0; i < Math.min(count, 5); i++) {
        const element = elements.nth(i);
        const isVisible = await element.isVisible();
        
        if (isVisible) {
          const styles = await element.evaluate((el) => {
            const computed = window.getComputedStyle(el);
            return {
              color: computed.color,
              backgroundColor: computed.backgroundColor
            };
          });
          
          // 這裡可以添加對比度計算邏輯
          expect(styles.color).toBeTruthy();
        }
      }
    }
  });
});
</file>

<file path="tests/utils/responsive-test-helper.ts">
/**
 * 響應式設計測試工具
 * 提供自動化測試響應式設計的工具函數
 */

import { Page, expect } from '@playwright/test';

export interface ViewportConfig {
  width: number;
  height: number;
  name: string;
  deviceType: 'mobile' | 'tablet' | 'desktop';
}

export interface PerformanceEntry {
  duration?: number;
  value?: number;
  hadRecentInput?: boolean;
}

export interface ResponsiveTestConfig {
  viewports: ViewportConfig[];
  elements: string[];
  breakpoints: Record<string, number>;
  touchTargetMinSize: number;
}

/**
 * 預設的響應式測試配置
 */
export const defaultResponsiveConfig: ResponsiveTestConfig = {
  viewports: [
    { width: 320, height: 568, name: 'iPhone SE', deviceType: 'mobile' },
    { width: 375, height: 667, name: 'iPhone 8', deviceType: 'mobile' },
    { width: 414, height: 896, name: 'iPhone 11', deviceType: 'mobile' },
    { width: 768, height: 1024, name: 'iPad', deviceType: 'tablet' },
    { width: 1024, height: 1366, name: 'iPad Pro', deviceType: 'tablet' },
    { width: 1280, height: 720, name: 'Desktop Small', deviceType: 'desktop' },
    { width: 1920, height: 1080, name: 'Desktop Large', deviceType: 'desktop' },
    { width: 2560, height: 1440, name: 'Desktop XL', deviceType: 'desktop' }
  ],
  elements: ['header', 'main', 'nav', 'footer', '.card', '.button'],
  breakpoints: {
    mobile: 640,
    tablet: 1024,
    desktop: 1280
  },
  touchTargetMinSize: 44
};

/**
 * 響應式測試工具類
 */
export class ResponsiveTestHelper {
  constructor(private page: Page, private config: ResponsiveTestConfig = defaultResponsiveConfig) {}

  /**
   * 測試所有視窗大小下的佈局
   */
  async testAllViewports(testCallback: (viewport: ViewportConfig) => Promise<void>) {
    for (const viewport of this.config.viewports) {
      await this.setViewport(viewport);
      await testCallback(viewport);
    }
  }

  /**
   * 設置視窗大小並等待佈局穩定
   */
  async setViewport(viewport: ViewportConfig) {
    await this.page.setViewportSize({ width: viewport.width, height: viewport.height });
    await this.page.waitForTimeout(200); // 等待佈局穩定
  }

  /**
   * 檢查元素在當前視窗下是否可見
   */
  async checkElementVisibility(selector: string): Promise<boolean> {
    try {
      const element = this.page.locator(selector);
      return await element.isVisible();
    } catch {
      return false;
    }
  }

  /**
   * 檢查所有重要元素的可見性
   */
  async checkAllElementsVisibility(): Promise<Record<string, boolean>> {
    const results: Record<string, boolean> = {};
    
    for (const selector of this.config.elements) {
      results[selector] = await this.checkElementVisibility(selector);
    }
    
    return results;
  }

  /**
   * 檢查觸摸目標大小
   */
  async checkTouchTargets(): Promise<{ selector: string; width: number; height: number; isValid: boolean }[]> {
    const results = [];
    const touchElements = await this.page.locator('button, a, [role="button"], .touch-target').all();
    
    for (const element of touchElements) {
      const box = await element.boundingBox();
      if (box && await element.isVisible()) {
        const isValid = box.width >= this.config.touchTargetMinSize && 
                       box.height >= this.config.touchTargetMinSize;
        
        results.push({
          selector: await element.getAttribute('class') || 'unknown',
          width: box.width,
          height: box.height,
          isValid
        });
      }
    }
    
    return results;
  }

  /**
   * 檢查文字是否被截斷
   */
  async checkTextOverflow(selector: string): Promise<boolean> {
    const element = this.page.locator(selector);
    
    try {
      const { scrollWidth, clientWidth } = await element.evaluate((el) => ({
        scrollWidth: el.scrollWidth,
        clientWidth: el.clientWidth
      }));
      
      return scrollWidth > clientWidth;
    } catch {
      return false;
    }
  }

  /**
   * 檢查元素是否重疊
   */
  async checkElementOverlap(selector1: string, selector2: string): Promise<boolean> {
    const element1 = this.page.locator(selector1);
    const element2 = this.page.locator(selector2);
    
    const box1 = await element1.boundingBox();
    const box2 = await element2.boundingBox();
    
    if (!box1 || !box2) return false;
    
    return !(
      box1.x + box1.width < box2.x ||
      box2.x + box2.width < box1.x ||
      box1.y + box1.height < box2.y ||
      box2.y + box2.height < box1.y
    );
  }

  /**
   * 檢查是否有水平滾動條
   */
  async hasHorizontalScroll(): Promise<boolean> {
    return await this.page.evaluate(() => {
      return document.documentElement.scrollWidth > document.documentElement.clientWidth;
    });
  }

  /**
   * 測試容器查詢響應
   */
  async testContainerQueries(containerSelector: string, expectedBehaviors: Record<number, string[]>) {
    for (const [width, expectedClasses] of Object.entries(expectedBehaviors)) {
      await this.page.setViewportSize({ width: parseInt(width), height: 800 });
      await this.page.waitForTimeout(100);
      
      const container = this.page.locator(containerSelector);
      
      for (const className of expectedClasses) {
        await expect(container).toHaveClass(new RegExp(className));
      }
    }
  }

  /**
   * 測試流體排版
   */
  async testFluidTypography(selector: string, expectedSizes: Record<number, { min: number; max: number }>) {
    for (const [width, { min, max }] of Object.entries(expectedSizes)) {
      await this.page.setViewportSize({ width: parseInt(width), height: 800 });
      await this.page.waitForTimeout(100);
      
      const fontSize = await this.page.locator(selector).evaluate((el) => {
        return parseFloat(window.getComputedStyle(el).fontSize);
      });
      
      expect(fontSize).toBeGreaterThanOrEqual(min);
      expect(fontSize).toBeLessThanOrEqual(max);
    }
  }

  /**
   * 生成響應式測試報告
   */
  async generateReport(): Promise<{
    viewport: ViewportConfig;
    visibility: Record<string, boolean>;
    touchTargets: { valid: number; invalid: number; details: unknown[] };
    hasHorizontalScroll: boolean;
    textOverflows: string[];
  }[]> {
    const reports = [];
    
    for (const viewport of this.config.viewports) {
      await this.setViewport(viewport);
      
      const visibility = await this.checkAllElementsVisibility();
      const touchTargets = await this.checkTouchTargets();
      const hasHorizontalScroll = await this.hasHorizontalScroll();
      
      // 檢查文字溢出
      const textOverflows = [];
      for (const selector of ['h1', 'h2', 'h3', 'p', '.text-content']) {
        if (await this.checkTextOverflow(selector)) {
          textOverflows.push(selector);
        }
      }
      
      reports.push({
        viewport,
        visibility,
        touchTargets: {
          valid: touchTargets.filter(t => t.isValid).length,
          invalid: touchTargets.filter(t => !t.isValid).length,
          details: touchTargets.filter(t => !t.isValid)
        },
        hasHorizontalScroll,
        textOverflows
      });
    }
    
    return reports;
  }

  /**
   * 截圖對比測試
   */
  async takeResponsiveScreenshots(name: string): Promise<void> {
    for (const viewport of this.config.viewports) {
      await this.setViewport(viewport);
      await expect(this.page).toHaveScreenshot(`${name}-${viewport.name}.png`);
    }
  }

  /**
   * 測試性能指標
   */
  async measurePerformance(): Promise<{
    lcp?: number;
    fid?: number;
    cls?: number;
    fcp?: number;
    ttfb?: number;
  }> {
    return await this.page.evaluate(() => {
      return new Promise((resolve) => {
        const metrics: Record<string, unknown> = {};
        let metricsCollected = 0;
        const totalMetrics = 3; // LCP, FID, CLS
        
        const checkComplete = () => {
          metricsCollected++;
          if (metricsCollected >= totalMetrics) {
            resolve(metrics);
          }
        };
        
        // 測量 LCP
        new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const lastEntry = entries[entries.length - 1];
          metrics.lcp = lastEntry.startTime;
          checkComplete();
        }).observe({ entryTypes: ['largest-contentful-paint'] });
        
        // 測量 INP (替代 FID)
        new PerformanceObserver((list) => {
          const entries = list.getEntries();
          if (entries.length > 0) {
            const entry = entries[0] as PerformanceEntry;
            metrics.inp = entry.duration || 0;
            checkComplete();
          }
        }).observe({ entryTypes: ['event'] });
        
        // 測量 CLS
        let clsValue = 0;
        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            const layoutShiftEntry = entry as PerformanceEntry & { hadRecentInput?: boolean; value?: number };
            if (!layoutShiftEntry.hadRecentInput) {
              clsValue += layoutShiftEntry.value || 0;
            }
          }
          metrics.cls = clsValue;
          checkComplete();
        }).observe({ entryTypes: ['layout-shift'] });
        
        // 5秒後超時
        setTimeout(() => resolve(metrics), 5000);
      });
    });
  }
}

/**
 * 快速響應式測試函數
 */
export async function quickResponsiveTest(
  page: Page, 
  url: string, 
  options: Partial<ResponsiveTestConfig> = {}
): Promise<void> {
  const config = { ...defaultResponsiveConfig, ...options };
  const helper = new ResponsiveTestHelper(page, config);
  
  await page.goto(url);
  
  await helper.testAllViewports(async (viewport) => {
    // 檢查基本可見性
    // const _visibility = await helper.checkAllElementsVisibility();
    
    // 檢查是否有水平滾動
    const hasHorizontalScroll = await helper.hasHorizontalScroll();
    expect(hasHorizontalScroll).toBeFalsy();
    
    // 檢查觸摸目標（僅在移動設備上）
    if (viewport.deviceType === 'mobile') {
      const touchTargets = await helper.checkTouchTargets();
      const invalidTargets = touchTargets.filter(t => !t.isValid);
      
      if (invalidTargets.length > 0) {
        console.warn(`Invalid touch targets found on ${viewport.name}:`, invalidTargets);
      }
    }
  });
}

export default ResponsiveTestHelper;
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    // 支持的圖片格式
    formats: ['image/webp', 'image/avif'],
    
    // 允許的圖片域名 (使用新的 remotePatterns 配置)
    remotePatterns: [
      {
        protocol: 'http',
        hostname: 'localhost',
      },
      {
        protocol: 'https',
        hostname: 'example.com',
      },
      {
        protocol: 'https',
        hostname: 'images.unsplash.com',
      },
      {
        protocol: 'https',
        hostname: 'via.placeholder.com',
      },
    ],
    
    // 圖片尺寸配置
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    
    // 啟用圖片優化
    unoptimized: false,
    
    // 懶加載配置
    loader: 'default',
    
    // 圖片緩存配置
    minimumCacheTTL: 60,
    
    // 危險的允許 SVG
    dangerouslyAllowSVG: false,
    
    // 內容安全策略
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },
  
  // 實驗性功能
  experimental: {
    // 啟用 App Router 優化
    optimizePackageImports: ['lucide-react'],
  },
  
  // 編譯器優化
  compiler: {
    // 移除 console.log
    removeConsole: process.env.NODE_ENV === 'production',
  },
  
  // 性能優化
  poweredByHeader: false,
  compress: true,
  
  // 重定向配置
  async redirects() {
    return [];
  },
  
  // 頭部配置
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'Referrer-Policy',
            value: 'origin-when-cross-origin',
          },
        ],
      },
    ];
  },
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "virtual-meeting-room",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --webpack",
    "build": "next build --webpack",
    "start": "next start",
    "lint": "eslint",
    "test": "playwright test",
    "test:ui": "playwright test --ui",
    "test:responsive": "playwright test tests/responsive.spec.ts",
    "test:touch": "playwright test tests/touch-interactions.spec.ts",
    "test:report": "playwright show-report"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.552.0",
    "next": "16.0.1",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "web-vitals": "^5.1.0",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@playwright/test": "^1.56.1",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.0.1",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="src/app/api/generate-topic/route.ts">
import { NextRequest, NextResponse } from 'next/server';

import { GoogleGenerativeAI } from '@google/generative-ai';

export async function POST(request: NextRequest) {
  try {
    const { firstStatement, context } = await request.json();

    if (!firstStatement) {
      return NextResponse.json(
        { error: '缺少必要的參數：firstStatement' },
        { status: 400 }
      );
    }

    // 構建主題生成的提示詞
    const prompt = `
請根據以下第一個發言內容，生成一個簡潔且準確的會議主題。

發言內容：
"${firstStatement}"

${context ? `會議背景：${context}` : ''}

要求：
1. 主題應該簡潔明了，不超過20個字
2. 準確反映討論的核心議題
3. 使用中文
4. 避免過於具體的細節
5. 適合作為辯論會議的標題

請直接返回主題，不需要其他說明。
`;

    // 使用簡化的 Gemini API 調用來生成主題
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY is not configured');
    }

    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });

    const result = await model.generateContent({
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      generationConfig: {
        temperature: 0.3,
        maxOutputTokens: 100,
      },
    });

    const content = result.response?.text() || '';

    // 清理生成的主題，移除引號和多餘的文字
    let topic = content.trim();
    topic = topic.replace(/^["「『]|["」』]$/g, ''); // 移除首尾引號
    topic = topic.replace(/^主題：|^會議主題：/g, ''); // 移除前綴
    topic = topic.trim();

    // 確保主題不為空
    if (!topic) {
      topic = '討論議題';
    }

    return NextResponse.json({ topic });
  } catch (error) {
    console.error('生成主題時發生錯誤:', error);
    return NextResponse.json(
      { error: '生成主題失敗', details: error instanceof Error ? error.message : '未知錯誤' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  
  /* 響應式斷點配置 - 語義化命名 */
  --breakpoint-mobile: 320px;
  --breakpoint-tablet: 640px;
  --breakpoint-laptop: 1024px;
  --breakpoint-desktop: 1280px;
  
  /* 觸摸友好的最小尺寸標準 */
  --touch-target-min: 44px;
  --touch-target-comfortable: 56px;
  
  /* 移動端優化的間距系統 */
  --spacing-mobile-xs: 0.25rem;
  --spacing-mobile-sm: 0.5rem;
  --spacing-mobile-md: 1rem;
  --spacing-mobile-lg: 1.5rem;
  --spacing-mobile-xl: 2rem;
  
  /* 自定義斷點 */
  --breakpoint-sm: 640px;
  --breakpoint-md: 768px;
  --breakpoint-lg: 1024px;
  --breakpoint-xl: 1280px;
  --breakpoint-2xl: 1536px;
  
  /* 觸摸目標尺寸 */
  --size-touch-sm: 44px;
  --size-touch-md: 56px;
  --size-touch-lg: 64px;
  
  /* 容器查詢斷點 */
  --container-xs: 280px;
  --container-sm: 320px;
  --container-md: 480px;
  --container-lg: 640px;
  --container-xl: 800px;
  --container-2xl: 1024px;
  
  /* 流體排版變量 */
  --fluid-min-width: 320px;
  --fluid-max-width: 1920px;
  --fluid-screen-ratio: 100vw;
  
  /* 容器查詢命名 */
  --container-name-component: component;
  --container-name-card: card;
  --container-name-layout: layout;
  
  /* 流體排版基礎變量 */
  --fluid-type-min-size: 0.875rem;
  --fluid-type-max-size: 1.125rem;
  --fluid-type-min-screen: 20rem;
  --fluid-type-max-screen: 120rem;
  
  /* 流體排版比例 */
  --fluid-heading-1-min: 1.5rem;
  --fluid-heading-1-max: 3rem;
  --fluid-heading-2-min: 1.25rem;
  --fluid-heading-2-max: 2.25rem;
  --fluid-heading-3-min: 1.125rem;
  --fluid-heading-3-max: 1.875rem;
  --fluid-body-min: 0.875rem;
  --fluid-body-max: 1.125rem;
  --fluid-small-min: 0.75rem;
  --fluid-small-max: 0.875rem;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

/* 添加 line-clamp 工具類 */
@layer utilities {
  .line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
  
  .line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }
  
  .line-clamp-3 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
  }
}

/* 自定義動畫 */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.animate-fade-in-up {
  animation: fadeInUp 0.3s ease-out;
}

.animate-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* 改進的焦點樣式 */
.focus-ring {
  @apply focus:outline-none focus:ring-4 focus:ring-blue-500/20;
}

/* 卡片懸停效果 */
.card-hover {
  @apply transition-all duration-300 ease-out hover:shadow-lg hover:scale-[1.02];
}

/* 按鈕樣式 */
.btn-primary {
  @apply bg-blue-600 text-white px-4 py-2 rounded-lg font-medium transition-colors hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-500/20 disabled:opacity-50 disabled:cursor-not-allowed;
}

.btn-secondary {
  @apply bg-gray-100 text-gray-700 px-4 py-2 rounded-lg font-medium transition-colors hover:bg-gray-200 focus:outline-none focus:ring-4 focus:ring-gray-500/20 disabled:opacity-50 disabled:cursor-not-allowed;
}

/* 滾動條樣式 */
.custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: #cbd5e1 #f1f5f9;
}

.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* 移動端優化的基礎樣式 */
@layer base {
  /* 確保觸摸目標最小尺寸 */
  button, [role="button"], input[type="button"], input[type="submit"] {
    min-height: 44px;
    min-width: 44px;
  }
  
  /* 移動端文字可讀性 */
  body {
    font-size: 16px; /* 防止iOS縮放 */
    -webkit-text-size-adjust: 100%;
    text-size-adjust: 100%;
  }
  
  /* 移動端滾動優化 */
  * {
    -webkit-overflow-scrolling: touch;
  }
}

@layer utilities {
  /* 響應式容器 */
  .container-responsive {
    @apply w-full mx-auto px-4 tablet:px-6 laptop:px-8;
    max-width: 100%;
  }
  
  @media (min-width: 640px) {
    .container-responsive {
      max-width: 640px;
    }
  }
  
  @media (min-width: 1024px) {
    .container-responsive {
      max-width: 1024px;
    }
  }
  
  @media (min-width: 1280px) {
    .container-responsive {
      max-width: 1280px;
    }
  }
  
  /* 觸摸友好的按鈕 */
  .btn-touch {
    @apply flex items-center justify-center;
    @apply px-4 py-3 rounded-lg;
    @apply transition-all duration-200 ease-out;
    @apply focus:outline-none focus:ring-4 focus:ring-blue-500/20;
    min-height: 44px;
    min-width: 44px;
  }
  
  .btn-touch-lg {
    @apply px-6 py-4 rounded-xl;
    min-height: 56px;
    min-width: 56px;
  }
  
  /* 移動端卡片樣式 */
  .card-mobile {
    @apply bg-white rounded-lg shadow-sm;
    @apply p-4 tablet:p-6;
    @apply border border-gray-100;
  }
  
  /* 響應式網格 */
  .grid-responsive {
    @apply grid gap-4;
    @apply grid-cols-1 tablet:grid-cols-2 laptop:grid-cols-3 desktop:grid-cols-4;
  }
  
  .grid-responsive-cards {
    @apply grid gap-4 tablet:gap-6;
    @apply grid-cols-1 tablet:grid-cols-2 laptop:grid-cols-3;
  }
  
  /* 移動端導航 */
  .nav-mobile {
    @apply fixed bottom-0 left-0 right-0;
    @apply bg-white border-t border-gray-200;
    @apply px-2 py-1;
    @apply tablet:hidden;
    z-index: 40;
  }
  
  .nav-desktop {
    @apply hidden tablet:flex;
  }
  
  /* 側滑抽屜 */
  .drawer-overlay {
    @apply fixed inset-0 bg-black/50;
    @apply transition-opacity duration-300;
    z-index: 40;
  }
  
  .drawer-content {
    @apply fixed left-0 top-0 bottom-0 w-80 max-w-[85vw];
    @apply bg-white shadow-xl;
    @apply transform transition-transform duration-300;
    @apply translate-x-0;
    z-index: 40;
  }
  
  .drawer-content.closed {
    @apply -translate-x-full;
  }
  
  /* 浮動操作按鈕 */
  .fab {
    @apply fixed rounded-full;
    @apply bg-blue-600 text-white shadow-xl;
    @apply flex items-center justify-center;
    @apply transition-all duration-200 ease-out;
    @apply hover:bg-blue-700 hover:scale-110;
    @apply focus:outline-none focus:ring-4 focus:ring-blue-500/20;
    bottom: 24px;
    right: 24px;
    width: 56px;
    height: 56px;
    z-index: 45;
  }
  
  /* 防止水平溢出 */
  .prevent-overflow {
    @apply max-w-full overflow-hidden;
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
  }
  
  /* 移動端文字截斷 */
  .text-mobile-truncate {
    @apply truncate tablet:text-clip;
  }
  
  /* 響應式間距 */
  .spacing-responsive {
    @apply space-y-4 tablet:space-y-6 laptop:space-y-8;
  }
  
  /* 全高度容器 */
  .full-height-mobile {
    height: 100vh;
    height: 100dvh; /* 動態視窗高度 */
  }
  
  .safe-area-mobile {
    padding-bottom: env(safe-area-inset-bottom);
    padding-top: env(safe-area-inset-top);
  }
}

/* 移動端媒體查詢優化 */
@media (max-width: 639px) {
  .hide-mobile {
    display: none !important;
  }
  
  /* 移動端表格響應式 */
  .table-mobile {
    @apply block overflow-x-auto whitespace-nowrap;
  }
  
  /* 移動端模態框 */
  .modal-mobile {
    @apply fixed;
    @apply rounded-xl;
    @apply max-h-[90vh] overflow-y-auto;
    inset: 1rem;
  }
}

@media (min-width: 640px) {
  .hide-tablet-up {
    display: none !important;
  }
}

/* 觸摸設備優化 */
@media (hover: none) and (pointer: coarse) {
  /* 移除懸停效果，添加觸摸反饋 */
  .touch-feedback {
    @apply active:scale-95 active:bg-gray-100 transition-transform duration-150;
  }
  
  .touch-feedback-strong {
    @apply active:scale-90 active:bg-gray-200 transition-all duration-200;
  }
  
  /* 增大點擊區域 */
  .touch-area {
    @apply relative;
  }
  
  .touch-area::before {
    content: '';
    @apply absolute inset-0;
    min-height: 44px;
    min-width: 44px;
    @apply -m-2; /* 擴大點擊區域 */
  }
  
  /* 觸摸目標尺寸優化 */
  .touch-target-sm {
    min-height: 44px;
    min-width: 44px;
    @apply flex items-center justify-center;
  }
  
  .touch-target-md {
    min-height: 56px;
    min-width: 56px;
    @apply flex items-center justify-center;
  }
  
  .touch-target-lg {
    min-height: 64px;
    min-width: 64px;
    @apply flex items-center justify-center;
  }
  
  /* 手勢區域 */
  .gesture-area {
    touch-action: manipulation;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }
  
  /* 禁用雙擊縮放 */
  .no-zoom {
    touch-action: manipulation;
  }
  
  /* 觸摸滾動優化 */
  .touch-scroll {
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
  }
}

/* 觸摸反饋動畫 */
@keyframes touch-ripple {
  0% {
    transform: scale(0);
    opacity: 1;
  }
  100% {
    transform: scale(4);
    opacity: 0;
  }
}

.touch-ripple {
  position: relative;
  overflow: hidden;
}

.touch-ripple::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 5px;
  height: 5px;
  background: rgba(255, 255, 255, 0.5);
  border-radius: 50%;
  transform: scale(0);
  animation: touch-ripple 0.6s linear;
  pointer-events: none;
}

/* 長按效果 */
.long-press-feedback {
  position: relative;
}

.long-press-feedback::before {
  content: '';
  position: absolute;
  inset: 0;
  background: radial-gradient(circle, rgba(59, 130, 246, 0.1) 0%, transparent 70%);
  border-radius: inherit;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.long-press-feedback.long-pressing::before {
  opacity: 1;
}

/* 容器查詢基礎設置 */
.container-query-component {
  container-type: inline-size;
  container-name: component;
}

.container-query-card {
  container-type: inline-size;
  container-name: card;
}

.container-query-layout {
  container-type: inline-size;
  container-name: layout;
}

/* 容器查詢響應式工具類 */
.cq-flex-col {
  display: flex;
  flex-direction: column;
}

.cq-flex-row {
  display: flex;
  flex-direction: row;
}

.cq-grid-auto {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}

/* 容器查詢降級策略 */
@supports not (container-type: inline-size) {
  .container-query-component,
  .container-query-card,
  .container-query-layout {
    /* 降級到媒體查詢 */
    width: 100%;
  }
  
  /* 移動端降級 */
  @media (max-width: 640px) {
    .cq-flex-col {
      flex-direction: column;
    }
    .cq-flex-row {
      flex-direction: column;
    }
  }
  
  /* 桌面端降級 */
  @media (min-width: 641px) {
    .cq-flex-row {
      flex-direction: row;
    }
  }
}

/* 支持容器查詢的瀏覽器增強 */
@supports (container-type: inline-size) {
  /* PersonaCard 容器查詢 */
  @container card (min-width: 280px) {
    .persona-card-narrow {
      flex-direction: row;
      align-items: center;
    }
  }
  
  @container card (min-width: 400px) {
    .persona-card-wide {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 1rem;
    }
  }
  
  /* DebateRoom 容器查詢 */
  @container component (min-width: 600px) {
    .debate-room-medium {
      grid-template-columns: 1fr 1fr;
    }
  }
  
  @container component (min-width: 900px) {
    .debate-room-large {
      grid-template-columns: 1fr 2fr 1fr;
    }
  }
  
  /* Navigation 容器查詢 */
  @container layout (min-width: 768px) {
    .nav-horizontal {
      flex-direction: row;
      justify-content: space-between;
    }
  }
}

/* 流體排版系統 */
@layer utilities {
  /* 主標題流體排版 */
  .fluid-heading-1 {
    font-size: clamp(var(--fluid-heading-1-min), 2vw + 1rem, var(--fluid-heading-1-max));
    line-height: clamp(1.2, 1vw + 1.1, 1.4);
    font-weight: 700;
  }
  
  .fluid-heading-2 {
    font-size: clamp(var(--fluid-heading-2-min), 1.5vw + 0.75rem, var(--fluid-heading-2-max));
    line-height: clamp(1.25, 0.75vw + 1.15, 1.35);
    font-weight: 600;
  }
  
  .fluid-heading-3 {
    font-size: clamp(var(--fluid-heading-3-min), 1vw + 0.5rem, var(--fluid-heading-3-max));
    line-height: clamp(1.3, 0.5vw + 1.2, 1.4);
    font-weight: 600;
  }
  
  /* 正文流體排版 */
  .fluid-body {
    font-size: clamp(var(--fluid-body-min), 0.5vw + 0.75rem, var(--fluid-body-max));
    line-height: clamp(1.4, 0.25vw + 1.35, 1.6);
  }
  
  .fluid-small {
    font-size: clamp(var(--fluid-small-min), 0.25vw + 0.7rem, var(--fluid-small-max));
    line-height: clamp(1.3, 0.2vw + 1.25, 1.5);
  }
  
  /* 流體間距 */
  .fluid-space-xs {
    margin: clamp(0.25rem, 0.5vw, 0.5rem);
  }
  
  .fluid-space-sm {
    margin: clamp(0.5rem, 1vw, 1rem);
  }
  
  .fluid-space-md {
    margin: clamp(1rem, 2vw, 2rem);
  }
  
  .fluid-space-lg {
    margin: clamp(1.5rem, 3vw, 3rem);
  }
  
  .fluid-space-xl {
    margin: clamp(2rem, 4vw, 4rem);
  }
  
  /* 流體內邊距 */
  .fluid-padding-xs {
    padding: clamp(0.25rem, 0.5vw, 0.5rem);
  }
  
  .fluid-padding-sm {
    padding: clamp(0.5rem, 1vw, 1rem);
  }
  
  .fluid-padding-md {
    padding: clamp(1rem, 2vw, 2rem);
  }
  
  .fluid-padding-lg {
    padding: clamp(1.5rem, 3vw, 3rem);
  }
  
  /* 流體間隙 */
  .fluid-gap-xs {
    gap: clamp(0.25rem, 0.5vw, 0.5rem);
  }
  
  .fluid-gap-sm {
    gap: clamp(0.5rem, 1vw, 1rem);
  }
  
  .fluid-gap-md {
    gap: clamp(1rem, 2vw, 2rem);
  }
  
  .fluid-gap-lg {
    gap: clamp(1.5rem, 3vw, 3rem);
  }
}

/* 流體排版可訪問性增強 */
@media (prefers-reduced-motion: reduce) {
  .fluid-heading-1,
  .fluid-heading-2,
  .fluid-heading-3,
  .fluid-body,
  .fluid-small {
    transition: none;
  }
}

/* 高對比度模式支持 */
@media (prefers-contrast: high) {
  .fluid-heading-1,
  .fluid-heading-2,
  .fluid-heading-3 {
    font-weight: 800;
  }
}

/* 高級佈局系統 */
@layer utilities {
  /* 主佈局 Grid */
  .layout-grid-main {
    display: grid;
    grid-template-areas:
      "header header header"
      "sidebar main aside"
      "footer footer footer";
    grid-template-columns: 250px 1fr 200px;
    grid-template-rows: auto 1fr auto;
    min-height: 100vh;
    gap: 1rem;
  }
  
  .layout-grid-simple {
    display: grid;
    grid-template-areas:
      "header"
      "main"
      "footer";
    grid-template-columns: 1fr;
    grid-template-rows: auto 1fr auto;
    min-height: 100vh;
    gap: 1rem;
  }
  
  /* 網格區域 */
  .grid-area-header { grid-area: header; }
  .grid-area-sidebar { grid-area: sidebar; }
  .grid-area-main { grid-area: main; }
  .grid-area-aside { grid-area: aside; }
  .grid-area-footer { grid-area: footer; }
  
  /* 自適應卡片網格 */
  .card-grid-auto {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: clamp(1rem, 2vw, 2rem);
    padding: clamp(1rem, 3vw, 3rem);
  }
  
  .card-grid-responsive {
    display: grid;
    gap: clamp(1rem, 2vw, 2rem);
    grid-template-columns: repeat(auto-fit, minmax(min(280px, 100%), 1fr));
  }
  
  /* Flexbox 佈局工具 */
  .flex-center {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .flex-between {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  
  .flex-start {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
  }
  
  .flex-end {
    display: flex;
    align-items: flex-end;
    justify-content: flex-end;
  }
  
  /* 響應式 Flexbox */
  .flex-col-mobile {
    display: flex;
    flex-direction: column;
  }
  
  @media (min-width: 640px) {
    .flex-col-mobile {
      flex-direction: row;
    }
  }
  
  /* 內容區域佈局 */
  .content-area {
    display: flex;
    flex-direction: column;
    gap: clamp(1rem, 2vw, 2rem);
    padding: clamp(1rem, 3vw, 3rem);
  }
  
  /* 側邊欄佈局 */
  .sidebar-layout {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  @media (min-width: 1024px) {
    .sidebar-layout {
      grid-template-columns: 250px 1fr;
    }
  }
  
  /* 三欄佈局 */
  .three-column-layout {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  @media (min-width: 768px) {
    .three-column-layout {
      grid-template-columns: 1fr 1fr;
    }
  }
  
  @media (min-width: 1200px) {
    .three-column-layout {
      grid-template-columns: 1fr 2fr 1fr;
    }
  }
}

/* 響應式佈局調整 */
@media (max-width: 1024px) {
  .layout-grid-main {
    grid-template-areas:
      "header"
      "main"
      "footer";
    grid-template-columns: 1fr;
  }
  
  .card-grid-auto {
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  }
}

@media (max-width: 640px) {
  .card-grid-auto {
    grid-template-columns: 1fr;
    padding: 1rem;
    gap: 1rem;
  }
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { WebVitalsProvider } from "@/components/WebVitalsProvider";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Virtual Meeting Room",
  description: "AI-powered virtual meeting room with intelligent debate system",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="zh-TW">
      <body className={`${inter.className} antialiased`}>
        <WebVitalsProvider>
          {children}
        </WebVitalsProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
'use client';

import { useMeetingRoomStore } from '@/stores/enhancedMeetingRoomStore';
import { DebateRoom } from '@/components';
import { Users, MessageSquare, Settings, Plus } from 'lucide-react';

export default function Home() {
  const { rooms, createRoom, selectRoom, currentRoom } = useMeetingRoomStore();

  const handleCreateRoom = () => {
    const roomName = prompt('請輸入會議室名稱：');
    
    if (roomName && roomName.trim()) {
      // 不再要求輸入議題，將在第一個發言後自動生成
      const roomId = createRoom(roomName.trim());
      selectRoom(roomId);
    }
  };

  // 如果有選中的房間，顯示辯論界面
  if (currentRoom) {
    return (
      <DebateRoom 
        room={currentRoom}
        onRoomUpdate={(updatedRoom) => {
          // 使用 store 的 updateRoom 方法更新房間
          useMeetingRoomStore.getState().updateRoom(updatedRoom.id, updatedRoom);
        }}
        onDebateComplete={(result) => {
          console.log('辯論完成:', result);
        }}
      />
    );
  }

  return (
    <div className="layout-grid-simple min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
      <header className="grid-area-header">
        <div className="content-area text-center">
          <h1 className="fluid-heading-1 font-bold text-gray-900 fluid-space-md">
            虛擬會議室
          </h1>
          <p className="fluid-body text-gray-600 max-w-2xl mx-auto">
            AI 驅動的智能辯論平台，讓不同角色的虛擬替身針對議題進行深度討論並達成共識
          </p>
        </div>
      </header>

      <main className="grid-area-main">
        <div className="content-area">
          {/* Quick Stats */}
          <div className="card-grid-responsive">
            <div className="bg-white rounded-lg shadow-md fluid-padding-lg text-center">
              <Users className="w-8 h-8 text-blue-600 mx-auto mb-2" />
              <h3 className="fluid-heading-3 font-semibold text-gray-900">6 個預設替身</h3>
              <p className="fluid-small text-gray-600">CEO、CTO、CFO 等專業角色</p>
            </div>
            <div className="bg-white rounded-lg shadow-md fluid-padding-lg text-center">
              <MessageSquare className="w-8 h-8 text-green-600 mx-auto mb-2" />
              <h3 className="fluid-heading-3 font-semibold text-gray-900">智能辯論</h3>
              <p className="fluid-small text-gray-600">基於 Chain of Thought 推理</p>
            </div>
            <div className="bg-white rounded-lg shadow-md fluid-padding-lg text-center">
              <Settings className="w-8 h-8 text-purple-600 mx-auto mb-2" />
              <h3 className="fluid-heading-3 font-semibold text-gray-900">即時搜尋</h3>
              <p className="fluid-small text-gray-600">Google Search grounding 支援</p>
            </div>
          </div>

          {/* Meeting Rooms */}
          <div className="bg-white rounded-lg shadow-md fluid-padding-lg">
            <div className="flex-between fluid-space-md">
              <h2 className="fluid-heading-2 font-bold text-gray-900">會議室</h2>
              <button
                onClick={handleCreateRoom}
                className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors"
              >
                <Plus className="w-4 h-4" />
                創建會議室
              </button>
            </div>

          {rooms.length === 0 ? (
            <div className="text-center py-12">
              <MessageSquare className="w-16 h-16 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-semibold text-gray-900 mb-2">
                還沒有會議室
              </h3>
              <p className="text-gray-600 mb-4">
                創建您的第一個會議室，AI 將根據討論內容自動生成主題
              </p>
              <button
                onClick={handleCreateRoom}
                className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors"
              >
                創建會議室
              </button>
            </div>
          ) : (
            <div className="card-grid-responsive">
              {rooms.map((room) => (
                <div
                  key={room.id}
                  className="border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow cursor-pointer"
                  onClick={() => selectRoom(room.id)}
                >
                  <h3 className="font-semibold text-gray-900 mb-2">
                    {room.name}
                  </h3>
                  <p className="text-gray-600 text-sm mb-3 line-clamp-2">
                    {room.topic || '主題將在開始討論後自動生成'}
                  </p>
                  <div className="flex justify-between items-center text-xs text-gray-500">
                    <span>
                      {room.participants.length} 個參與者
                    </span>
                    <span className={`px-2 py-1 rounded-full ${
                      room.status === 'completed' ? 'bg-green-100 text-green-800' :
                      room.status === 'debating' ? 'bg-blue-100 text-blue-800' :
                      room.status === 'paused' ? 'bg-yellow-100 text-yellow-800' :
                      'bg-gray-100 text-gray-800'
                    }`}>
                      {room.status === 'completed' ? '已完成' :
                       room.status === 'debating' ? '辯論中' :
                       room.status === 'paused' ? '已暫停' :
                       '待開始'}
                    </span>
                  </div>
                </div>
              ))}
            </div>
          )}
          </div>
        </div>
      </main>

      <footer className="grid-area-footer">
        <div className="content-area text-center">
          <p className="fluid-small text-gray-600">© 2024 Virtual Meeting Room. Powered by Gemini AI.</p>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="src/components/DebateRoom.tsx">
import React, { useState, useEffect } from 'react';
import { MeetingRoom, Persona } from '@/types';
import { useDebateControl } from '@/hooks/useDebateOrchestrator';
import { useSwipe } from '../hooks/useSwipe';
import { useMeetingRoomStore } from '@/stores';
import { DebateViewer } from './DebateViewer';
import { DebateControlPanel } from './DebateControlPanel';
import { ConsensusDisplay } from './ConsensusDisplay';
import { PersonaManager } from './PersonaManager';
import { PersonaSelectionPanel } from './PersonaSelectionPanel';
import { ModeratorSelectionPanel } from './ModeratorSelectionPanel';
import { EditableTopicHeader } from './EditableTopicHeader';
import { MobileNavigation } from './MobileNavigation';

interface DebateRoomProps {
  room: MeetingRoom;
  onRoomUpdate?: (room: MeetingRoom) => void;
  onDebateComplete?: (result: unknown) => void;
}

export const DebateRoom: React.FC<DebateRoomProps> = ({
  room,
  onRoomUpdate,
  
}) => {
  const [activeTab, setActiveTab] = useState<'debate' | 'consensus' | 'participants' | 'selection'>('debate');
  
  
  const tabs = ['selection', 'debate', 'consensus', 'participants'] as const;
  const currentTabIndex = tabs.indexOf(activeTab);

  const {
    debateStatus,
    isLoading,
    error,
    startDebate,
    pauseDebate,
    resumeDebate,
    stopDebate,
  } = useDebateControl();

  const {
    currentRoom,
    currentSpeaker,
    currentRound,
    nextRound,
    reset,
  } = useMeetingRoomStore();

  // 從當前房間獲取數據
  const statements = currentRoom?.statements || [];
  const consensusData = currentRoom?.consensus;

  // 找到當前發言者的 Persona 對象
  const currentSpeakerPersona = currentSpeaker && typeof currentSpeaker === 'string' 
    ? room.participants.find(p => p.id === currentSpeaker) || null
    : (currentSpeaker as Persona | null);

  // 鍵盤快捷鍵
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) {
        return; // 忽略輸入框中的按鍵
      }

      switch (event.code) {
        case 'Space':
          event.preventDefault();
          if (debateStatus === 'debating') {
            pauseDebate();
          } else if (debateStatus === 'paused') {
            resumeDebate();
          }
          break;
        case 'Enter':
          event.preventDefault();
          if (debateStatus === 'debating' && !isLoading) {
            nextRound();
          }
          break;
        case 'Escape':
          event.preventDefault();
          if (debateStatus === 'debating' || debateStatus === 'paused') {
            stopDebate();
          }
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [debateStatus, isLoading, pauseDebate, resumeDebate, nextRound, stopDebate]);

  

  // 滑動手勢處理
  const handleSwipeLeft = () => {
    if (currentTabIndex < tabs.length - 1) {
      setActiveTab(tabs[currentTabIndex + 1]);
    }
  };

  const handleSwipeRight = () => {
    if (currentTabIndex > 0) {
      setActiveTab(tabs[currentTabIndex - 1]);
    }
  };

  // 使用滑動手勢 hook
  useSwipe({
    onSwipeLeft: handleSwipeLeft,
    onSwipeRight: handleSwipeRight,
  }, {
    threshold: 50,
    preventDefaultTouchmoveEvent: false,
  });

  const getTabIcon = (tab: string) => {
    switch (tab) {
      case 'selection': return '🎭';
      case 'debate': return '💬';
      case 'consensus': return '📊';
      case 'participants': return '👥';
      default: return '📄';
    }
  };

  const getTabCount = (tab: string) => {
    switch (tab) {
      case 'selection': return room.participants.length;
      case 'debate': return statements.length;
      case 'participants': return room.participants.length;
      default: return null;
    }
  };

  return (
    <div className="full-height-mobile flex flex-col bg-gray-100 safe-area-mobile">
      {/* 移動端導航組件 */}
      <MobileNavigation
        currentTab={activeTab}
        onTabChange={(tab) => setActiveTab(tab as typeof activeTab)}
        participantCount={room.participants.length}
        statementCount={statements.length}
        onSettingsClick={() => {
          // TODO: Implement mobile settings modal
          console.log('Mobile settings clicked');
        }}
      />
      {/* 頂部標題欄 - 響應式優化 */}
      <div className="bg-white shadow-sm border-b border-gray-200 container-responsive py-4">
        <div className="flex items-center justify-between">
          <div className="flex-1 min-w-0">
            <h1 className="text-lg tablet:text-xl font-semibold text-gray-900 mb-2 prevent-overflow">{room.name}</h1>
            <EditableTopicHeader
              topic={room.topic}
              isGenerated={room.isTopicGenerated}
              onTopicChange={(newTopic) => {
                const updatedRoom = { 
                  ...room, 
                  topic: newTopic,
                  isTopicGenerated: false // 手動編輯後移除AI生成標記
                };
                onRoomUpdate?.(updatedRoom);
              }}
            />
          </div>
          
          <div className="hidden laptop:flex items-center space-x-4 flex-shrink-0">
            {error && (
              <div className="flex items-center text-red-600 text-sm">
                <span className="mr-2">⚠️</span>
                {error}
              </div>
            )}
            
            <div className="text-sm text-gray-500">
              創建時間: <span className="font-medium">{new Date(room.createdAt).toLocaleDateString()}</span>
            </div>
          </div>
          
          {/* 移動端錯誤顯示 */}
          {error && (
            <div className="laptop:hidden flex items-center text-red-600 text-xs">
              <span className="mr-1">⚠️</span>
            </div>
          )}
        </div>
      </div>

      {/* 標籤導航 - 響應式優化 */}
      <div className="bg-white border-b border-gray-200 nav-desktop">
        <div className="container-responsive">
          <nav className="flex space-x-4 tablet:space-x-8 overflow-x-auto">
            {(['selection', 'debate', 'consensus', 'participants'] as const).map((tab) => {
              const count = getTabCount(tab);
              return (
                <button
                  key={tab}
                  onClick={() => setActiveTab(tab)}
                  className={`btn-touch py-3 tablet:py-4 px-2 tablet:px-3 border-b-2 font-medium text-xs tablet:text-sm transition-colors whitespace-nowrap ${
                    activeTab === tab
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  }`}
                >
                  <span className="flex items-center space-x-1 tablet:space-x-2">
                    <span className="text-sm tablet:text-base">{getTabIcon(tab)}</span>
                    <span className="hidden tablet:inline">
                      {tab === 'selection' && '人格選擇'}
                      {tab === 'debate' && '辯論過程'}
                      {tab === 'consensus' && '共識分析'}
                      {tab === 'participants' && '參與者'}
                    </span>
                    <span className="tablet:hidden text-xs">
                      {tab === 'selection' && '選擇'}
                      {tab === 'debate' && '辯論'}
                      {tab === 'consensus' && '共識'}
                      {tab === 'participants' && '參與'}
                    </span>
                    {count !== null && (
                      <span className={`px-1 tablet:px-2 py-0.5 tablet:py-1 rounded-full text-xs ${
                        activeTab === tab
                          ? 'bg-blue-100 text-blue-600'
                          : 'bg-gray-100 text-gray-600'
                      }`}>
                        {count}
                      </span>
                    )}
                  </span>
                </button>
              );
            })}
          </nav>
        </div>
      </div>

      {/* 主要內容區域 - 響應式布局 */}
      <div className="flex-1 flex overflow-hidden">
        {/* 主要內容 - 移動端全屏，平板端和桌面端左側 */}
        <div className="flex-1 flex flex-col tablet:w-auto laptop:flex-1">
          {activeTab === 'selection' && (
            <div className="flex-1 flex flex-col overflow-hidden">
              <div className="flex-1 container-responsive py-4 overflow-hidden">
                <div className="h-full flex flex-col spacing-responsive">
                {/* 主持人選擇區域 */}
                <ModeratorSelectionPanel
                  availablePersonas={useMeetingRoomStore.getState().availablePersonas}
                  selectedModerator={room.moderator}
                  onModeratorSelect={(moderator) => {
                    const updatedRoom = { ...room, moderator };
                    onRoomUpdate?.(updatedRoom);
                  }}
                />

                {/* 參與者選擇區域 */}
                <PersonaSelectionPanel
                  availablePersonas={useMeetingRoomStore.getState().availablePersonas}
                  selectedPersonas={room.participants}
                  onPersonaToggle={(persona) => {
                    const isSelected = room.participants.some(p => p.id === persona.id);
                    let updatedParticipants;
                    
                    if (isSelected) {
                      // 移除人格
                      updatedParticipants = room.participants.filter(p => p.id !== persona.id);
                    } else {
                      // 添加人格
                      updatedParticipants = [...room.participants, persona];
                    }
                    
                    const updatedRoom = { ...room, participants: updatedParticipants };
                    onRoomUpdate?.(updatedRoom);
                  }}
                  maxPersonas={6}
                  className="flex-1"
                />
              </div>
              </div>
            </div>
          )}

          {activeTab === 'debate' && (
            <div className="flex-1 container-responsive py-4">
              <DebateViewer
              statements={statements}
              currentSpeaker={currentSpeakerPersona}
              debateStatus={debateStatus}
              currentRound={currentRound}
              loading={isLoading}
              
            />
            </div>
          )}

          {activeTab === 'consensus' && (
            <div className="flex-1 container-responsive py-4">
              <ConsensusDisplay
                consensusData={consensusData}
                statements={statements}
                className="h-full"
              />
            </div>
          )}

          {activeTab === 'participants' && (
            <div className="flex-1 container-responsive py-4">
              <PersonaManager
                personas={room.participants}
                onPersonasChange={(personas) => {
                  const updatedRoom = { ...room, participants: personas };
                  onRoomUpdate?.(updatedRoom);
                }}
                disabled={debateStatus === 'debating'}
              />
            </div>
          )}
        </div>

        {/* 右側控制面板 - 桌面端顯示，移動端隱藏 */}
        <div className="hidden laptop:block w-80 border-l border-gray-200 bg-gray-50 p-6">
          <DebateControlPanel
            debateStatus={debateStatus}
            currentRound={currentRound}
            totalStatements={statements.length}
            loading={isLoading}
            onStart={(initialTopic) => {
              // 如果提供了初始議題，先更新房間主題
              if (initialTopic && initialTopic.trim()) {
                const updatedRoom = { 
                  ...room, 
                  topic: initialTopic.trim(),
                  isTopicGenerated: false // 用戶提供的主題不標記為AI生成
                };
                onRoomUpdate?.(updatedRoom);
              }
              startDebate(initialTopic);
            }}
            onPause={pauseDebate}
            onResume={resumeDebate}
            onStop={stopDebate}
            onNextRound={nextRound}
            onReset={() => reset()}
            disabled={room.participants.length < 2}
          />

          {/* 快速統計 */}
          <div className="mt-6 bg-white rounded-lg shadow p-4">
            <h4 className="font-medium text-gray-900 mb-3">快速統計</h4>
            <div className="space-y-2 text-sm">
              <div className="flex justify-between">
                <span className="text-gray-600">參與者數量</span>
                <span className="font-medium">{room.participants.length}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-600">當前輪次</span>
                <span className="font-medium">{currentRound}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-600">總發言數</span>
                <span className="font-medium">{statements.length}</span>
              </div>
              {statements.length > 0 && (
                <div className="flex justify-between">
                  <span className="text-gray-600">平均傾向度</span>
                  <span className="font-medium">
                    {(statements.reduce((sum, s) => sum + s.tendencyScore, 0) / statements.length).toFixed(1)}/10
                  </span>
                </div>
              )}
            </div>
          </div>

          {/* 當前發言者信息 */}
          {currentSpeakerPersona && (
            <div className="mt-6 bg-white rounded-lg shadow p-4">
              <h4 className="font-medium text-gray-900 mb-3">當前發言者</h4>
              <div className="flex items-center space-x-3">
                <div className="w-10 h-10 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center text-white font-bold">
                  {currentSpeakerPersona.name.charAt(0)}
                </div>
                <div>
                  <p className="font-medium text-gray-900">{currentSpeakerPersona.name}</p>
                  <p className="text-xs text-gray-500">{currentSpeakerPersona.role}</p>
                </div>
              </div>
              <div className="mt-3 text-xs text-gray-600">
                <p>專業領域: {currentSpeakerPersona.ragFocus.join(', ')}</p>
                <p>創造性: {(currentSpeakerPersona.temperature * 100).toFixed(0)}%</p>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* 移動端底部導航 */}
      <div className="nav-mobile">
        <div className="flex justify-around items-center">
          {(['selection', 'debate', 'consensus', 'participants'] as const).map((tab) => {
            const count = getTabCount(tab);
            return (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                className={`btn-touch flex flex-col items-center justify-center py-2 px-1 rounded-lg transition-colors relative ${
                  activeTab === tab
                    ? 'bg-blue-50 text-blue-600'
                    : 'text-gray-500 hover:text-gray-700'
                }`}
              >
                <span className="text-lg mb-1">{getTabIcon(tab)}</span>
                <span className="text-xs font-medium">
                  {tab === 'selection' && '選擇'}
                  {tab === 'debate' && '辯論'}
                  {tab === 'consensus' && '共識'}
                  {tab === 'participants' && '參與'}
                </span>
                {count !== null && count > 0 && (
                  <span className={`absolute -top-1 -right-1 px-1 py-0.5 rounded-full text-xs ${
                    activeTab === tab
                      ? 'bg-blue-500 text-white'
                      : 'bg-gray-400 text-white'
                  }`}>
                    {count}
                  </span>
                )}
              </button>
            );
          })}
        </div>
        
        {/* 滑動指示器 */}
        <div className="flex justify-center mt-1">
          <div className="flex space-x-1">
            {tabs.map((_, index) => (
              <div
                key={index}
                className={`w-1 h-1 rounded-full transition-colors ${
                  index === currentTabIndex ? 'bg-blue-500' : 'bg-gray-300'
                }`}
              />
            ))}
          </div>
        </div>
      </div>

      {/* 浮動操作按鈕 - 移動端和平板端顯示 */}
      {(debateStatus === 'idle' || debateStatus === 'paused') && room.participants.length >= 2 && (
        <button
          onClick={() => {
            if (debateStatus === 'idle') {
              startDebate();
            } else if (debateStatus === 'paused') {
              resumeDebate();
            }
          }}
          className="fab laptop:hidden"
          disabled={isLoading}
        >
          {debateStatus === 'idle' ? '▶️' : '▶️'}
        </button>
      )}

      {debateStatus === 'debating' && (
        <button
          onClick={pauseDebate}
          className="fab laptop:hidden"
          disabled={isLoading}
        >
          ⏸️
        </button>
      )}
    </div>
  );
};
</file>

<file path="src/services/geminiService.ts">
import { GoogleGenerativeAI, GenerativeModel } from '@google/generative-ai';
import { Persona, DebateContext, GeminiResponse, SourceReference } from '@/types';
import { PersonaEngine } from './personaEngine';
import { SourceProcessor, GeminiErrorHandler, GeminiCache } from './geminiUtils';

class GeminiService {
  private genAI: GoogleGenerativeAI;
  private model: GenerativeModel;

  constructor() {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY is not configured');
    }
    
    this.genAI = new GoogleGenerativeAI(apiKey);
    this.model = this.genAI.getGenerativeModel({
      model: "gemini-2.0-flash-exp",
    });
  }

  /**
   * 建構替身的完整提示詞
   */
  private buildPersonaPrompt(
    persona: Persona,
    context: DebateContext,
    searchResults?: SourceReference[]
  ): string {
    return PersonaEngine.buildPersonaPrompt(persona, context, searchResults);
  }

  /**
   * 解析 Gemini 回應
   */
  private parseGeminiResponse(response: import('@/types/gemini').GeminiApiResponse): import('@/types/gemini').GeminiResponse {
    try {
      const content = response.response?.text() || '';
      
      // 使用 PersonaEngine 解析回應
      const parsed = PersonaEngine.parsePersonaResponse(content);
      
      // 使用 SourceProcessor 處理來源資訊
      const sources = SourceProcessor.processGroundingMetadata(response);
      const validatedSources = SourceProcessor.validateSources(sources);
      
      // 安全地獲取 groundingMetadata
      const groundingMetadata = response.response?.candidates?.[0]?.groundingMetadata;
      
      // 添加內聯引用
      const contentWithCitations = groundingMetadata 
        ? SourceProcessor.addInlineCitations(parsed.cleanContent, groundingMetadata)
        : parsed.cleanContent;

      return {
        content: contentWithCitations,
        tendencyScore: parsed.tendencyScore,
        reasoning: parsed.reasoning,
        sources: validatedSources,
        searchQueries: groundingMetadata 
          ? SourceProcessor.extractSearchQueries(groundingMetadata)
          : [],
      };
    } catch (error) {
      console.error('Error parsing Gemini response:', error);
      return {
        content: '抱歉，我在處理回應時遇到了問題。',
        tendencyScore: 5,
        error: GeminiErrorHandler.formatError(error),
      };
    }
  }

  /**
   * 生成替身回應
   */
  async generatePersonaResponse(
    persona: Persona,
    context: DebateContext,
    searchResults?: SourceReference[]
  ): Promise<GeminiResponse> {
    // 檢查快取
    const cacheKey = GeminiCache.generateKey(
      'persona_response',
      persona.id,
      context.topic,
      context.previousStatements.length
    );
    
    const cached = GeminiCache.get<GeminiResponse>(cacheKey);
    if (cached) {
      return cached;
    }

    return GeminiErrorHandler.withRetry(async () => {
      const prompt = this.buildPersonaPrompt(persona, context, searchResults);
      
      const result = await this.model.generateContent({
        contents: [{ role: 'user', parts: [{ text: prompt }] }],
        tools: [{ googleSearchRetrieval: {} }],
        generationConfig: {
          temperature: persona.temperature,
          maxOutputTokens: 800,
          topP: 0.8,
          topK: 40,
        },
      });

      // 轉換為相容的格式
      const compatibleResult = {
        response: {
          text: () => result.response?.text() || '',
          candidates: result.response?.candidates
        }
      };

      const response = this.parseGeminiResponse(compatibleResult);
      
      // 快取成功的回應（較短的 TTL，因為辯論內容時效性強）
      GeminiCache.set(cacheKey, response, 2 * 60 * 1000); // 2 分鐘
      
      return response;
    }, `生成 ${persona.name} 的回應`);
  }

  /**
   * 執行議題相關搜尋
   */
  async searchTopicInformation(
    topic: string,
    personaFocuses: string[]
  ): Promise<SourceReference[]> {
    // 檢查快取
    const cacheKey = GeminiCache.generateKey('topic_search', topic, personaFocuses);
    const cached = GeminiCache.get<SourceReference[]>(cacheKey);
    if (cached) {
      return cached;
    }

    return GeminiErrorHandler.withRetry(async () => {
      const searchQuery = `${topic} ${personaFocuses.join(' ')}`;
      
      const result = await this.model.generateContent({
        contents: [{ 
          role: 'user', 
          parts: [{ text: `請搜尋關於「${searchQuery}」的最新資訊和數據，重點關注：${personaFocuses.join('、')}` }] 
        }],
        tools: [{ googleSearchRetrieval: {} }],
        generationConfig: {
          temperature: 0.3,
          maxOutputTokens: 500,
        },
      });

      // 轉換為相容的格式
      const compatibleResult = {
        response: {
          text: () => result.response?.text() || '',
          candidates: result.response?.candidates
        }
      };

      const sources = SourceProcessor.processGroundingMetadata(compatibleResult);
      const validatedSources = SourceProcessor.validateSources(sources);
      
      // 快取搜尋結果（較長的 TTL，因為搜尋結果相對穩定）
      GeminiCache.set(cacheKey, validatedSources, 10 * 60 * 1000); // 10 分鐘
      
      return validatedSources;
    }, '搜尋議題資訊');
  }

  /**
   * 分析議題並生成搜尋關鍵詞
   */
  async analyzeTopicAndGenerateKeywords(
    topic: string,
    personas: Persona[]
  ): Promise<string[]> {
    // 檢查快取
    const cacheKey = GeminiCache.generateKey('topic_keywords', topic, personas.map(p => p.id));
    const cached = GeminiCache.get<string[]>(cacheKey);
    if (cached) {
      return cached;
    }

    try {
      return await GeminiErrorHandler.withRetry(async () => {
        // 使用 PersonaEngine 生成基礎關鍵詞
        const baseKeywords = personas.flatMap(persona => 
          PersonaEngine.generateSearchKeywords(persona, topic)
        );
        
        const uniqueKeywords = [...new Set(baseKeywords)];
        
        const prompt = `
分析以下辯論議題，並根據參與者的專業領域生成 3-5 個最相關的搜尋關鍵詞：

議題：${topic}

參與者專業領域：${personas.map(p => p.identity).join('、')}

現有關鍵詞：${uniqueKeywords.join(', ')}

請提供能夠獲得最新、最相關資訊的搜尋關鍵詞，每行一個，不要包含編號或冒號：
`;

        const result = await this.model.generateContent({
          contents: [{ role: 'user', parts: [{ text: prompt }] }],
          tools: [{ googleSearchRetrieval: {} }],
          generationConfig: {
            temperature: 0.4,
            maxOutputTokens: 200,
          },
        });

        const content = result.response?.text() || '';
        const aiKeywords = content
          .split('\n')
          .map((line: string) => line.trim())
          .filter((line: string) => line.length > 0 && !line.includes('：') && !line.match(/^\d+\./))
          .slice(0, 5);

        // 合併 AI 生成的關鍵詞和基礎關鍵詞
        const allKeywords = [...new Set([...aiKeywords, ...uniqueKeywords])];
        const finalKeywords = allKeywords.slice(0, 8);
        
        // 快取關鍵詞
        GeminiCache.set(cacheKey, finalKeywords, 15 * 60 * 1000); // 15 分鐘
        
        return finalKeywords;
      }, '分析議題並生成關鍵詞');
    } catch (error) {
      console.error('Error analyzing topic:', error);
      // 降級處理：使用 PersonaEngine 生成的關鍵詞
      const fallbackKeywords = personas.flatMap(persona => 
        PersonaEngine.generateSearchKeywords(persona, topic)
      );
      return [...new Set(fallbackKeywords)].slice(0, 5);
    }
  }
}

// 單例模式
let geminiService: GeminiService | null = null;

export const getGeminiService = (): GeminiService => {
  if (!geminiService) {
    geminiService = new GeminiService();
  }
  return geminiService;
};

export default GeminiService;
</file>

<file path="src/services/geminiUtils.ts">
import { SourceReference } from '@/types';

/**
 * 來源引用處理工具
 */
export class SourceProcessor {
  /**
   * 處理 Gemini 回應中的來源引用
   */
  static processGroundingMetadata(response: import('@/types/gemini').GeminiApiResponse): import('@/types/gemini').SourceReference[] {
    const sources: SourceReference[] = [];
    
    try {
      const groundingMetadata = response.response?.candidates?.[0]?.groundingMetadata;
      if (!groundingMetadata?.groundingChunks) {
        return sources;
      }

      const chunks = groundingMetadata.groundingChunks;
      chunks.forEach((chunk: import('@/types/gemini').GroundingChunk, index: number) => {
        if (chunk.web && chunk.web.uri) {
          sources.push({
            url: chunk.web.uri,
            title: chunk.web.title || `來源 ${index + 1}`,
            snippet: chunk.web.snippet || '',
            relevanceScore: chunk.relevanceScore || 0.5,
          });
        }
      });

      // 按相關性分數排序
      sources.sort((a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0));
      
      return sources;
    } catch (error) {
      console.error('Error processing grounding metadata:', error);
      return sources;
    }
  }

  /**
   * 為文本添加內聯引用
   */
  static addInlineCitations(text: string, groundingMetadata: import('@/types/gemini').GroundingMetadata): string {
    try {
      if (!groundingMetadata?.groundingSupports || !groundingMetadata?.groundingChunks) {
        return text;
      }

      const supports = groundingMetadata.groundingSupports;
      const chunks = groundingMetadata.groundingChunks;

      // 按結束位置降序排序，避免插入時位置偏移
      const sortedSupports = [...supports].sort(
        (a, b) => (b.segment?.endIndex ?? 0) - (a.segment?.endIndex ?? 0)
      );

      let processedText = text;

      for (const support of sortedSupports) {
        const endIndex = support.segment?.endIndex;
        if (endIndex === undefined || !support.groundingChunkIndices?.length) {
          continue;
        }

        const citationLinks = support.groundingChunkIndices
          .map((i: number) => {
            const uri = chunks[i]?.web?.uri;
            const title = chunks[i]?.web?.title || `來源 ${i + 1}`;
            if (uri) {
              return `[${i + 1}](${uri} "${title}")`;
            }
            return null;
          })
          .filter(Boolean);

        if (citationLinks.length > 0) {
          const citationString = ` ${citationLinks.join(', ')}`;
          processedText = processedText.slice(0, endIndex) + citationString + processedText.slice(endIndex);
        }
      }

      return processedText;
    } catch (error) {
      console.error('Error adding inline citations:', error);
      return text;
    }
  }

  /**
   * 提取搜尋查詢
   */
  static extractSearchQueries(groundingMetadata: import('@/types/gemini').GroundingMetadata): string[] {
    try {
      return groundingMetadata?.webSearchQueries || [];
    } catch (error) {
      console.error('Error extracting search queries:', error);
      return [];
    }
  }

  /**
   * 驗證來源的可靠性
   */
  static validateSources(sources: SourceReference[]): SourceReference[] {
    return sources.filter(source => {
      // 基本驗證
      if (!source.url || !source.title) {
        return false;
      }

      // URL 格式驗證
      try {
        new URL(source.url);
      } catch {
        return false;
      }

      // 相關性分數驗證
      if (source.relevanceScore !== undefined && source.relevanceScore < 0.3) {
        return false;
      }

      return true;
    });
  }

  /**
   * 格式化來源列表為顯示用
   */
  static formatSourcesForDisplay(sources: SourceReference[]): string {
    if (sources.length === 0) {
      return '無參考來源';
    }

    return sources
      .map((source, index) => {
        const domain = new URL(source.url).hostname;
        return `${index + 1}. [${source.title}](${source.url}) - ${domain}`;
      })
      .join('\n');
  }

  /**
   * 生成來源摘要
   */
  static generateSourceSummary(sources: SourceReference[]): {
    totalSources: number;
    domains: string[];
    averageRelevance: number;
  } {
    const totalSources = sources.length;
    const domains = [...new Set(sources.map(source => {
      try {
        return new URL(source.url).hostname;
      } catch {
        return 'unknown';
      }
    }))];

    const relevanceScores = sources
      .map(source => source.relevanceScore || 0.5)
      .filter(score => score > 0);
    
    const averageRelevance = relevanceScores.length > 0
      ? relevanceScores.reduce((sum, score) => sum + score, 0) / relevanceScores.length
      : 0;

    return {
      totalSources,
      domains,
      averageRelevance,
    };
  }
}

/**
 * 錯誤處理和重試機制
 */
export class GeminiErrorHandler {
  private static readonly MAX_RETRIES = 3;
  private static readonly RETRY_DELAYS = [1000, 2000, 4000]; // 指數退避

  /**
   * 帶重試的 API 呼叫
   */
  static async withRetry<T>(
    operation: () => Promise<T>,
    context: string = 'API call'
  ): Promise<T> {
    let lastError: Error = new Error('Unknown error');

    for (let attempt = 0; attempt < this.MAX_RETRIES; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        
        console.warn(`${context} failed (attempt ${attempt + 1}/${this.MAX_RETRIES}):`, error);

        // 檢查是否應該重試
        if (!this.shouldRetry(error as Error) || attempt === this.MAX_RETRIES - 1) {
          break;
        }

        // 等待後重試
        await this.delay(this.RETRY_DELAYS[attempt]);
      }
    }

    throw new Error(`${context} failed after ${this.MAX_RETRIES} attempts: ${lastError.message}`);
  }

  /**
   * 判斷錯誤是否應該重試
   */
  private static shouldRetry(error: Error): boolean {
    const retryableErrors = [
      'RATE_LIMIT_EXCEEDED',
      'INTERNAL_ERROR',
      'SERVICE_UNAVAILABLE',
      'TIMEOUT',
      'NETWORK_ERROR',
    ];

    return retryableErrors.some(errorType => 
      error.message.includes(errorType) || 
      error.name.includes(errorType)
    );
  }

  /**
   * 延遲函數
   */
  private static delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * 格式化錯誤訊息
   */
  static formatError(error: unknown): string {
    if (error instanceof Error) {
      // 處理常見的 Gemini API 錯誤
      if (error.message.includes('API_KEY')) {
        return 'API 金鑰配置錯誤，請檢查環境變數設定';
      }
      if (error.message.includes('RATE_LIMIT')) {
        return 'API 呼叫頻率過高，請稍後再試';
      }
      if (error.message.includes('QUOTA_EXCEEDED')) {
        return 'API 配額已用完，請檢查計費設定';
      }
      if (error.message.includes('INVALID_ARGUMENT')) {
        return '請求參數無效，請檢查輸入內容';
      }
      
      return error.message;
    }
    
    if (typeof error === 'string') {
      return error;
    }
    
    return '發生未知錯誤';
  }
}

/**
 * 快取管理
 */
export class GeminiCache {
  private static cache = new Map<string, { data: unknown; timestamp: number; ttl: number }>();
  private static readonly DEFAULT_TTL = 5 * 60 * 1000; // 5 分鐘

  /**
   * 設定快取
   */
  static set(key: string, data: unknown, ttl: number = this.DEFAULT_TTL): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl,
    });
  }

  /**
   * 獲取快取
   */
  static get<T>(key: string): T | null {
    const item = this.cache.get(key);
    if (!item) {
      return null;
    }

    // 檢查是否過期
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }

    return item.data as T;
  }

  /**
   * 清除過期快取
   */
  static cleanup(): void {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.ttl) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * 清除所有快取
   */
  static clear(): void {
    this.cache.clear();
  }

  /**
   * 生成快取鍵
   */
  static generateKey(prefix: string, ...params: unknown[]): string {
    return `${prefix}:${params.map(p => JSON.stringify(p)).join(':')}`;
  }
}

// 定期清理快取
setInterval(() => {
  GeminiCache.cleanup();
}, 60000); // 每分鐘清理一次
</file>

<file path="src/stores/additionalStores.ts">
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

/**
 * 辯論記錄接口
 */
export interface DebateRecord {
  id: string;
  roomId: string;
  roomName: string;
  topic: string;
  participants: string[];
  startTime: number;
  endTime?: number;
  totalRounds: number;
  finalConsensus?: {
    supportRate: number;
    opposeRate: number;
    consensusReached: boolean;
  };
  keyInsights: string[];
}

/**
 * 通知接口
 */
export interface Notification {
  id: string;
  type: 'info' | 'warning' | 'error' | 'success';
  title: string;
  message: string;
  timestamp: number;
  read: boolean;
  autoHide?: boolean;
  duration?: number;
}

/**
 * 辯論歷史和分析存儲
 */
interface DebateHistoryState {
  // 歷史記錄
  debateHistory: DebateRecord[];
  
  // 分析數據
  analytics: {
    totalDebates: number;
    averageRounds: number;
    consensusRate: number;
    mostActivePersonas: Array<{ personaId: string; participationCount: number }>;
    topTopics: Array<{ topic: string; debateCount: number }>;
  };
  
  // Actions
  addDebateRecord: (record: DebateRecord) => void;
  getDebatesByTopic: (topic: string) => DebateRecord[];
  getDebatesByPersona: (personaId: string) => DebateRecord[];
  getAnalytics: () => Record<string, unknown>;
  clearHistory: () => void;
  exportHistory: () => string;
  importHistory: (data: string) => boolean;
}

export const useDebateHistoryStore = create<DebateHistoryState>()(
  devtools(
    (set, get) => ({
      debateHistory: [],
      analytics: {
        totalDebates: 0,
        averageRounds: 0,
        consensusRate: 0,
        mostActivePersonas: [],
        topTopics: []
      },
      
      addDebateRecord: (record: DebateRecord) => {
        set((state) => {
          const newHistory = [...state.debateHistory, record];
          return {
            debateHistory: newHistory,
            analytics: calculateAnalytics(newHistory)
          };
        });
      },
      
      getDebatesByTopic: (topic: string) => {
        return get().debateHistory.filter(debate => 
          debate.topic.toLowerCase().includes(topic.toLowerCase())
        );
      },
      
      getDebatesByPersona: (personaId: string) => {
        return get().debateHistory.filter(debate => 
          debate.participants.includes(personaId)
        );
      },
      
      getAnalytics: () => {
        return get().analytics;
      },
      
      clearHistory: () => {
        set({
          debateHistory: [],
          analytics: {
            totalDebates: 0,
            averageRounds: 0,
            consensusRate: 0,
            mostActivePersonas: [],
            topTopics: []
          }
        });
      },
      
      exportHistory: () => {
        const data = {
          debateHistory: get().debateHistory,
          exportTime: Date.now(),
          version: '1.0'
        };
        return JSON.stringify(data, null, 2);
      },
      
      importHistory: (data: string) => {
        try {
          const parsed = JSON.parse(data);
          if (parsed.debateHistory && Array.isArray(parsed.debateHistory)) {
            const analytics = calculateAnalytics(parsed.debateHistory);
            set({
              debateHistory: parsed.debateHistory,
              analytics
            });
            return true;
          }
          return false;
        } catch {
          return false;
        }
      }
    }),
    {
      name: 'debate-history-store'
    }
  )
);

/**
 * 計算分析數據
 */
function calculateAnalytics(history: DebateRecord[]) {
  const totalDebates = history.length;
  
  if (totalDebates === 0) {
    return {
      totalDebates: 0,
      averageRounds: 0,
      consensusRate: 0,
      mostActivePersonas: [],
      topTopics: []
    };
  }
  
  const totalRounds = history.reduce((sum, debate) => sum + debate.totalRounds, 0);
  const averageRounds = totalRounds / totalDebates;
  
  const consensusCount = history.filter(debate => 
    debate.finalConsensus?.consensusReached
  ).length;
  const consensusRate = consensusCount / totalDebates;
  
  // 統計最活躍的替身
  const personaStats: Record<string, number> = {};
  history.forEach(debate => {    debate.participants.forEach(personaId => {
      personaStats[personaId] = (personaStats[personaId] || 0) + 1;
    });
  });
  
  const mostActivePersonas = Object.entries(personaStats)
    .map(([personaId, count]) => ({ personaId, participationCount: count }))
    .sort((a, b) => b.participationCount - a.participationCount)
    .slice(0, 5);
  
  // 統計熱門話題
  const topicStats: Record<string, number> = {};
  history.forEach(debate => {
    topicStats[debate.topic] = (topicStats[debate.topic] || 0) + 1;
  });
  
  const topTopics = Object.entries(topicStats)
    .map(([topic, count]) => ({ topic, debateCount: count }))
    .sort((a, b) => b.debateCount - a.debateCount)
    .slice(0, 10);
  
  return {
    totalDebates,
    averageRounds,
    consensusRate,
    mostActivePersonas,
    topTopics
  };
}

/**
 * 通知系統存儲
 */
interface NotificationState {
  notifications: Notification[];
  
  // Actions
  addNotification: (notification: Notification) => void;
  markAsRead: (id: string) => void;
  removeNotification: (id: string) => void;
  clearAll: () => void;
  getUnreadCount: () => number;
}

export const useNotificationStore = create<NotificationState>()(
  devtools(
    (set, get) => ({
      notifications: [],
      
      addNotification: (notification: Notification) => {
        set((state) => ({
          notifications: [notification, ...state.notifications]
        }));
        
        // 自動隱藏通知
        if (notification.autoHide !== false) {
          const duration = notification.duration || 5000;
          setTimeout(() => {
            get().removeNotification(notification.id);
          }, duration);
        }
      },
      
      markAsRead: (id: string) => {
        set((state) => ({
          notifications: state.notifications.map(notification =>
            notification.id === id 
              ? { ...notification, read: true }
              : notification
          )
        }));
      },
      
      removeNotification: (id: string) => {
        set((state) => ({
          notifications: state.notifications.filter(notification => 
            notification.id !== id
          )
        }));
      },
      
      clearAll: () => {
        set({ notifications: [] });
      },
      
      getUnreadCount: () => {
        return get().notifications.filter(notification => !notification.read).length;
      }
    }),
    {
      name: 'notification-store'
    }
  )
);

/**
 * 用戶偏好設定存儲
 */
interface UserPreferencesState {
  preferences: {
    theme: 'light' | 'dark' | 'auto';
    language: 'zh-TW' | 'zh-CN' | 'en';
    autoSave: boolean;
    notificationSettings: {
      debateStart: boolean;
      debateEnd: boolean;
      consensusReached: boolean;
      newStatement: boolean;
    };
    displaySettings: {
      showTimestamps: boolean;
      showSourceLinks: boolean;
      compactMode: boolean;
    };
  };
  
  // Actions
  updatePreference: <K extends keyof UserPreferencesState['preferences']>(
    key: K, 
    value: UserPreferencesState['preferences'][K]
  ) => void;
  resetToDefaults: () => void;
}

const defaultPreferences: UserPreferencesState['preferences'] = {
  theme: 'auto',
  language: 'zh-TW',
  autoSave: true,
  notificationSettings: {
    debateStart: true,
    debateEnd: true,
    consensusReached: true,
    newStatement: false
  },
  displaySettings: {
    showTimestamps: true,
    showSourceLinks: true,
    compactMode: false
  }
};

export const useUserPreferencesStore = create<UserPreferencesState>()(
  devtools(
    (set) => ({
      preferences: defaultPreferences,
      
      updatePreference: (key, value) => {
        set((state) => ({
          preferences: {
            ...state.preferences,
            [key]: value
          }
        }));
      },
      
      resetToDefaults: () => {
        set({ preferences: defaultPreferences });
      }
    }),
    {
      name: 'user-preferences-store'
    }
  )
);
</file>

<file path="src/hooks/useDebateOrchestrator.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import { DebateOrchestrator, DebateState } from '@/services/debateOrchestrator';
import { MeetingRoom, Statement, ConsensusData } from '@/types';
import { useMeetingRoomStore } from '@/stores';

/**
 * 辯論協調器 Hook - 管理辯論流程和狀態
 */
export const useDebateOrchestrator = () => {
  const orchestratorRef = useRef<DebateOrchestrator | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  
  const {
    currentRoom,
    setDebateStatus,
    setCurrentSpeaker,
    addStatement,
    updateConsensus,
    setError,
    setLoading,
    nextRound,
    generateTopicFromStatement,
  } = useMeetingRoomStore();

  // 初始化協調器
  const initializeOrchestrator = useCallback(() => {
    if (orchestratorRef.current) {
      orchestratorRef.current.reset();
    }

    orchestratorRef.current = new DebateOrchestrator({
      onStateChange: (state, data?: unknown) => {
        console.log('Debate state changed:', state, data);
        
        switch (state) {
          case DebateState.READY:
            setDebateStatus('preparing');
            setLoading(false);
            break;
          case DebateState.RUNNING:
            setDebateStatus('debating');
            break;
          case DebateState.SEARCHING:
            setDebateStatus('searching');
            setLoading(true);
            break;
          case DebateState.PAUSED:
            setDebateStatus('paused');
            break;
          case DebateState.COMPLETED:
            setDebateStatus('completed');
            setCurrentSpeaker(null);
            setLoading(false);
            break;
          case DebateState.ERROR:
            setDebateStatus('error');
            setLoading(false);
            setError((data as { error?: string })?.error || '未知錯誤');
            break;
          case DebateState.INITIALIZING:
            setLoading(true);
            break;
          default:
            break;
        }
      },
      
      onStatementAdded: (statement: Statement) => {
        addStatement(statement);
        
        // 如果這是第一個發言且主題未設定或為默認值，自動生成主題
        if (currentRoom && 
            (currentRoom.topic === '討論議題' || currentRoom.topic === '' || !currentRoom.topic) &&
            currentRoom.statements.length === 0) {
          // 使用新添加的發言生成主題
          generateTopicFromStatement(statement.content);
        }
      },
      
      onConsensusUpdate: (consensus: ConsensusData) => {
        updateConsensus(consensus);
      },
      
      onError: (error: string) => {
        setError(error);
        setLoading(false);
      },
      
      onRoundComplete: (round: number, roundData: unknown) => {
        nextRound();
        console.log(`Round ${round} completed`, roundData);
      },
      
      onDebateComplete: (result: unknown) => {
        console.log('Debate completed:', result);
        setCurrentSpeaker(null);
      },
    });

    setIsInitialized(true);
  }, [
    currentRoom,
    setDebateStatus,
    setCurrentSpeaker,
    addStatement,
    updateConsensus,
    setError,
    setLoading,
    nextRound,
    generateTopicFromStatement,
  ]);

  // 初始化辯論
  const initializeDebate = useCallback(async (room: MeetingRoom) => {
    if (!orchestratorRef.current) {
      initializeOrchestrator();
    }

    try {
      setLoading(true);
      setError(null);
      await orchestratorRef.current!.initializeDebate(room);
    } catch (error) {
      setError(error instanceof Error ? error.message : '初始化失敗');
      setLoading(false);
    }
  }, [initializeOrchestrator, setLoading, setError]);

  // 開始辯論
  const startDebate = useCallback(async (initialTopic?: string) => {
    if (!orchestratorRef.current) {
      setError('協調器未初始化');
      return;
    }

    try {
      setError(null);
      
      // 如果提供了初始議題，先更新會議室主題
      if (initialTopic && currentRoom) {
        const { updateRoom } = useMeetingRoomStore.getState();
        updateRoom(currentRoom.id, {
          topic: initialTopic,
          isTopicGenerated: false
        });
      }
      
      await orchestratorRef.current.startDebate();
    } catch (error) {
      setError(error instanceof Error ? error.message : '開始辯論失敗');
    }
  }, [setError, currentRoom]);

  // 暫停辯論
  const pauseDebate = useCallback(() => {
    if (orchestratorRef.current) {
      orchestratorRef.current.pauseDebate();
    }
  }, []);

  // 恢復辯論
  const resumeDebate = useCallback(async () => {
    if (!orchestratorRef.current) {
      setError('協調器未初始化');
      return;
    }

    try {
      setError(null);
      await orchestratorRef.current.resumeDebate();
    } catch (error) {
      setError(error instanceof Error ? error.message : '恢復辯論失敗');
    }
  }, [setError]);

  // 停止辯論
  const stopDebate = useCallback(() => {
    if (orchestratorRef.current) {
      orchestratorRef.current.stopDebate();
    }
  }, []);

  // 獲取當前狀態
  const getOrchestratorState = useCallback(() => {
    return orchestratorRef.current?.getState() || null;
  }, []);

  // 重置協調器
  const resetOrchestrator = useCallback(() => {
    if (orchestratorRef.current) {
      orchestratorRef.current.reset();
    }
    setIsInitialized(false);
  }, []);

  // 組件卸載時清理
  useEffect(() => {
    return () => {
      if (orchestratorRef.current) {
        orchestratorRef.current.reset();
      }
    };
  }, []);

  // 當前會議室變化時重新初始化
  useEffect(() => {
    if (currentRoom && isInitialized) {
      initializeDebate(currentRoom);
    }
  }, [currentRoom, isInitialized, initializeDebate]);

  return {
    // 狀態
    isInitialized,
    get orchestratorState() {
      return orchestratorRef.current?.getState() || null;
    },
    
    // 方法
    initializeOrchestrator,
    initializeDebate,
    startDebate,
    pauseDebate,
    resumeDebate,
    stopDebate,
    resetOrchestrator,
    getOrchestratorState,
  };
};

/**
 * 辯論控制 Hook - 提供簡化的辯論控制介面
 */
export const useDebateControl = () => {
  const {
    initializeDebate,
    startDebate,
    pauseDebate,
    resumeDebate,
    stopDebate,
    isInitialized,
  } = useDebateOrchestrator();
  
  const {
    currentRoom,
    debateStatus,
    isLoading,
    error,
    availablePersonas,
  } = useMeetingRoomStore();

  // 檢查是否可以開始辯論
  const canStartDebate = useCallback(() => {
    if (!currentRoom) return false;
    if (!isInitialized) return false;
    if (debateStatus !== 'idle' && debateStatus !== 'preparing') return false;
    
    const activePersonas = availablePersonas.filter(p => p.isActive);
    return activePersonas.length >= 2;
  }, [currentRoom, isInitialized, debateStatus, availablePersonas]);

  // 檢查是否可以暫停辯論
  const canPauseDebate = useCallback(() => {
    return debateStatus === 'debating' && !isLoading;
  }, [debateStatus, isLoading]);

  // 檢查是否可以恢復辯論
  const canResumeDebate = useCallback(() => {
    return debateStatus === 'paused';
  }, [debateStatus]);

  // 檢查是否可以停止辯論
  const canStopDebate = useCallback(() => {
    return ['preparing', 'searching', 'debating', 'paused'].includes(debateStatus);
  }, [debateStatus]);

  // 自動初始化
  useEffect(() => {
    if (currentRoom && !isInitialized) {
      initializeDebate(currentRoom);
    }
  }, [currentRoom, isInitialized, initializeDebate]);

  return {
    // 狀態
    currentRoom,
    debateStatus,
    isLoading,
    error,
    isInitialized,
    
    // 檢查方法
    canStartDebate: canStartDebate(),
    canPauseDebate: canPauseDebate(),
    canResumeDebate: canResumeDebate(),
    canStopDebate: canStopDebate(),
    
    // 控制方法
    startDebate: (initialTopic?: string) => startDebate(initialTopic),
    pauseDebate,
    resumeDebate,
    stopDebate,
  };
};

const debateOrchestratorExports = { useDebateOrchestrator, useDebateControl };

export default debateOrchestratorExports;
</file>

<file path="src/stores/enhancedMeetingRoomStore.ts">
import { create } from 'zustand';
import { persist, subscribeWithSelector } from 'zustand/middleware';
import { MeetingRoom, Persona, Statement, DebateStatus, ConsensusData, SearchResult, UserPreferences } from '@/types';
import { PersonaEngine } from '@/services/personaEngine';
import { calculateConsensus, generateId, extractTopicFromContent } from '@/utils';

interface MeetingRoomState {
  // 當前會議室狀態
  currentRoom: MeetingRoom | null;
  
  // 所有會議室
  rooms: MeetingRoom[];
  
  // 可用替身
  availablePersonas: Persona[];
  
  // 辯論狀態
  debateStatus: DebateStatus;
  currentRound: number;
  currentSpeaker: string | null;
  
  // 控制狀態
  isLoading: boolean;
  error: string | null;
  
  // 用戶偏好設定
  userPreferences: UserPreferences;
  
  // Actions
  createRoom: (name: string, topic?: string) => string;
  selectRoom: (roomId: string) => void;
  updateRoom: (roomId: string, updates: Partial<MeetingRoom>) => void;
  deleteRoom: (roomId: string) => void;
  
  // 替身管理
  addPersona: (persona: Omit<Persona, 'id'>) => void;
  updatePersona: (personaId: string, updates: Partial<Persona>) => void;
  deletePersona: (personaId: string) => void;
  togglePersonaActive: (personaId: string) => void;
  duplicatePersona: (personaId: string) => void;
  resetPersonasToDefault: () => void;
  
  // 辯論控制
  startDebate: () => void;
  pauseDebate: () => void;
  resumeDebate: () => void;
  stopDebate: () => void;
  nextRound: () => void;
  resetDebate: () => void;
  generateTopicFromStatement: (statement: string) => Promise<void>;
  
  // 發言管理
  addStatement: (statement: Omit<Statement, 'id' | 'timestamp'>) => void;
  updateStatement: (statementId: string, updates: Partial<Statement>) => void;
  deleteStatement: (statementId: string) => void;
  updateConsensus: (consensus: ConsensusData) => void;
  addSearchResults: (results: SearchResult) => void;
  
  // 狀態管理
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  setDebateStatus: (status: DebateStatus) => void;
  setCurrentSpeaker: (speakerId: string | null) => void;
  
  // 用戶偏好
  updateUserPreferences: (preferences: Partial<UserPreferences>) => void;
  
  // 自動保存
  enableAutoSave: () => void;
  disableAutoSave: () => void;
  
  // 重置
  reset: () => void;
  resetAll: () => void;
}

const defaultPersonas: Persona[] = [
  {
    id: 'ceo-001',
    name: 'CEO',
    role: '執行長',
    identity: '公司執行長，擁有 15 年企業管理經驗',
    primeDirective: '追求公司整體利益最大化，平衡各方利益相關者需求',
    toneStyle: '權威、決斷、具有遠見，習慣從戰略高度分析問題',
    defaultBias: '傾向於支持能帶來長期價值的創新方案',
    ragFocus: ['企業戰略', '市場趨勢', '競爭分析', '投資回報'],
    temperature: 0.7,
    systemPrompt: '你是一位經驗豐富的執行長，專注於商業價值和長期發展。',
    color: '#1f2937',
    isActive: false,
  },
  {
    id: 'cto-001',
    name: 'CTO',
    role: '技術長',
    identity: '技術長，專精於技術架構和創新',
    primeDirective: '推動技術創新，確保技術方案的可行性和先進性',
    toneStyle: '理性、技術導向、注重實現細節和技術風險',
    defaultBias: '支持技術先進且可擴展的解決方案',
    ragFocus: ['技術趨勢', '架構設計', '開發成本', '技術風險'],
    temperature: 0.6,
    systemPrompt: '你是一位技術專家，專注於技術創新和系統穩定性。',
    color: '#059669',
    isActive: false,
  },
  {
    id: 'cfo-001',
    name: 'CFO',
    role: '財務長',
    identity: '財務長，擁有 20 年金融和風險管理經驗',
    primeDirective: '保護股東價值，最大化投資回報率並嚴格控制預算',
    toneStyle: '謹慎、數據驅動、習慣引用財務數據和成本效益分析',
    defaultBias: '對高資本支出持懷疑態度，要求明確的財務模型',
    ragFocus: ['財務報告', '成本分析', '投資回報', '風險評估'],
    temperature: 0.4,
    systemPrompt: '你是一位財務專家，專注於成本控制和投資回報。',
    color: '#dc2626',
    isActive: false,
  },
  {
    id: 'env-001',
    name: '環保倡議者',
    role: '環境保護專家',
    identity: '環境保護專家，致力於可持續發展',
    primeDirective: '推動環境友善的解決方案，確保企業責任',
    toneStyle: '熱情、理想主義、引用環境數據和可持續發展研究',
    defaultBias: '強烈支持綠色環保的方案',
    ragFocus: ['環境影響', '可持續發展', '綠色技術', '環保法規'],
    temperature: 0.8,
    systemPrompt: '你是一位環保專家，專注於可持續發展和環境保護。',
    color: '#16a34a',
    isActive: false,
  },
  {
    id: 'legal-001',
    name: '法律顧問',
    role: '法律顧問',
    identity: '資深律師，專精企業法務和合規',
    primeDirective: '確保所有決策符合法律規範，降低法律風險',
    toneStyle: '嚴謹、保守、引用法律條文和判例',
    defaultBias: '傾向於選擇法律風險較低的方案',
    ragFocus: ['法律法規', '合規要求', '判例分析', '風險評估'],
    temperature: 0.3,
    systemPrompt: '你是一位法律專家，專注於合規和風險控制。',
    color: '#7c3aed',
    isActive: false,
  },
  {
    id: 'market-001',
    name: '市場分析師',
    role: '市場分析師',
    identity: '市場研究專家，專精消費者行為分析',
    primeDirective: '深入了解市場需求，預測消費者反應',
    toneStyle: '分析性、數據導向、引用市場調研和消費者數據',
    defaultBias: '支持符合市場需求和消費者期待的方案',
    ragFocus: ['市場調研', '消費者行為', '競爭分析', '趨勢預測'],
    temperature: 0.6,
    systemPrompt: '你是一位市場分析專家，專注於市場趨勢和消費者行為。',
    color: '#ea580c',
    isActive: false,
  },
];

const defaultUserPreferences: UserPreferences = {
  theme: 'auto',
  language: 'zh-TW',
  autoSave: true,
  notificationsEnabled: true,
  defaultMeetingSettings: {
    maxRounds: 5,
    consensusThreshold: 0.7,
    timeoutPerRound: 300,
    allowUserIntervention: true,
    autoSaveInterval: 30,
  },
};

let autoSaveInterval: NodeJS.Timeout | null = null;

export const useMeetingRoomStore = create<MeetingRoomState>()(
  subscribeWithSelector(
    persist(
      (set, get) => ({
        // 初始狀態
        currentRoom: null,
        rooms: [],
        availablePersonas: defaultPersonas,
        debateStatus: 'idle',
        currentRound: 0,
        currentSpeaker: null,
        isLoading: false,
        error: null,
        userPreferences: defaultUserPreferences,

        // 會議室管理
        createRoom: (name: string, topic?: string) => {
          const roomId = generateId();
          const newRoom: MeetingRoom = {
            id: roomId,
            name,
            topic: topic || '', // 允許空主題，將在第一個發言後自動生成
            createdAt: Date.now(),
            updatedAt: Date.now(),
            status: 'idle',
            participants: [],
            statements: [],
            searchResults: [],
            settings: { ...get().userPreferences.defaultMeetingSettings },
            isTopicGenerated: false, // 初始為 false，當 AI 生成主題時設為 true
          };
          
          set((currentState) => ({
            rooms: [...currentState.rooms, newRoom],
            currentRoom: newRoom,
          }));
          
          return roomId;
        },

        selectRoom: (roomId: string) => {
          const room = get().rooms.find(r => r.id === roomId);
          if (room) {
            set({ 
              currentRoom: room, 
              debateStatus: room.status,
              currentRound: room.statements.length > 0 ? 
                Math.max(...room.statements.map(s => s.round)) : 0,
            });
          }
        },

        updateRoom: (roomId: string, updates: Partial<MeetingRoom>) => {
          set((currentState) => ({
            rooms: currentState.rooms.map(room =>
              room.id === roomId
                ? { ...room, ...updates, updatedAt: Date.now() }
                : room
            ),
            currentRoom: currentState.currentRoom?.id === roomId
              ? { ...currentState.currentRoom, ...updates, updatedAt: Date.now() }
              : currentState.currentRoom,
          }));
        },

        deleteRoom: (roomId: string) => {
          set((currentState) => ({
            rooms: currentState.rooms.filter(room => room.id !== roomId),
            currentRoom: currentState.currentRoom?.id === roomId ? null : currentState.currentRoom,
          }));
        },

        // 替身管理
        addPersona: (persona: Omit<Persona, 'id'>) => {
          const newPersona: Persona = {
            ...persona,
            id: generateId(),
            color: persona.color || PersonaEngine.suggestPersonaColor(persona as Persona),
          };
          
          set((state) => ({
            availablePersonas: [...state.availablePersonas, newPersona],
          }));
        },

        updatePersona: (personaId: string, updates: Partial<Persona>) => {
          set((state) => ({
            availablePersonas: state.availablePersonas.map(persona =>
              persona.id === personaId ? { ...persona, ...updates } : persona
            ),
          }));
        },

        deletePersona: (personaId: string) => {
          set((state) => ({
            availablePersonas: state.availablePersonas.filter(p => p.id !== personaId),
          }));
        },

        togglePersonaActive: (personaId: string) => {
          set((state) => {
            const updatedPersonas = state.availablePersonas.map(persona =>
              persona.id === personaId ? { ...persona, isActive: !persona.isActive } : persona
            );
            
            const activePersonas = updatedPersonas.filter(p => p.isActive);
            
            return {
              availablePersonas: updatedPersonas,
              currentRoom: state.currentRoom ? {
                ...state.currentRoom,
                participants: activePersonas,
                updatedAt: Date.now(),
              } : null,
            };
          });
        },

        duplicatePersona: (personaId: string) => {
          const persona = get().availablePersonas.find(p => p.id === personaId);
          if (persona) {
            const duplicatedPersona: Persona = {
              ...persona,
              id: generateId(),
              name: `${persona.name} (副本)`,
              isActive: false,
            };
            
            set((state) => ({
              availablePersonas: [...state.availablePersonas, duplicatedPersona],
            }));
          }
        },

        resetPersonasToDefault: () => {
          set({ availablePersonas: defaultPersonas });
        },

        // 辯論控制
        startDebate: () => {
          set(() => ({
            debateStatus: 'preparing',
            currentRound: 1,
            error: null,
          }));
          
          if (get().currentRoom) {
            get().updateRoom(get().currentRoom!.id, { status: 'preparing' });
          }
        },

        pauseDebate: () => {
          set({ debateStatus: 'paused' });
          if (get().currentRoom) {
            get().updateRoom(get().currentRoom!.id, { status: 'paused' });
          }
        },

        resumeDebate: () => {
          set({ debateStatus: 'debating' });
          if (get().currentRoom) {
            get().updateRoom(get().currentRoom!.id, { status: 'debating' });
          }
        },

        stopDebate: () => {
          set({
            debateStatus: 'completed',
            currentSpeaker: null,
          });
          if (get().currentRoom) {
            get().updateRoom(get().currentRoom!.id, { status: 'completed' });
          }
        },

        nextRound: () => {
          set((state) => ({
            currentRound: state.currentRound + 1,
          }));
        },

        resetDebate: () => {
          set({
            debateStatus: 'idle',
            currentRound: 0,
            currentSpeaker: null,
            error: null,
          });
          
          if (get().currentRoom) {
            get().updateRoom(get().currentRoom!.id, { 
              status: 'idle',
              statements: [],
              searchResults: [],
              consensus: undefined,
            });
          }
        },

        // 發言管理
        addStatement: (statement: Omit<Statement, 'id' | 'timestamp'>) => {
          const newStatement: Statement = {
            ...statement,
            id: generateId(),
            timestamp: Date.now(),
          };
          
          set((state) => {
            if (!state.currentRoom) return state;
            
            const updatedRoom = {
              ...state.currentRoom,
              statements: [...state.currentRoom.statements, newStatement],
              updatedAt: Date.now(),
            };
            
            // 如果是第一個發言且沒有主題，嘗試從發言內容生成主題
            if (updatedRoom.statements.length === 1 && !updatedRoom.topic.trim()) {
              // 從發言內容提取關鍵詞作為主題
              const content = newStatement.content;
              const generatedTopic = extractTopicFromContent(content);
              if (generatedTopic) {
                updatedRoom.topic = generatedTopic;
                updatedRoom.isTopicGenerated = true;
              }
            }
            
            // 自動計算共識
            const scores = updatedRoom.statements.map(s => s.tendencyScore);
            const consensus = calculateConsensus(scores);
            updatedRoom.consensus = consensus;
            
            return {
              currentRoom: updatedRoom,
              rooms: state.rooms.map(room =>
                room.id === updatedRoom.id ? updatedRoom : room
              ),
            };
          });
        },

        updateStatement: (statementId: string, updates: Partial<Statement>) => {
          set((state) => {
            if (!state.currentRoom) return state;
            
            const updatedRoom = {
              ...state.currentRoom,
              statements: state.currentRoom.statements.map(stmt =>
                stmt.id === statementId ? { ...stmt, ...updates } : stmt
              ),
              updatedAt: Date.now(),
            };
            
            return {
              currentRoom: updatedRoom,
              rooms: state.rooms.map(room =>
                room.id === updatedRoom.id ? updatedRoom : room
              ),
            };
          });
        },

        deleteStatement: (statementId: string) => {
          set((state) => {
            if (!state.currentRoom) return state;
            
            const updatedRoom = {
              ...state.currentRoom,
              statements: state.currentRoom.statements.filter(stmt => stmt.id !== statementId),
              updatedAt: Date.now(),
            };
            
            return {
              currentRoom: updatedRoom,
              rooms: state.rooms.map(room =>
                room.id === updatedRoom.id ? updatedRoom : room
              ),
            };
          });
        },

        updateConsensus: (consensus: ConsensusData) => {
          const currentRoom = get().currentRoom;
          if (currentRoom) {
            get().updateRoom(currentRoom.id, { consensus });
          }
        },

        addSearchResults: (results: SearchResult) => {
          set((state) => {
            if (!state.currentRoom) return state;
            
            const updatedRoom = {
              ...state.currentRoom,
              searchResults: [...state.currentRoom.searchResults, results],
              updatedAt: Date.now(),
            };
            
            return {
              currentRoom: updatedRoom,
              rooms: state.rooms.map(room =>
                room.id === updatedRoom.id ? updatedRoom : room
              ),
            };
          });
        },

        // 狀態管理
        setLoading: (loading: boolean) => set({ isLoading: loading }),
        setError: (error: string | null) => set({ error }),
        setDebateStatus: (status: DebateStatus) => set({ debateStatus: status }),
        setCurrentSpeaker: (speakerId: string | null) => set({ currentSpeaker: speakerId }),

        // 用戶偏好
        updateUserPreferences: (preferences: Partial<UserPreferences>) => {
          set((state) => ({
            userPreferences: { ...state.userPreferences, ...preferences },
          }));
        },

        // 自動保存
        enableAutoSave: () => {
          const state = get();
          if (autoSaveInterval) clearInterval(autoSaveInterval);
          
          autoSaveInterval = setInterval(() => {
            const currentState = get();
            if (currentState.currentRoom && currentState.debateStatus === 'debating') {
              // 自動保存邏輯已經在 persist 中間件中處理
              console.log('Auto-saving meeting room state...');
            }
          }, state.userPreferences.defaultMeetingSettings.autoSaveInterval * 1000);
        },

        disableAutoSave: () => {
          if (autoSaveInterval) {
            clearInterval(autoSaveInterval);
            autoSaveInterval = null;
          }
        },

        // 重置
        reset: () => set({
          currentRoom: null,
          debateStatus: 'idle',
          currentRound: 0,
          currentSpeaker: null,
          isLoading: false,
          error: null,
        }),

        resetAll: () => set({
          currentRoom: null,
          rooms: [],
          availablePersonas: defaultPersonas,
          debateStatus: 'idle',
          currentRound: 0,
          currentSpeaker: null,
          isLoading: false,
          error: null,
          userPreferences: defaultUserPreferences,
        }),

        // 主題生成
        generateTopicFromStatement: async (statement: string) => {
          try {
            const response = await fetch('/api/generate-topic', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                firstStatement: statement,
                context: get().currentRoom?.name,
              }),
            });

            if (response.ok) {
              const data = await response.json();
              const generatedTopic = data.topic;
              
              const currentRoom = get().currentRoom;
              if (currentRoom && generatedTopic) {
                get().updateRoom(currentRoom.id, {
                  topic: generatedTopic,
                  isTopicGenerated: true,
                });
              }
            }
          } catch (error) {
            console.error('生成主題失敗:', error);
            // 靜默失敗，不影響辯論流程
          }
        },
      }),
      {
        name: 'meeting-room-storage',
        partialize: (state) => ({
          rooms: state.rooms as unknown[],
          availablePersonas: state.availablePersonas as unknown[],
          userPreferences: state.userPreferences as import('@/types/gemini').PersistedState['userPreferences'],
        }),
        version: 1,
        migrate: (persistedState: unknown, version: number) => {
          // 確保 persistedState 存在
          if (!persistedState) {
            return {
              rooms: [],
              availablePersonas: defaultPersonas,
              userPreferences: {},
            };
          }

          const state = persistedState as import('@/types/gemini').PersistedState;

          // 版本遷移邏輯
          if (version === 0 || !version) {
            // 從版本 0 或無版本升級到版本 1
            return {
              rooms: state.rooms || [],
              availablePersonas: state.availablePersonas || defaultPersonas,
              userPreferences: {},
            };
          }

          // 確保所有必要字段存在
          return {
            rooms: state.rooms || [],
            availablePersonas: state.availablePersonas || defaultPersonas,
            userPreferences: {},
          };
        },
      }
    )
  )
);

// 訢閱狀態變化以實現自動保存
useMeetingRoomStore.subscribe(
  (state) => state.userPreferences.autoSave,
  (autoSave) => {
    if (autoSave) {
      useMeetingRoomStore.getState().enableAutoSave();
    } else {
      useMeetingRoomStore.getState().disableAutoSave();
    }
  }
);

// 初始化自動保存
if (typeof window !== 'undefined') {
  const initialState = useMeetingRoomStore.getState();
  if (initialState.userPreferences.autoSave) {
    initialState.enableAutoSave();
  }
}

export default useMeetingRoomStore;
</file>

<file path="src/stores/meetingRoomStore.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { MeetingRoom, Persona, Statement, DebateStatus, ConsensusData, SearchResult } from '@/types';

interface MeetingRoomState {
  // 當前會議室狀態
  currentRoom: MeetingRoom | null;
  
  // 所有會議室
  rooms: MeetingRoom[];
  
  // 可用替身
  availablePersonas: Persona[];
  
  // 辯論狀態
  debateStatus: DebateStatus;
  currentRound: number;
  currentSpeaker: Persona | null;
  
  // 控制狀態
  isLoading: boolean;
  error: string | null;
  
  // Actions
  createRoom: (name: string, topic: string) => string;
  selectRoom: (roomId: string) => void;
  updateRoom: (roomId: string, updates: Partial<MeetingRoom>) => void;
  deleteRoom: (roomId: string) => void;
  
  // 替身管理
  addPersona: (persona: Omit<Persona, 'id'>) => void;
  updatePersona: (personaId: string, updates: Partial<Persona>) => void;
  deletePersona: (personaId: string) => void;
  togglePersonaActive: (personaId: string) => void;
  
  // 辯論控制
  startDebate: (initialTopic?: string) => void;
  pauseDebate: () => void;
  resumeDebate: () => void;
  stopDebate: () => void;
  nextRound: () => void;
  generateTopicFromStatement: (statement: string) => Promise<void>;
  
  // 發言管理
  addStatement: (statement: Omit<Statement, 'id' | 'timestamp'>) => void;
  updateConsensus: (consensus: ConsensusData) => void;
  addSearchResults: (results: SearchResult) => void;
  
  // 狀態管理
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  setDebateStatus: (status: DebateStatus) => void;
  setCurrentSpeaker: (speaker: Persona | null) => void;
  
  // 重置
  reset: () => void;
}

const generateId = () => Math.random().toString(36).substr(2, 9);

const defaultPersonas: Persona[] = [
  {
    id: 'ceo-001',
    name: 'CEO',
    role: '執行長',
    identity: '公司執行長，擁有 15 年企業管理經驗',
    primeDirective: '追求公司整體利益最大化，平衡各方利益相關者需求',
    toneStyle: '權威、決斷、具有遠見，習慣從戰略高度分析問題',
    defaultBias: '傾向於支持能帶來長期價值的創新方案',
    ragFocus: ['企業戰略', '市場趨勢', '競爭分析', '投資回報'],
    temperature: 0.7,
    systemPrompt: '你是一位經驗豐富的執行長，專注於商業價值和長期發展。',
    color: '#1f2937',
    isActive: false,
  },
  {
    id: 'cto-001',
    name: 'CTO',
    role: '技術長',
    identity: '技術長，專精於技術架構和創新',
    primeDirective: '推動技術創新，確保技術方案的可行性和先進性',
    toneStyle: '理性、技術導向、注重實現細節和技術風險',
    defaultBias: '支持技術先進且可擴展的解決方案',
    ragFocus: ['技術趨勢', '架構設計', '開發成本', '技術風險'],
    temperature: 0.6,
    systemPrompt: '你是一位技術專家，專注於技術創新和系統穩定性。',
    color: '#059669',
    isActive: false,
  },
  {
    id: 'cfo-001',
    name: 'CFO',
    role: '財務長',
    identity: '財務長，擁有 20 年金融和風險管理經驗',
    primeDirective: '保護股東價值，最大化投資回報率並嚴格控制預算',
    toneStyle: '謹慎、數據驅動、習慣引用財務數據和成本效益分析',
    defaultBias: '對高資本支出持懷疑態度，要求明確的財務模型',
    ragFocus: ['財務報告', '成本分析', '投資回報', '風險評估'],
    temperature: 0.4,
    systemPrompt: '你是一位財務專家，專注於成本控制和投資回報。',
    color: '#dc2626',
    isActive: false,
  },
  {
    id: 'env-001',
    name: '環保倡議者',
    role: '環境保護專家',
    identity: '環境保護專家，致力於可持續發展',
    primeDirective: '推動環境友善的解決方案，確保企業責任',
    toneStyle: '熱情、理想主義、引用環境數據和可持續發展研究',
    defaultBias: '強烈支持綠色環保的方案',
    ragFocus: ['環境影響', '可持續發展', '綠色技術', '環保法規'],
    temperature: 0.8,
    systemPrompt: '你是一位環保專家，專注於可持續發展和環境保護。',
    color: '#16a34a',
    isActive: false,
  },
  {
    id: 'legal-001',
    name: '法律顧問',
    role: '法律顧問',
    identity: '資深律師，專精企業法務和合規',
    primeDirective: '確保所有決策符合法律規範，降低法律風險',
    toneStyle: '嚴謹、保守、引用法律條文和判例',
    defaultBias: '傾向於選擇法律風險較低的方案',
    ragFocus: ['法律法規', '合規要求', '判例分析', '風險評估'],
    temperature: 0.3,
    systemPrompt: '你是一位法律專家，專注於合規和風險控制。',
    color: '#7c3aed',
    isActive: false,
  },
  {
    id: 'market-001',
    name: '市場分析師',
    role: '市場分析師',
    identity: '市場研究專家，專精消費者行為分析',
    primeDirective: '深入了解市場需求，預測消費者反應',
    toneStyle: '分析性、數據導向、引用市場調研和消費者數據',
    defaultBias: '支持符合市場需求和消費者期待的方案',
    ragFocus: ['市場調研', '消費者行為', '競爭分析', '趨勢預測'],
    temperature: 0.6,
    systemPrompt: '你是一位市場分析專家，專注於市場趨勢和消費者行為。',
    color: '#ea580c',
    isActive: false,
  },
];

export const useMeetingRoomStore = create<MeetingRoomState>()(
  persist(
    (set, get) => ({
      // 初始狀態
      currentRoom: null,
      rooms: [],
      availablePersonas: defaultPersonas,
      debateStatus: 'idle',
      currentRound: 0,
      currentSpeaker: null,
      isLoading: false,
      error: null,

      // 會議室管理
      createRoom: (name: string, topic: string) => {
        const roomId = generateId();
        const newRoom: MeetingRoom = {
          id: roomId,
          name,
          topic,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          status: 'idle',
          participants: [],
          statements: [],
          searchResults: [],
          settings: {
            maxRounds: 5,
            consensusThreshold: 0.7,
            timeoutPerRound: 300000, // 5分鐘，確保不少於30秒
            allowUserIntervention: true,
            autoSaveInterval: 30,
          },
        };
        
        set((currentState) => ({
          rooms: [...currentState.rooms, newRoom],
          currentRoom: newRoom,
        }));
        
        return roomId;
      },

      selectRoom: (roomId: string) => {
        const room = get().rooms.find(r => r.id === roomId);
        if (room) {
          set({ currentRoom: room, debateStatus: room.status });
        }
      },

      updateRoom: (roomId: string, updates: Partial<MeetingRoom>) => {
        set((state) => ({
          rooms: state.rooms.map((room: import('@/types').MeetingRoom) =>
            room.id === roomId
              ? { ...room, ...updates, updatedAt: Date.now() }
              : room
          ),
          currentRoom: state.currentRoom?.id === roomId
            ? { ...state.currentRoom, ...updates, updatedAt: Date.now() }
            : state.currentRoom,
        }));
      },

      deleteRoom: (roomId: string) => {
        set((state) => ({
          rooms: state.rooms.filter(room => room.id !== roomId),
          currentRoom: state.currentRoom?.id === roomId ? null : state.currentRoom,
        }));
      },

      // 替身管理
      addPersona: (persona: Omit<Persona, 'id'>) => {
        const newPersona: Persona = {
          ...persona,
          id: generateId(),
        };
        
        set((state) => ({
          availablePersonas: [...state.availablePersonas, newPersona],
        }));
      },

      updatePersona: (personaId: string, updates: Partial<Persona>) => {
        set((state) => ({
          availablePersonas: state.availablePersonas.map(persona =>
            persona.id === personaId ? { ...persona, ...updates } : persona
          ),
        }));
      },

      deletePersona: (personaId: string) => {
        set((state) => ({
          availablePersonas: state.availablePersonas.filter(p => p.id !== personaId),
        }));
      },

      togglePersonaActive: (personaId: string) => {
        set((currentState) => {
          const updatedPersonas = currentState.availablePersonas.map(persona =>
            persona.id === personaId ? { ...persona, isActive: !persona.isActive } : persona
          );
          
          const activePersonas = updatedPersonas.filter(p => p.isActive);
          
          return {
            availablePersonas: updatedPersonas,
            currentRoom: currentState.currentRoom ? {
              ...currentState.currentRoom,
              participants: activePersonas,
              updatedAt: Date.now(),
            } : null,
          };
        });
      },

      // 辯論控制
      startDebate: (initialTopic?: string) => {
        set(() => ({
          debateStatus: 'preparing',
          currentRound: 1,
          error: null,
        }));
        
        if (get().currentRoom) {
          const updates: Partial<MeetingRoom> = { status: 'preparing' };
          
          // 如果提供了初始議題，更新會議室主題
          if (initialTopic) {
            updates.topic = initialTopic;
            updates.isTopicGenerated = false; // 用戶提供的主題
          }
          
          get().updateRoom(get().currentRoom!.id, updates);
        }
      },

      pauseDebate: () => {
        set({ debateStatus: 'paused' });
        if (get().currentRoom) {
          get().updateRoom(get().currentRoom!.id, { status: 'paused' });
        }
      },

      resumeDebate: () => {
        set({ debateStatus: 'debating' });
        if (get().currentRoom) {
          get().updateRoom(get().currentRoom!.id, { status: 'debating' });
        }
      },

      stopDebate: () => {
        set({
          debateStatus: 'completed',
          currentSpeaker: null,
        });
        if (get().currentRoom) {
          get().updateRoom(get().currentRoom!.id, { status: 'completed' });
        }
      },

      nextRound: () => {
        set((state) => ({
          currentRound: state.currentRound + 1,
        }));
      },

      // 發言管理
      addStatement: (statement: Omit<Statement, 'id' | 'timestamp'>) => {
        const newStatement: Statement = {
          ...statement,
          id: generateId(),
          timestamp: Date.now(),
        };
        
        set((state) => {
          if (!state.currentRoom) return state;
          
          const updatedRoom = {
            ...state.currentRoom,
            statements: [...state.currentRoom.statements, newStatement],
            updatedAt: Date.now(),
          };
          
          return {
            currentRoom: updatedRoom,
            rooms: state.rooms.map(room =>
              room.id === updatedRoom.id ? updatedRoom : room
            ),
          };
        });
      },

      updateConsensus: (consensus: ConsensusData) => {
        const currentRoom = get().currentRoom;
        if (currentRoom) {
          get().updateRoom(currentRoom.id, { consensus });
        }
      },

      addSearchResults: (results: SearchResult) => {
        set((state) => {
          if (!state.currentRoom) return state;
          
          const updatedRoom = {
            ...state.currentRoom,
            searchResults: [...state.currentRoom.searchResults, results],
            updatedAt: Date.now(),
          };
          
          return {
            currentRoom: updatedRoom,
            rooms: state.rooms.map(room =>
              room.id === updatedRoom.id ? updatedRoom : room
            ),
          };
        });
      },

      // 主題生成
      generateTopicFromStatement: async (statement: string) => {
        try {
          const response = await fetch('/api/generate-topic', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              firstStatement: statement,
              context: get().currentRoom?.name,
            }),
          });

          if (response.ok) {
            const data = await response.json();
            const generatedTopic = data.topic;
            
            const currentRoom = get().currentRoom;
            if (currentRoom && generatedTopic) {
              get().updateRoom(currentRoom.id, {
                topic: generatedTopic,
                isTopicGenerated: true,
              });
            }
          }
        } catch (error) {
          console.error('生成主題失敗:', error);
          // 靜默失敗，不影響辯論流程
        }
      },

      // 狀態管理
      setLoading: (loading: boolean) => set({ isLoading: loading }),
      setError: (error: string | null) => set({ error }),
      setDebateStatus: (status: DebateStatus) => set({ debateStatus: status }),
      setCurrentSpeaker: (speaker: Persona | null) => set({ currentSpeaker: speaker }),

      // 重置
      reset: () => set({
        currentRoom: null,
        debateStatus: 'idle',
        currentRound: 0,
        currentSpeaker: null,
        isLoading: false,
        error: null,
      }),
    }),
    {
      name: 'meeting-room-storage',
      version: 1,
      migrate: (persistedState: unknown, version: number) => {
        if (version === 0) {
          const state = persistedState as import('@/types/gemini').PersistedState;
          // 從版本0遷移到版本1
          return {
            rooms: state?.rooms?.map((room: unknown) => {
              const typedRoom = room as import('@/types').MeetingRoom;
              
              return {
                ...typedRoom,
                settings: {
                  // 默認值
                  maxRounds: typedRoom.settings?.maxRounds || 5,
                  consensusThreshold: typedRoom.settings?.consensusThreshold || 0.7,
                  timeoutPerRound: Math.max(30000, typedRoom.settings?.timeoutPerRound || 300000),
                  allowUserIntervention: typedRoom.settings?.allowUserIntervention !== undefined ? 
                    typedRoom.settings.allowUserIntervention : true,
                  autoSaveInterval: typedRoom.settings?.autoSaveInterval || 30,
                }
              };
            }) || [],
            availablePersonas: state?.availablePersonas || []
          };
        }
        return persistedState as import('@/types/gemini').PersistedState;
      },
      partialize: (state) => ({
        rooms: state.rooms as unknown[],
        availablePersonas: state.availablePersonas as unknown[],
      }),
    }
  )
);
</file>

</files>
